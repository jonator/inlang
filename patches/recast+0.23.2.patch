diff --git a/node_modules/recast/.eslintrc.js b/node_modules/recast/.eslintrc.js
index 3403c26..0eb360a 100644
--- a/node_modules/recast/.eslintrc.js
+++ b/node_modules/recast/.eslintrc.js
@@ -12,5 +12,5 @@ module.exports = {
     "no-case-declarations": "error",
     "no-fallthrough": "error",
   },
-  ignorePatterns: ["test/data"],
+  ignorePatterns: ["test/data", "esm", "lib/**/*.js", "parsers/**/*.js"],
 };
diff --git a/node_modules/recast/.gitignore b/node_modules/recast/.gitignore
new file mode 100644
index 0000000..b6929cf
--- /dev/null
+++ b/node_modules/recast/.gitignore
@@ -0,0 +1,13 @@
+/node_modules
+/test/data/babylon
+/test/data/babel-parser
+/test/data/graphql-tools-src
+
+# Ignore TypeScript-emitted files
+*.js
+!.*rc.js
+*.d.ts
+esm
+# Except...
+!/types/**/*.d.ts
+
diff --git a/node_modules/recast/.npmignore b/node_modules/recast/.npmignore
new file mode 100644
index 0000000..60acfdb
--- /dev/null
+++ b/node_modules/recast/.npmignore
@@ -0,0 +1,7 @@
+/node_modules
+/test
+/types
+yarn.lock
+
+*.ts
+!*.d.ts
diff --git a/node_modules/recast/.prettierignore b/node_modules/recast/.prettierignore
index 047e508..979fe61 100644
--- a/node_modules/recast/.prettierignore
+++ b/node_modules/recast/.prettierignore
@@ -1,3 +1,4 @@
 *.d.ts
 test/data/
 /example
+/esm
diff --git a/node_modules/recast/esm/lib/comments.d.ts b/node_modules/recast/esm/lib/comments.d.ts
new file mode 100644
index 0000000..1c1df43
--- /dev/null
+++ b/node_modules/recast/esm/lib/comments.d.ts
@@ -0,0 +1,2 @@
+export declare function attach(comments: any[], ast: any, lines: any): void;
+export declare function printComments(path: any, print: any): any;
diff --git a/node_modules/recast/esm/lib/comments.mjs b/node_modules/recast/esm/lib/comments.mjs
new file mode 100644
index 0000000..9b43215
--- /dev/null
+++ b/node_modules/recast/esm/lib/comments.mjs
@@ -0,0 +1,306 @@
+import assert from "assert";
+import * as types from "ast-types";
+const n = types.namedTypes;
+const isArray = types.builtInTypes.array;
+const isObject = types.builtInTypes.object;
+import { Lines, concat } from "./lines.mjs";
+import { comparePos, fixFaultyLocations } from "./util.mjs";
+const childNodesCache = new WeakMap();
+// TODO Move a non-caching implementation of this function into ast-types,
+// and implement a caching wrapper function here.
+function getSortedChildNodes(node, lines, resultArray) {
+    if (!node) {
+        return resultArray;
+    }
+    // The .loc checks below are sensitive to some of the problems that
+    // are fixed by this utility function. Specifically, if it decides to
+    // set node.loc to null, indicating that the node's .loc information
+    // is unreliable, then we don't want to add node to the resultArray.
+    fixFaultyLocations(node, lines);
+    if (resultArray) {
+        if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {
+            // This reverse insertion sort almost always takes constant
+            // time because we almost always (maybe always?) append the
+            // nodes in order anyway.
+            let i = resultArray.length - 1;
+            for (; i >= 0; --i) {
+                const child = resultArray[i];
+                if (child &&
+                    child.loc &&
+                    comparePos(child.loc.end, node.loc.start) <= 0) {
+                    break;
+                }
+            }
+            resultArray.splice(i + 1, 0, node);
+            return resultArray;
+        }
+    }
+    else {
+        const childNodes = childNodesCache.get(node);
+        if (childNodes) {
+            return childNodes;
+        }
+    }
+    let names;
+    if (isArray.check(node)) {
+        names = Object.keys(node);
+    }
+    else if (isObject.check(node)) {
+        names = types.getFieldNames(node);
+    }
+    else {
+        return resultArray;
+    }
+    if (!resultArray) {
+        childNodesCache.set(node, (resultArray = []));
+    }
+    for (let i = 0, nameCount = names.length; i < nameCount; ++i) {
+        getSortedChildNodes(node[names[i]], lines, resultArray);
+    }
+    return resultArray;
+}
+// As efficiently as possible, decorate the comment object with
+// .precedingNode, .enclosingNode, and/or .followingNode properties, at
+// least one of which is guaranteed to be defined.
+function decorateComment(node, comment, lines) {
+    const childNodes = getSortedChildNodes(node, lines);
+    // Time to dust off the old binary search robes and wizard hat.
+    let left = 0;
+    let right = childNodes && childNodes.length;
+    let precedingNode;
+    let followingNode;
+    while (typeof right === "number" && left < right) {
+        const middle = (left + right) >> 1;
+        const child = childNodes[middle];
+        if (comparePos(child.loc.start, comment.loc.start) <= 0 &&
+            comparePos(comment.loc.end, child.loc.end) <= 0) {
+            // The comment is completely contained by this child node.
+            decorateComment((comment.enclosingNode = child), comment, lines);
+            return; // Abandon the binary search at this level.
+        }
+        if (comparePos(child.loc.end, comment.loc.start) <= 0) {
+            // This child node falls completely before the comment.
+            // Because we will never consider this node or any nodes
+            // before it again, this node must be the closest preceding
+            // node we have encountered so far.
+            precedingNode = child;
+            left = middle + 1;
+            continue;
+        }
+        if (comparePos(comment.loc.end, child.loc.start) <= 0) {
+            // This child node falls completely after the comment.
+            // Because we will never consider this node or any nodes after
+            // it again, this node must be the closest following node we
+            // have encountered so far.
+            followingNode = child;
+            right = middle;
+            continue;
+        }
+        throw new Error("Comment location overlaps with node location");
+    }
+    if (precedingNode) {
+        comment.precedingNode = precedingNode;
+    }
+    if (followingNode) {
+        comment.followingNode = followingNode;
+    }
+}
+export function attach(comments, ast, lines) {
+    if (!isArray.check(comments)) {
+        return;
+    }
+    const tiesToBreak = [];
+    comments.forEach(function (comment) {
+        comment.loc.lines = lines;
+        decorateComment(ast, comment, lines);
+        const pn = comment.precedingNode;
+        const en = comment.enclosingNode;
+        const fn = comment.followingNode;
+        if (pn && fn) {
+            const tieCount = tiesToBreak.length;
+            if (tieCount > 0) {
+                const lastTie = tiesToBreak[tieCount - 1];
+                assert.strictEqual(lastTie.precedingNode === comment.precedingNode, lastTie.followingNode === comment.followingNode);
+                if (lastTie.followingNode !== comment.followingNode) {
+                    breakTies(tiesToBreak, lines);
+                }
+            }
+            tiesToBreak.push(comment);
+        }
+        else if (pn) {
+            // No contest: we have a trailing comment.
+            breakTies(tiesToBreak, lines);
+            addTrailingComment(pn, comment);
+        }
+        else if (fn) {
+            // No contest: we have a leading comment.
+            breakTies(tiesToBreak, lines);
+            addLeadingComment(fn, comment);
+        }
+        else if (en) {
+            // The enclosing node has no child nodes at all, so what we
+            // have here is a dangling comment, e.g. [/* crickets */].
+            breakTies(tiesToBreak, lines);
+            addDanglingComment(en, comment);
+        }
+        else {
+            throw new Error("AST contains no nodes at all?");
+        }
+    });
+    breakTies(tiesToBreak, lines);
+    comments.forEach(function (comment) {
+        // These node references were useful for breaking ties, but we
+        // don't need them anymore, and they create cycles in the AST that
+        // may lead to infinite recursion if we don't delete them here.
+        delete comment.precedingNode;
+        delete comment.enclosingNode;
+        delete comment.followingNode;
+    });
+}
+function breakTies(tiesToBreak, lines) {
+    const tieCount = tiesToBreak.length;
+    if (tieCount === 0) {
+        return;
+    }
+    const pn = tiesToBreak[0].precedingNode;
+    const fn = tiesToBreak[0].followingNode;
+    let gapEndPos = fn.loc.start;
+    // Iterate backwards through tiesToBreak, examining the gaps
+    // between the tied comments. In order to qualify as leading, a
+    // comment must be separated from fn by an unbroken series of
+    // whitespace-only gaps (or other comments).
+    let indexOfFirstLeadingComment = tieCount;
+    let comment;
+    for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
+        comment = tiesToBreak[indexOfFirstLeadingComment - 1];
+        assert.strictEqual(comment.precedingNode, pn);
+        assert.strictEqual(comment.followingNode, fn);
+        const gap = lines.sliceString(comment.loc.end, gapEndPos);
+        if (/\S/.test(gap)) {
+            // The gap string contained something other than whitespace.
+            break;
+        }
+        gapEndPos = comment.loc.start;
+    }
+    while (indexOfFirstLeadingComment <= tieCount &&
+        (comment = tiesToBreak[indexOfFirstLeadingComment]) &&
+        // If the comment is a //-style comment and indented more
+        // deeply than the node itself, reconsider it as trailing.
+        (comment.type === "Line" || comment.type === "CommentLine") &&
+        comment.loc.start.column > fn.loc.start.column) {
+        ++indexOfFirstLeadingComment;
+    }
+    if (indexOfFirstLeadingComment) {
+        const { enclosingNode } = tiesToBreak[indexOfFirstLeadingComment - 1];
+        if (enclosingNode?.type === "CallExpression") {
+            --indexOfFirstLeadingComment;
+        }
+    }
+    tiesToBreak.forEach(function (comment, i) {
+        if (i < indexOfFirstLeadingComment) {
+            addTrailingComment(pn, comment);
+        }
+        else {
+            addLeadingComment(fn, comment);
+        }
+    });
+    tiesToBreak.length = 0;
+}
+function addCommentHelper(node, comment) {
+    const comments = node.comments || (node.comments = []);
+    comments.push(comment);
+}
+function addLeadingComment(node, comment) {
+    comment.leading = true;
+    comment.trailing = false;
+    addCommentHelper(node, comment);
+}
+function addDanglingComment(node, comment) {
+    comment.leading = false;
+    comment.trailing = false;
+    addCommentHelper(node, comment);
+}
+function addTrailingComment(node, comment) {
+    comment.leading = false;
+    comment.trailing = true;
+    addCommentHelper(node, comment);
+}
+function printLeadingComment(commentPath, print) {
+    const comment = commentPath.getValue();
+    n.Comment.assert(comment);
+    const loc = comment.loc;
+    const lines = loc && loc.lines;
+    const parts = [print(commentPath)];
+    if (comment.trailing) {
+        // When we print trailing comments as leading comments, we don't
+        // want to bring any trailing spaces along.
+        parts.push("\n");
+    }
+    else if (lines instanceof Lines) {
+        const trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end) || lines.lastPos());
+        if (trailingSpace.length === 1) {
+            // If the trailing space contains no newlines, then we want to
+            // preserve it exactly as we found it.
+            parts.push(trailingSpace);
+        }
+        else {
+            // If the trailing space contains newlines, then replace it
+            // with just that many newlines, with all other spaces removed.
+            parts.push(new Array(trailingSpace.length).join("\n"));
+        }
+    }
+    else {
+        parts.push("\n");
+    }
+    return concat(parts);
+}
+function printTrailingComment(commentPath, print) {
+    const comment = commentPath.getValue(commentPath);
+    n.Comment.assert(comment);
+    const loc = comment.loc;
+    const lines = loc && loc.lines;
+    const parts = [];
+    if (lines instanceof Lines) {
+        const fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();
+        const leadingSpace = lines.slice(fromPos, loc.start);
+        if (leadingSpace.length === 1) {
+            // If the leading space contains no newlines, then we want to
+            // preserve it exactly as we found it.
+            parts.push(leadingSpace);
+        }
+        else {
+            // If the leading space contains newlines, then replace it
+            // with just that many newlines, sans all other spaces.
+            parts.push(new Array(leadingSpace.length).join("\n"));
+        }
+    }
+    parts.push(print(commentPath));
+    return concat(parts);
+}
+export function printComments(path, print) {
+    const value = path.getValue();
+    const innerLines = print(path);
+    const comments = n.Node.check(value) && types.getFieldValue(value, "comments");
+    if (!comments || comments.length === 0) {
+        return innerLines;
+    }
+    const leadingParts = [];
+    const trailingParts = [innerLines];
+    path.each(function (commentPath) {
+        const comment = commentPath.getValue();
+        const leading = types.getFieldValue(comment, "leading");
+        const trailing = types.getFieldValue(comment, "trailing");
+        if (leading ||
+            (trailing &&
+                !(n.Statement.check(value) ||
+                    comment.type === "Block" ||
+                    comment.type === "CommentBlock"))) {
+            leadingParts.push(printLeadingComment(commentPath, print));
+        }
+        else if (trailing) {
+            trailingParts.push(printTrailingComment(commentPath, print));
+        }
+    }, "comments");
+    leadingParts.push.apply(leadingParts, trailingParts);
+    return concat(leadingParts);
+}
diff --git a/node_modules/recast/esm/lib/fast-path.d.ts b/node_modules/recast/esm/lib/fast-path.d.ts
new file mode 100644
index 0000000..f678193
--- /dev/null
+++ b/node_modules/recast/esm/lib/fast-path.d.ts
@@ -0,0 +1,25 @@
+interface FastPathType {
+    stack: any[];
+    copy(): any;
+    getName(): any;
+    getValue(): any;
+    valueIsDuplicate(): any;
+    getNode(count?: number): any;
+    getParentNode(count?: number): any;
+    getRootValue(): any;
+    call(callback: any, ...names: any[]): any;
+    each(callback: any, ...names: any[]): any;
+    map(callback: any, ...names: any[]): any;
+    hasParens(): any;
+    getPrevToken(node: any): any;
+    getNextToken(node: any): any;
+    needsParens(assumeExpressionContext?: boolean): any;
+    canBeFirstInStatement(): any;
+    firstInStatement(): any;
+}
+interface FastPathConstructor {
+    new (value: any): FastPathType;
+    from(obj: any): any;
+}
+declare const FastPath: FastPathConstructor;
+export default FastPath;
diff --git a/node_modules/recast/esm/lib/fast-path.mjs b/node_modules/recast/esm/lib/fast-path.mjs
new file mode 100644
index 0000000..27b924f
--- /dev/null
+++ b/node_modules/recast/esm/lib/fast-path.mjs
@@ -0,0 +1,526 @@
+import assert from "assert";
+import * as types from "ast-types";
+import * as util from "./util.mjs";
+const n = types.namedTypes;
+const isArray = types.builtInTypes.array;
+const isNumber = types.builtInTypes.number;
+const PRECEDENCE = {};
+[
+    ["??"],
+    ["||"],
+    ["&&"],
+    ["|"],
+    ["^"],
+    ["&"],
+    ["==", "===", "!=", "!=="],
+    ["<", ">", "<=", ">=", "in", "instanceof"],
+    [">>", "<<", ">>>"],
+    ["+", "-"],
+    ["*", "/", "%"],
+    ["**"],
+].forEach(function (tier, i) {
+    tier.forEach(function (op) {
+        PRECEDENCE[op] = i;
+    });
+});
+const FastPath = function FastPath(value) {
+    assert.ok(this instanceof FastPath);
+    this.stack = [value];
+};
+const FPp = FastPath.prototype;
+// Static convenience function for coercing a value to a FastPath.
+FastPath.from = function (obj) {
+    if (obj instanceof FastPath) {
+        // Return a defensive copy of any existing FastPath instances.
+        return obj.copy();
+    }
+    if (obj instanceof types.NodePath) {
+        // For backwards compatibility, unroll NodePath instances into
+        // lightweight FastPath [..., name, value] stacks.
+        const copy = Object.create(FastPath.prototype);
+        const stack = [obj.value];
+        for (let pp; (pp = obj.parentPath); obj = pp)
+            stack.push(obj.name, pp.value);
+        copy.stack = stack.reverse();
+        return copy;
+    }
+    // Otherwise use obj as the value of the new FastPath instance.
+    return new FastPath(obj);
+};
+FPp.copy = function copy() {
+    const copy = Object.create(FastPath.prototype);
+    copy.stack = this.stack.slice(0);
+    return copy;
+};
+// The name of the current property is always the penultimate element of
+// this.stack, and always a String.
+FPp.getName = function getName() {
+    const s = this.stack;
+    const len = s.length;
+    if (len > 1) {
+        return s[len - 2];
+    }
+    // Since the name is always a string, null is a safe sentinel value to
+    // return if we do not know the name of the (root) value.
+    return null;
+};
+// The value of the current property is always the final element of
+// this.stack.
+FPp.getValue = function getValue() {
+    const s = this.stack;
+    return s[s.length - 1];
+};
+FPp.valueIsDuplicate = function () {
+    const s = this.stack;
+    const valueIndex = s.length - 1;
+    return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;
+};
+function getNodeHelper(path, count) {
+    const s = path.stack;
+    for (let i = s.length - 1; i >= 0; i -= 2) {
+        const value = s[i];
+        if (n.Node.check(value) && --count < 0) {
+            return value;
+        }
+    }
+    return null;
+}
+FPp.getNode = function getNode(count = 0) {
+    return getNodeHelper(this, ~~count);
+};
+FPp.getParentNode = function getParentNode(count = 0) {
+    return getNodeHelper(this, ~~count + 1);
+};
+// The length of the stack can be either even or odd, depending on whether
+// or not we have a name for the root value. The difference between the
+// index of the root value and the index of the final value is always
+// even, though, which allows us to return the root value in constant time
+// (i.e. without iterating backwards through the stack).
+FPp.getRootValue = function getRootValue() {
+    const s = this.stack;
+    if (s.length % 2 === 0) {
+        return s[1];
+    }
+    return s[0];
+};
+// Temporarily push properties named by string arguments given after the
+// callback function onto this.stack, then call the callback with a
+// reference to this (modified) FastPath object. Note that the stack will
+// be restored to its original state after the callback is finished, so it
+// is probably a mistake to retain a reference to the path.
+FPp.call = function call(callback /*, name1, name2, ... */) {
+    const s = this.stack;
+    const origLen = s.length;
+    let value = s[origLen - 1];
+    const argc = arguments.length;
+    for (let i = 1; i < argc; ++i) {
+        const name = arguments[i];
+        value = value[name];
+        s.push(name, value);
+    }
+    const result = callback(this);
+    s.length = origLen;
+    return result;
+};
+// Similar to FastPath.prototype.call, except that the value obtained by
+// accessing this.getValue()[name1][name2]... should be array-like. The
+// callback will be called with a reference to this path object for each
+// element of the array.
+FPp.each = function each(callback /*, name1, name2, ... */) {
+    const s = this.stack;
+    const origLen = s.length;
+    let value = s[origLen - 1];
+    const argc = arguments.length;
+    for (let i = 1; i < argc; ++i) {
+        const name = arguments[i];
+        value = value[name];
+        s.push(name, value);
+    }
+    for (let i = 0; i < value.length; ++i) {
+        if (i in value) {
+            s.push(i, value[i]);
+            // If the callback needs to know the value of i, call
+            // path.getName(), assuming path is the parameter name.
+            callback(this);
+            s.length -= 2;
+        }
+    }
+    s.length = origLen;
+};
+// Similar to FastPath.prototype.each, except that the results of the
+// callback function invocations are stored in an array and returned at
+// the end of the iteration.
+FPp.map = function map(callback /*, name1, name2, ... */) {
+    const s = this.stack;
+    const origLen = s.length;
+    let value = s[origLen - 1];
+    const argc = arguments.length;
+    for (let i = 1; i < argc; ++i) {
+        const name = arguments[i];
+        value = value[name];
+        s.push(name, value);
+    }
+    const result = new Array(value.length);
+    for (let i = 0; i < value.length; ++i) {
+        if (i in value) {
+            s.push(i, value[i]);
+            result[i] = callback(this, i);
+            s.length -= 2;
+        }
+    }
+    s.length = origLen;
+    return result;
+};
+// Returns true if the node at the tip of the path is wrapped with
+// parentheses, OR if the only reason the node needed parentheses was that
+// it couldn't be the first expression in the enclosing statement (see
+// FastPath#canBeFirstInStatement), and it has an opening `(` character.
+// For example, the FunctionExpression in `(function(){}())` appears to
+// need parentheses only because it's the first expression in the AST, but
+// since it happens to be preceded by a `(` (which is not apparent from
+// the AST but can be determined using FastPath#getPrevToken), there is no
+// ambiguity about how to parse it, so it counts as having parentheses,
+// even though it is not immediately followed by a `)`.
+FPp.hasParens = function () {
+    const node = this.getNode();
+    const prevToken = this.getPrevToken(node);
+    if (!prevToken) {
+        return false;
+    }
+    const nextToken = this.getNextToken(node);
+    if (!nextToken) {
+        return false;
+    }
+    if (prevToken.value === "(") {
+        if (nextToken.value === ")") {
+            // If the node preceded by a `(` token and followed by a `)` token,
+            // then of course it has parentheses.
+            return true;
+        }
+        // If this is one of the few Expression types that can't come first in
+        // the enclosing statement because of parsing ambiguities (namely,
+        // FunctionExpression, ObjectExpression, and ClassExpression) and
+        // this.firstInStatement() returns true, and the node would not need
+        // parentheses in an expression context because this.needsParens(true)
+        // returns false, then it just needs an opening parenthesis to resolve
+        // the parsing ambiguity that made it appear to need parentheses.
+        const justNeedsOpeningParen = !this.canBeFirstInStatement() &&
+            this.firstInStatement() &&
+            !this.needsParens(true);
+        if (justNeedsOpeningParen) {
+            return true;
+        }
+    }
+    return false;
+};
+FPp.getPrevToken = function (node) {
+    node = node || this.getNode();
+    const loc = node && node.loc;
+    const tokens = loc && loc.tokens;
+    if (tokens && loc.start.token > 0) {
+        const token = tokens[loc.start.token - 1];
+        if (token) {
+            // Do not return tokens that fall outside the root subtree.
+            const rootLoc = this.getRootValue().loc;
+            if (util.comparePos(rootLoc.start, token.loc.start) <= 0) {
+                return token;
+            }
+        }
+    }
+    return null;
+};
+FPp.getNextToken = function (node) {
+    node = node || this.getNode();
+    const loc = node && node.loc;
+    const tokens = loc && loc.tokens;
+    if (tokens && loc.end.token < tokens.length) {
+        const token = tokens[loc.end.token];
+        if (token) {
+            // Do not return tokens that fall outside the root subtree.
+            const rootLoc = this.getRootValue().loc;
+            if (util.comparePos(token.loc.end, rootLoc.end) <= 0) {
+                return token;
+            }
+        }
+    }
+    return null;
+};
+// Inspired by require("ast-types").NodePath.prototype.needsParens, but
+// more efficient because we're iterating backwards through a stack.
+FPp.needsParens = function (assumeExpressionContext) {
+    const node = this.getNode();
+    // This needs to come before `if (!parent) { return false }` because
+    // an object destructuring assignment requires parens for
+    // correctness even when it's the topmost expression.
+    if (node.type === "AssignmentExpression" &&
+        node.left.type === "ObjectPattern") {
+        return true;
+    }
+    const parent = this.getParentNode();
+    const name = this.getName();
+    // If the value of this path is some child of a Node and not a Node
+    // itself, then it doesn't need parentheses. Only Node objects (in fact,
+    // only Expression nodes) need parentheses.
+    if (this.getValue() !== node) {
+        return false;
+    }
+    // Only statements don't need parentheses.
+    if (n.Statement.check(node)) {
+        return false;
+    }
+    // Identifiers never need parentheses.
+    if (node.type === "Identifier") {
+        return false;
+    }
+    if (parent && parent.type === "ParenthesizedExpression") {
+        return false;
+    }
+    if (node.extra && node.extra.parenthesized) {
+        return true;
+    }
+    if (!parent)
+        return false;
+    switch (node.type) {
+        case "UnaryExpression":
+        case "SpreadElement":
+        case "SpreadProperty":
+            return (parent.type === "MemberExpression" &&
+                name === "object" &&
+                parent.object === node);
+        case "BinaryExpression":
+        case "LogicalExpression":
+            switch (parent.type) {
+                case "CallExpression":
+                    return name === "callee" && parent.callee === node;
+                case "UnaryExpression":
+                case "SpreadElement":
+                case "SpreadProperty":
+                    return true;
+                case "MemberExpression":
+                    return name === "object" && parent.object === node;
+                case "BinaryExpression":
+                case "LogicalExpression": {
+                    const po = parent.operator;
+                    const pp = PRECEDENCE[po];
+                    const no = node.operator;
+                    const np = PRECEDENCE[no];
+                    if (pp > np) {
+                        return true;
+                    }
+                    if (pp === np && name === "right") {
+                        assert.strictEqual(parent.right, node);
+                        return true;
+                    }
+                    break;
+                }
+                default:
+                    return false;
+            }
+            break;
+        case "SequenceExpression":
+            switch (parent.type) {
+                case "ReturnStatement":
+                    return false;
+                case "ForStatement":
+                    // Although parentheses wouldn't hurt around sequence expressions in
+                    // the head of for loops, traditional style dictates that e.g. i++,
+                    // j++ should not be wrapped with parentheses.
+                    return false;
+                case "ExpressionStatement":
+                    return name !== "expression";
+                default:
+                    // Otherwise err on the side of overparenthesization, adding
+                    // explicit exceptions above if this proves overzealous.
+                    return true;
+            }
+        case "OptionalIndexedAccessType":
+            return node.optional && parent.type === "IndexedAccessType";
+        case "IntersectionTypeAnnotation":
+        case "UnionTypeAnnotation":
+            return parent.type === "NullableTypeAnnotation";
+        case "Literal":
+            return (parent.type === "MemberExpression" &&
+                isNumber.check(node.value) &&
+                name === "object" &&
+                parent.object === node);
+        // Babel 6 Literal split
+        case "NumericLiteral":
+            return (parent.type === "MemberExpression" &&
+                name === "object" &&
+                parent.object === node);
+        case "YieldExpression":
+        case "AwaitExpression":
+        case "AssignmentExpression":
+        case "ConditionalExpression":
+            switch (parent.type) {
+                case "UnaryExpression":
+                case "SpreadElement":
+                case "SpreadProperty":
+                case "BinaryExpression":
+                case "LogicalExpression":
+                    return true;
+                case "CallExpression":
+                case "NewExpression":
+                    return name === "callee" && parent.callee === node;
+                case "ConditionalExpression":
+                    return name === "test" && parent.test === node;
+                case "MemberExpression":
+                    return name === "object" && parent.object === node;
+                default:
+                    return false;
+            }
+        case "ArrowFunctionExpression":
+            if (n.CallExpression.check(parent) &&
+                name === "callee" &&
+                parent.callee === node) {
+                return true;
+            }
+            if (n.MemberExpression.check(parent) &&
+                name === "object" &&
+                parent.object === node) {
+                return true;
+            }
+            if (n.TSAsExpression &&
+                n.TSAsExpression.check(parent) &&
+                name === "expression" &&
+                parent.expression === node) {
+                return true;
+            }
+            return isBinary(parent);
+        case "ObjectExpression":
+            if (parent.type === "ArrowFunctionExpression" &&
+                name === "body" &&
+                parent.body === node) {
+                return true;
+            }
+            break;
+        case "TSAsExpression":
+            if (parent.type === "ArrowFunctionExpression" &&
+                name === "body" &&
+                parent.body === node &&
+                node.expression.type === "ObjectExpression") {
+                return true;
+            }
+            break;
+        case "CallExpression":
+            if (name === "declaration" &&
+                n.ExportDefaultDeclaration.check(parent) &&
+                n.FunctionExpression.check(node.callee)) {
+                return true;
+            }
+    }
+    if (parent.type === "NewExpression" &&
+        name === "callee" &&
+        parent.callee === node) {
+        return containsCallExpression(node);
+    }
+    if (assumeExpressionContext !== true &&
+        !this.canBeFirstInStatement() &&
+        this.firstInStatement()) {
+        return true;
+    }
+    return false;
+};
+function isBinary(node) {
+    return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);
+}
+// @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]
+function isUnaryLike(node) {
+    return (n.UnaryExpression.check(node) ||
+        // I considered making SpreadElement and SpreadProperty subtypes of
+        // UnaryExpression, but they're not really Expression nodes.
+        (n.SpreadElement && n.SpreadElement.check(node)) ||
+        (n.SpreadProperty && n.SpreadProperty.check(node)));
+}
+function containsCallExpression(node) {
+    if (n.CallExpression.check(node)) {
+        return true;
+    }
+    if (isArray.check(node)) {
+        return node.some(containsCallExpression);
+    }
+    if (n.Node.check(node)) {
+        return types.someField(node, (_name, child) => containsCallExpression(child));
+    }
+    return false;
+}
+FPp.canBeFirstInStatement = function () {
+    const node = this.getNode();
+    if (n.FunctionExpression.check(node)) {
+        return false;
+    }
+    if (n.ObjectExpression.check(node)) {
+        return false;
+    }
+    if (n.ClassExpression.check(node)) {
+        return false;
+    }
+    return true;
+};
+FPp.firstInStatement = function () {
+    const s = this.stack;
+    let parentName, parent;
+    let childName, child;
+    for (let i = s.length - 1; i >= 0; i -= 2) {
+        if (n.Node.check(s[i])) {
+            childName = parentName;
+            child = parent;
+            parentName = s[i - 1];
+            parent = s[i];
+        }
+        if (!parent || !child) {
+            continue;
+        }
+        if (n.BlockStatement.check(parent) &&
+            parentName === "body" &&
+            childName === 0) {
+            assert.strictEqual(parent.body[0], child);
+            return true;
+        }
+        if (n.ExpressionStatement.check(parent) && childName === "expression") {
+            assert.strictEqual(parent.expression, child);
+            return true;
+        }
+        if (n.AssignmentExpression.check(parent) && childName === "left") {
+            assert.strictEqual(parent.left, child);
+            return true;
+        }
+        if (n.ArrowFunctionExpression.check(parent) && childName === "body") {
+            assert.strictEqual(parent.body, child);
+            return true;
+        }
+        // s[i + 1] and s[i + 2] represent the array between the parent
+        // SequenceExpression node and its child nodes
+        if (n.SequenceExpression.check(parent) &&
+            s[i + 1] === "expressions" &&
+            childName === 0) {
+            assert.strictEqual(parent.expressions[0], child);
+            continue;
+        }
+        if (n.CallExpression.check(parent) && childName === "callee") {
+            assert.strictEqual(parent.callee, child);
+            continue;
+        }
+        if (n.MemberExpression.check(parent) && childName === "object") {
+            assert.strictEqual(parent.object, child);
+            continue;
+        }
+        if (n.ConditionalExpression.check(parent) && childName === "test") {
+            assert.strictEqual(parent.test, child);
+            continue;
+        }
+        if (isBinary(parent) && childName === "left") {
+            assert.strictEqual(parent.left, child);
+            continue;
+        }
+        if (n.UnaryExpression.check(parent) &&
+            !parent.prefix &&
+            childName === "argument") {
+            assert.strictEqual(parent.argument, child);
+            continue;
+        }
+        return false;
+    }
+    return true;
+};
+export default FastPath;
diff --git a/node_modules/recast/esm/lib/lines.d.ts b/node_modules/recast/esm/lib/lines.d.ts
new file mode 100644
index 0000000..a6c2ca0
--- /dev/null
+++ b/node_modules/recast/esm/lib/lines.d.ts
@@ -0,0 +1,62 @@
+import { Options } from "./options.js";
+import { namedTypes } from "ast-types";
+type Pos = namedTypes.Position;
+type LineInfo = {
+    readonly line: string;
+    readonly indent: number;
+    readonly locked: boolean;
+    readonly sliceStart: number;
+    readonly sliceEnd: number;
+};
+export declare class Lines {
+    private infos;
+    readonly length: number;
+    readonly name: string | null;
+    private mappings;
+    private cachedSourceMap;
+    private cachedTabWidth;
+    constructor(infos: LineInfo[], sourceFileName?: string | null);
+    toString(options?: Options): string;
+    getSourceMap(sourceMapName: string, sourceRoot?: string): any;
+    bootstrapCharAt(pos: Pos): string;
+    charAt(pos: Pos): string;
+    stripMargin(width: number, skipFirstLine: boolean): Lines;
+    indent(by: number): Lines;
+    indentTail(by: number): Lines;
+    lockIndentTail(): Lines;
+    getIndentAt(line: number): number;
+    guessTabWidth(): number;
+    startsWithComment(): boolean;
+    isOnlyWhitespace(): boolean;
+    isPrecededOnlyByWhitespace(pos: Pos): boolean;
+    getLineLength(line: number): number;
+    nextPos(pos: Pos, skipSpaces?: boolean): boolean;
+    prevPos(pos: Pos, skipSpaces?: boolean): boolean;
+    firstPos(): {
+        line: number;
+        column: number;
+    };
+    lastPos(): {
+        line: number;
+        column: number;
+    };
+    skipSpaces(pos: Pos, backward?: boolean, modifyInPlace?: boolean): namedTypes.Position | null;
+    trimLeft(): Lines;
+    trimRight(): Lines;
+    trim(): Lines;
+    eachPos(callback: (pos: Pos) => any, startPos?: Pos, skipSpaces?: boolean): void;
+    bootstrapSlice(start: Pos, end: Pos): Lines;
+    slice(start?: Pos, end?: Pos): Lines;
+    bootstrapSliceString(start: Pos, end: Pos, options?: Options): string;
+    sliceString(start?: Pos, end?: Pos, options?: Options): string;
+    isEmpty(): boolean;
+    join(elements: (string | Lines)[]): Lines;
+    concat(...args: (string | Lines)[]): Lines;
+}
+export declare function countSpaces(spaces: any, tabWidth?: number): number;
+/**
+ * @param {Object} options - Options object that configures printing.
+ */
+export declare function fromString(string: string | Lines, options?: Options): Lines;
+export declare function concat(elements: any): Lines;
+export {};
diff --git a/node_modules/recast/esm/lib/lines.mjs b/node_modules/recast/esm/lib/lines.mjs
new file mode 100644
index 0000000..aa1b7f9
--- /dev/null
+++ b/node_modules/recast/esm/lib/lines.mjs
@@ -0,0 +1,644 @@
+import assert from "assert";
+import sourceMap from "source-map";
+import { normalize as normalizeOptions } from "./options.mjs";
+import { comparePos } from "./util.mjs";
+import Mapping from "./mapping.mjs";
+export class Lines {
+    constructor(infos, sourceFileName = null) {
+        this.infos = infos;
+        this.mappings = [];
+        this.cachedSourceMap = null;
+        this.cachedTabWidth = void 0;
+        assert.ok(infos.length > 0);
+        this.length = infos.length;
+        this.name = sourceFileName || null;
+        if (this.name) {
+            this.mappings.push(new Mapping(this, {
+                start: this.firstPos(),
+                end: this.lastPos(),
+            }));
+        }
+    }
+    toString(options) {
+        return this.sliceString(this.firstPos(), this.lastPos(), options);
+    }
+    getSourceMap(sourceMapName, sourceRoot) {
+        if (!sourceMapName) {
+            // Although we could make up a name or generate an anonymous
+            // source map, instead we assume that any consumer who does not
+            // provide a name does not actually want a source map.
+            return null;
+        }
+        const targetLines = this;
+        function updateJSON(json) {
+            json = json || {};
+            json.file = sourceMapName;
+            if (sourceRoot) {
+                json.sourceRoot = sourceRoot;
+            }
+            return json;
+        }
+        if (targetLines.cachedSourceMap) {
+            // Since Lines objects are immutable, we can reuse any source map
+            // that was previously generated. Nevertheless, we return a new
+            // JSON object here to protect the cached source map from outside
+            // modification.
+            return updateJSON(targetLines.cachedSourceMap.toJSON());
+        }
+        const smg = new sourceMap.SourceMapGenerator(updateJSON());
+        const sourcesToContents = {};
+        targetLines.mappings.forEach(function (mapping) {
+            const sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) ||
+                mapping.sourceLines.lastPos();
+            const targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) ||
+                targetLines.lastPos();
+            while (comparePos(sourceCursor, mapping.sourceLoc.end) < 0 &&
+                comparePos(targetCursor, mapping.targetLoc.end) < 0) {
+                const sourceChar = mapping.sourceLines.charAt(sourceCursor);
+                const targetChar = targetLines.charAt(targetCursor);
+                assert.strictEqual(sourceChar, targetChar);
+                const sourceName = mapping.sourceLines.name;
+                // Add mappings one character at a time for maximum resolution.
+                smg.addMapping({
+                    source: sourceName,
+                    original: { line: sourceCursor.line, column: sourceCursor.column },
+                    generated: { line: targetCursor.line, column: targetCursor.column },
+                });
+                if (!hasOwn.call(sourcesToContents, sourceName)) {
+                    const sourceContent = mapping.sourceLines.toString();
+                    smg.setSourceContent(sourceName, sourceContent);
+                    sourcesToContents[sourceName] = sourceContent;
+                }
+                targetLines.nextPos(targetCursor, true);
+                mapping.sourceLines.nextPos(sourceCursor, true);
+            }
+        });
+        targetLines.cachedSourceMap = smg;
+        return smg.toJSON();
+    }
+    bootstrapCharAt(pos) {
+        assert.strictEqual(typeof pos, "object");
+        assert.strictEqual(typeof pos.line, "number");
+        assert.strictEqual(typeof pos.column, "number");
+        const line = pos.line, column = pos.column, strings = this.toString().split(lineTerminatorSeqExp), string = strings[line - 1];
+        if (typeof string === "undefined")
+            return "";
+        if (column === string.length && line < strings.length)
+            return "\n";
+        if (column >= string.length)
+            return "";
+        return string.charAt(column);
+    }
+    charAt(pos) {
+        assert.strictEqual(typeof pos, "object");
+        assert.strictEqual(typeof pos.line, "number");
+        assert.strictEqual(typeof pos.column, "number");
+        let line = pos.line, column = pos.column, secret = this, infos = secret.infos, info = infos[line - 1], c = column;
+        if (typeof info === "undefined" || c < 0)
+            return "";
+        const indent = this.getIndentAt(line);
+        if (c < indent)
+            return " ";
+        c += info.sliceStart - indent;
+        if (c === info.sliceEnd && line < this.length)
+            return "\n";
+        if (c >= info.sliceEnd)
+            return "";
+        return info.line.charAt(c);
+    }
+    stripMargin(width, skipFirstLine) {
+        if (width === 0)
+            return this;
+        assert.ok(width > 0, "negative margin: " + width);
+        if (skipFirstLine && this.length === 1)
+            return this;
+        const lines = new Lines(this.infos.map(function (info, i) {
+            if (info.line && (i > 0 || !skipFirstLine)) {
+                info = {
+                    ...info,
+                    indent: Math.max(0, info.indent - width),
+                };
+            }
+            return info;
+        }));
+        if (this.mappings.length > 0) {
+            const newMappings = lines.mappings;
+            assert.strictEqual(newMappings.length, 0);
+            this.mappings.forEach(function (mapping) {
+                newMappings.push(mapping.indent(width, skipFirstLine, true));
+            });
+        }
+        return lines;
+    }
+    indent(by) {
+        if (by === 0) {
+            return this;
+        }
+        const lines = new Lines(this.infos.map(function (info) {
+            if (info.line && !info.locked) {
+                info = {
+                    ...info,
+                    indent: info.indent + by,
+                };
+            }
+            return info;
+        }));
+        if (this.mappings.length > 0) {
+            const newMappings = lines.mappings;
+            assert.strictEqual(newMappings.length, 0);
+            this.mappings.forEach(function (mapping) {
+                newMappings.push(mapping.indent(by));
+            });
+        }
+        return lines;
+    }
+    indentTail(by) {
+        if (by === 0) {
+            return this;
+        }
+        if (this.length < 2) {
+            return this;
+        }
+        const lines = new Lines(this.infos.map(function (info, i) {
+            if (i > 0 && info.line && !info.locked) {
+                info = {
+                    ...info,
+                    indent: info.indent + by,
+                };
+            }
+            return info;
+        }));
+        if (this.mappings.length > 0) {
+            const newMappings = lines.mappings;
+            assert.strictEqual(newMappings.length, 0);
+            this.mappings.forEach(function (mapping) {
+                newMappings.push(mapping.indent(by, true));
+            });
+        }
+        return lines;
+    }
+    lockIndentTail() {
+        if (this.length < 2) {
+            return this;
+        }
+        return new Lines(this.infos.map((info, i) => ({
+            ...info,
+            locked: i > 0,
+        })));
+    }
+    getIndentAt(line) {
+        assert.ok(line >= 1, "no line " + line + " (line numbers start from 1)");
+        return Math.max(this.infos[line - 1].indent, 0);
+    }
+    guessTabWidth() {
+        if (typeof this.cachedTabWidth === "number") {
+            return this.cachedTabWidth;
+        }
+        const counts = []; // Sparse array.
+        let lastIndent = 0;
+        for (let line = 1, last = this.length; line <= last; ++line) {
+            const info = this.infos[line - 1];
+            const sliced = info.line.slice(info.sliceStart, info.sliceEnd);
+            // Whitespace-only lines don't tell us much about the likely tab
+            // width of this code.
+            if (isOnlyWhitespace(sliced)) {
+                continue;
+            }
+            const diff = Math.abs(info.indent - lastIndent);
+            counts[diff] = ~~counts[diff] + 1;
+            lastIndent = info.indent;
+        }
+        let maxCount = -1;
+        let result = 2;
+        for (let tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {
+            if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {
+                maxCount = counts[tabWidth];
+                result = tabWidth;
+            }
+        }
+        return (this.cachedTabWidth = result);
+    }
+    // Determine if the list of lines has a first line that starts with a //
+    // or /* comment. If this is the case, the code may need to be wrapped in
+    // parens to avoid ASI issues.
+    startsWithComment() {
+        if (this.infos.length === 0) {
+            return false;
+        }
+        const firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();
+        return (firstLine.length === 0 ||
+            firstLine.slice(0, 2) === "//" ||
+            firstLine.slice(0, 2) === "/*");
+    }
+    isOnlyWhitespace() {
+        return isOnlyWhitespace(this.toString());
+    }
+    isPrecededOnlyByWhitespace(pos) {
+        const info = this.infos[pos.line - 1];
+        const indent = Math.max(info.indent, 0);
+        const diff = pos.column - indent;
+        if (diff <= 0) {
+            // If pos.column does not exceed the indentation amount, then
+            // there must be only whitespace before it.
+            return true;
+        }
+        const start = info.sliceStart;
+        const end = Math.min(start + diff, info.sliceEnd);
+        const prefix = info.line.slice(start, end);
+        return isOnlyWhitespace(prefix);
+    }
+    getLineLength(line) {
+        const info = this.infos[line - 1];
+        return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;
+    }
+    nextPos(pos, skipSpaces = false) {
+        const l = Math.max(pos.line, 0), c = Math.max(pos.column, 0);
+        if (c < this.getLineLength(l)) {
+            pos.column += 1;
+            return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
+        }
+        if (l < this.length) {
+            pos.line += 1;
+            pos.column = 0;
+            return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
+        }
+        return false;
+    }
+    prevPos(pos, skipSpaces = false) {
+        let l = pos.line, c = pos.column;
+        if (c < 1) {
+            l -= 1;
+            if (l < 1)
+                return false;
+            c = this.getLineLength(l);
+        }
+        else {
+            c = Math.min(c - 1, this.getLineLength(l));
+        }
+        pos.line = l;
+        pos.column = c;
+        return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;
+    }
+    firstPos() {
+        // Trivial, but provided for completeness.
+        return { line: 1, column: 0 };
+    }
+    lastPos() {
+        return {
+            line: this.length,
+            column: this.getLineLength(this.length),
+        };
+    }
+    skipSpaces(pos, backward = false, modifyInPlace = false) {
+        if (pos) {
+            pos = modifyInPlace
+                ? pos
+                : {
+                    line: pos.line,
+                    column: pos.column,
+                };
+        }
+        else if (backward) {
+            pos = this.lastPos();
+        }
+        else {
+            pos = this.firstPos();
+        }
+        if (backward) {
+            while (this.prevPos(pos)) {
+                if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {
+                    return pos;
+                }
+            }
+            return null;
+        }
+        else {
+            while (isOnlyWhitespace(this.charAt(pos))) {
+                if (!this.nextPos(pos)) {
+                    return null;
+                }
+            }
+            return pos;
+        }
+    }
+    trimLeft() {
+        const pos = this.skipSpaces(this.firstPos(), false, true);
+        return pos ? this.slice(pos) : emptyLines;
+    }
+    trimRight() {
+        const pos = this.skipSpaces(this.lastPos(), true, true);
+        return pos ? this.slice(this.firstPos(), pos) : emptyLines;
+    }
+    trim() {
+        const start = this.skipSpaces(this.firstPos(), false, true);
+        if (start === null) {
+            return emptyLines;
+        }
+        const end = this.skipSpaces(this.lastPos(), true, true);
+        if (end === null) {
+            return emptyLines;
+        }
+        return this.slice(start, end);
+    }
+    eachPos(callback, startPos = this.firstPos(), skipSpaces = false) {
+        const pos = this.firstPos();
+        if (startPos) {
+            (pos.line = startPos.line), (pos.column = startPos.column);
+        }
+        if (skipSpaces && !this.skipSpaces(pos, false, true)) {
+            return; // Encountered nothing but spaces.
+        }
+        do
+            callback.call(this, pos);
+        while (this.nextPos(pos, skipSpaces));
+    }
+    bootstrapSlice(start, end) {
+        const strings = this.toString()
+            .split(lineTerminatorSeqExp)
+            .slice(start.line - 1, end.line);
+        if (strings.length > 0) {
+            strings.push(strings.pop().slice(0, end.column));
+            strings[0] = strings[0].slice(start.column);
+        }
+        return fromString(strings.join("\n"));
+    }
+    slice(start, end) {
+        if (!end) {
+            if (!start) {
+                // The client seems to want a copy of this Lines object, but
+                // Lines objects are immutable, so it's perfectly adequate to
+                // return the same object.
+                return this;
+            }
+            // Slice to the end if no end position was provided.
+            end = this.lastPos();
+        }
+        if (!start) {
+            throw new Error("cannot slice with end but not start");
+        }
+        const sliced = this.infos.slice(start.line - 1, end.line);
+        if (start.line === end.line) {
+            sliced[0] = sliceInfo(sliced[0], start.column, end.column);
+        }
+        else {
+            assert.ok(start.line < end.line);
+            sliced[0] = sliceInfo(sliced[0], start.column);
+            sliced.push(sliceInfo(sliced.pop(), 0, end.column));
+        }
+        const lines = new Lines(sliced);
+        if (this.mappings.length > 0) {
+            const newMappings = lines.mappings;
+            assert.strictEqual(newMappings.length, 0);
+            this.mappings.forEach(function (mapping) {
+                const sliced = mapping.slice(this, start, end);
+                if (sliced) {
+                    newMappings.push(sliced);
+                }
+            }, this);
+        }
+        return lines;
+    }
+    bootstrapSliceString(start, end, options) {
+        return this.slice(start, end).toString(options);
+    }
+    sliceString(start = this.firstPos(), end = this.lastPos(), options) {
+        const { tabWidth, useTabs, reuseWhitespace, lineTerminator } = normalizeOptions(options);
+        const parts = [];
+        for (let line = start.line; line <= end.line; ++line) {
+            let info = this.infos[line - 1];
+            if (line === start.line) {
+                if (line === end.line) {
+                    info = sliceInfo(info, start.column, end.column);
+                }
+                else {
+                    info = sliceInfo(info, start.column);
+                }
+            }
+            else if (line === end.line) {
+                info = sliceInfo(info, 0, end.column);
+            }
+            const indent = Math.max(info.indent, 0);
+            const before = info.line.slice(0, info.sliceStart);
+            if (reuseWhitespace &&
+                isOnlyWhitespace(before) &&
+                countSpaces(before, tabWidth) === indent) {
+                // Reuse original spaces if the indentation is correct.
+                parts.push(info.line.slice(0, info.sliceEnd));
+                continue;
+            }
+            let tabs = 0;
+            let spaces = indent;
+            if (useTabs) {
+                tabs = Math.floor(indent / tabWidth);
+                spaces -= tabs * tabWidth;
+            }
+            let result = "";
+            if (tabs > 0) {
+                result += new Array(tabs + 1).join("\t");
+            }
+            if (spaces > 0) {
+                result += new Array(spaces + 1).join(" ");
+            }
+            result += info.line.slice(info.sliceStart, info.sliceEnd);
+            parts.push(result);
+        }
+        return parts.join(lineTerminator);
+    }
+    isEmpty() {
+        return this.length < 2 && this.getLineLength(1) < 1;
+    }
+    join(elements) {
+        const separator = this;
+        const infos = [];
+        const mappings = [];
+        let prevInfo;
+        function appendLines(linesOrNull) {
+            if (linesOrNull === null) {
+                return;
+            }
+            if (prevInfo) {
+                const info = linesOrNull.infos[0];
+                const indent = new Array(info.indent + 1).join(" ");
+                const prevLine = infos.length;
+                const prevColumn = Math.max(prevInfo.indent, 0) +
+                    prevInfo.sliceEnd -
+                    prevInfo.sliceStart;
+                prevInfo.line =
+                    prevInfo.line.slice(0, prevInfo.sliceEnd) +
+                        indent +
+                        info.line.slice(info.sliceStart, info.sliceEnd);
+                // If any part of a line is indentation-locked, the whole line
+                // will be indentation-locked.
+                prevInfo.locked = prevInfo.locked || info.locked;
+                prevInfo.sliceEnd = prevInfo.line.length;
+                if (linesOrNull.mappings.length > 0) {
+                    linesOrNull.mappings.forEach(function (mapping) {
+                        mappings.push(mapping.add(prevLine, prevColumn));
+                    });
+                }
+            }
+            else if (linesOrNull.mappings.length > 0) {
+                mappings.push.apply(mappings, linesOrNull.mappings);
+            }
+            linesOrNull.infos.forEach(function (info, i) {
+                if (!prevInfo || i > 0) {
+                    prevInfo = { ...info };
+                    infos.push(prevInfo);
+                }
+            });
+        }
+        function appendWithSeparator(linesOrNull, i) {
+            if (i > 0)
+                appendLines(separator);
+            appendLines(linesOrNull);
+        }
+        elements
+            .map(function (elem) {
+            const lines = fromString(elem);
+            if (lines.isEmpty())
+                return null;
+            return lines;
+        })
+            .forEach((linesOrNull, i) => {
+            if (separator.isEmpty()) {
+                appendLines(linesOrNull);
+            }
+            else {
+                appendWithSeparator(linesOrNull, i);
+            }
+        });
+        if (infos.length < 1)
+            return emptyLines;
+        const lines = new Lines(infos);
+        lines.mappings = mappings;
+        return lines;
+    }
+    concat(...args) {
+        const list = [this];
+        list.push.apply(list, args);
+        assert.strictEqual(list.length, args.length + 1);
+        return emptyLines.join(list);
+    }
+}
+const fromStringCache = {};
+const hasOwn = fromStringCache.hasOwnProperty;
+const maxCacheKeyLen = 10;
+export function countSpaces(spaces, tabWidth) {
+    let count = 0;
+    const len = spaces.length;
+    for (let i = 0; i < len; ++i) {
+        switch (spaces.charCodeAt(i)) {
+            case 9: {
+                // '\t'
+                assert.strictEqual(typeof tabWidth, "number");
+                assert.ok(tabWidth > 0);
+                const next = Math.ceil(count / tabWidth) * tabWidth;
+                if (next === count) {
+                    count += tabWidth;
+                }
+                else {
+                    count = next;
+                }
+                break;
+            }
+            case 11: // '\v'
+            case 12: // '\f'
+            case 13: // '\r'
+            case 0xfeff: // zero-width non-breaking space
+                // These characters contribute nothing to indentation.
+                break;
+            case 32: // ' '
+            default:
+                // Treat all other whitespace like ' '.
+                count += 1;
+                break;
+        }
+    }
+    return count;
+}
+const leadingSpaceExp = /^\s*/;
+// As specified here: http://www.ecma-international.org/ecma-262/6.0/#sec-line-terminators
+const lineTerminatorSeqExp = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;
+/**
+ * @param {Object} options - Options object that configures printing.
+ */
+export function fromString(string, options) {
+    if (string instanceof Lines)
+        return string;
+    string += "";
+    const tabWidth = options && options.tabWidth;
+    const tabless = string.indexOf("\t") < 0;
+    const cacheable = !options && tabless && string.length <= maxCacheKeyLen;
+    assert.ok(tabWidth || tabless, "No tab width specified but encountered tabs in string\n" + string);
+    if (cacheable && hasOwn.call(fromStringCache, string))
+        return fromStringCache[string];
+    const lines = new Lines(string.split(lineTerminatorSeqExp).map(function (line) {
+        // TODO: handle null exec result
+        const spaces = leadingSpaceExp.exec(line)[0];
+        return {
+            line: line,
+            indent: countSpaces(spaces, tabWidth),
+            // Boolean indicating whether this line can be reindented.
+            locked: false,
+            sliceStart: spaces.length,
+            sliceEnd: line.length,
+        };
+    }), normalizeOptions(options).sourceFileName);
+    if (cacheable)
+        fromStringCache[string] = lines;
+    return lines;
+}
+function isOnlyWhitespace(string) {
+    return !/\S/.test(string);
+}
+function sliceInfo(info, startCol, endCol) {
+    let sliceStart = info.sliceStart;
+    let sliceEnd = info.sliceEnd;
+    let indent = Math.max(info.indent, 0);
+    let lineLength = indent + sliceEnd - sliceStart;
+    if (typeof endCol === "undefined") {
+        endCol = lineLength;
+    }
+    startCol = Math.max(startCol, 0);
+    endCol = Math.min(endCol, lineLength);
+    endCol = Math.max(endCol, startCol);
+    if (endCol < indent) {
+        indent = endCol;
+        sliceEnd = sliceStart;
+    }
+    else {
+        sliceEnd -= lineLength - endCol;
+    }
+    lineLength = endCol;
+    lineLength -= startCol;
+    if (startCol < indent) {
+        indent -= startCol;
+    }
+    else {
+        startCol -= indent;
+        indent = 0;
+        sliceStart += startCol;
+    }
+    assert.ok(indent >= 0);
+    assert.ok(sliceStart <= sliceEnd);
+    assert.strictEqual(lineLength, indent + sliceEnd - sliceStart);
+    if (info.indent === indent &&
+        info.sliceStart === sliceStart &&
+        info.sliceEnd === sliceEnd) {
+        return info;
+    }
+    return {
+        line: info.line,
+        indent: indent,
+        // A destructive slice always unlocks indentation.
+        locked: false,
+        sliceStart: sliceStart,
+        sliceEnd: sliceEnd,
+    };
+}
+export function concat(elements) {
+    return emptyLines.join(elements);
+}
+// The emptyLines object needs to be created all the way down here so that
+// Lines.prototype will be fully populated.
+const emptyLines = fromString("");
diff --git a/node_modules/recast/esm/lib/mapping.d.ts b/node_modules/recast/esm/lib/mapping.d.ts
new file mode 100644
index 0000000..03ad709
--- /dev/null
+++ b/node_modules/recast/esm/lib/mapping.d.ts
@@ -0,0 +1,15 @@
+import { namedTypes } from "ast-types";
+import { Lines } from "./lines.js";
+type Pos = namedTypes.Position;
+type Loc = namedTypes.SourceLocation;
+export default class Mapping {
+    sourceLines: Lines;
+    sourceLoc: Loc;
+    targetLoc: Loc;
+    constructor(sourceLines: Lines, sourceLoc: Loc, targetLoc?: Loc);
+    slice(lines: Lines, start: Pos, end?: Pos): Mapping | null;
+    add(line: number, column: number): Mapping;
+    subtract(line: number, column: number): Mapping;
+    indent(by: number, skipFirstLine?: boolean, noNegativeColumns?: boolean): Mapping;
+}
+export {};
diff --git a/node_modules/recast/esm/lib/mapping.mjs b/node_modules/recast/esm/lib/mapping.mjs
new file mode 100644
index 0000000..9e531c1
--- /dev/null
+++ b/node_modules/recast/esm/lib/mapping.mjs
@@ -0,0 +1,188 @@
+import assert from "assert";
+import { comparePos } from "./util.mjs";
+export default class Mapping {
+    constructor(sourceLines, sourceLoc, targetLoc = sourceLoc) {
+        this.sourceLines = sourceLines;
+        this.sourceLoc = sourceLoc;
+        this.targetLoc = targetLoc;
+    }
+    slice(lines, start, end = lines.lastPos()) {
+        const sourceLines = this.sourceLines;
+        let sourceLoc = this.sourceLoc;
+        let targetLoc = this.targetLoc;
+        function skip(name) {
+            const sourceFromPos = sourceLoc[name];
+            const targetFromPos = targetLoc[name];
+            let targetToPos = start;
+            if (name === "end") {
+                targetToPos = end;
+            }
+            else {
+                assert.strictEqual(name, "start");
+            }
+            return skipChars(sourceLines, sourceFromPos, lines, targetFromPos, targetToPos);
+        }
+        if (comparePos(start, targetLoc.start) <= 0) {
+            if (comparePos(targetLoc.end, end) <= 0) {
+                targetLoc = {
+                    start: subtractPos(targetLoc.start, start.line, start.column),
+                    end: subtractPos(targetLoc.end, start.line, start.column),
+                };
+                // The sourceLoc can stay the same because the contents of the
+                // targetLoc have not changed.
+            }
+            else if (comparePos(end, targetLoc.start) <= 0) {
+                return null;
+            }
+            else {
+                sourceLoc = {
+                    start: sourceLoc.start,
+                    end: skip("end"),
+                };
+                targetLoc = {
+                    start: subtractPos(targetLoc.start, start.line, start.column),
+                    end: subtractPos(end, start.line, start.column),
+                };
+            }
+        }
+        else {
+            if (comparePos(targetLoc.end, start) <= 0) {
+                return null;
+            }
+            if (comparePos(targetLoc.end, end) <= 0) {
+                sourceLoc = {
+                    start: skip("start"),
+                    end: sourceLoc.end,
+                };
+                targetLoc = {
+                    // Same as subtractPos(start, start.line, start.column):
+                    start: { line: 1, column: 0 },
+                    end: subtractPos(targetLoc.end, start.line, start.column),
+                };
+            }
+            else {
+                sourceLoc = {
+                    start: skip("start"),
+                    end: skip("end"),
+                };
+                targetLoc = {
+                    // Same as subtractPos(start, start.line, start.column):
+                    start: { line: 1, column: 0 },
+                    end: subtractPos(end, start.line, start.column),
+                };
+            }
+        }
+        return new Mapping(this.sourceLines, sourceLoc, targetLoc);
+    }
+    add(line, column) {
+        return new Mapping(this.sourceLines, this.sourceLoc, {
+            start: addPos(this.targetLoc.start, line, column),
+            end: addPos(this.targetLoc.end, line, column),
+        });
+    }
+    subtract(line, column) {
+        return new Mapping(this.sourceLines, this.sourceLoc, {
+            start: subtractPos(this.targetLoc.start, line, column),
+            end: subtractPos(this.targetLoc.end, line, column),
+        });
+    }
+    indent(by, skipFirstLine = false, noNegativeColumns = false) {
+        if (by === 0) {
+            return this;
+        }
+        let targetLoc = this.targetLoc;
+        const startLine = targetLoc.start.line;
+        const endLine = targetLoc.end.line;
+        if (skipFirstLine && startLine === 1 && endLine === 1) {
+            return this;
+        }
+        targetLoc = {
+            start: targetLoc.start,
+            end: targetLoc.end,
+        };
+        if (!skipFirstLine || startLine > 1) {
+            const startColumn = targetLoc.start.column + by;
+            targetLoc.start = {
+                line: startLine,
+                column: noNegativeColumns ? Math.max(0, startColumn) : startColumn,
+            };
+        }
+        if (!skipFirstLine || endLine > 1) {
+            const endColumn = targetLoc.end.column + by;
+            targetLoc.end = {
+                line: endLine,
+                column: noNegativeColumns ? Math.max(0, endColumn) : endColumn,
+            };
+        }
+        return new Mapping(this.sourceLines, this.sourceLoc, targetLoc);
+    }
+}
+function addPos(toPos, line, column) {
+    return {
+        line: toPos.line + line - 1,
+        column: toPos.line === 1 ? toPos.column + column : toPos.column,
+    };
+}
+function subtractPos(fromPos, line, column) {
+    return {
+        line: fromPos.line - line + 1,
+        column: fromPos.line === line ? fromPos.column - column : fromPos.column,
+    };
+}
+function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {
+    const targetComparison = comparePos(targetFromPos, targetToPos);
+    if (targetComparison === 0) {
+        // Trivial case: no characters to skip.
+        return sourceFromPos;
+    }
+    let sourceCursor, targetCursor;
+    if (targetComparison < 0) {
+        // Skipping forward.
+        sourceCursor =
+            sourceLines.skipSpaces(sourceFromPos) || sourceLines.lastPos();
+        targetCursor =
+            targetLines.skipSpaces(targetFromPos) || targetLines.lastPos();
+        const lineDiff = targetToPos.line - targetCursor.line;
+        sourceCursor.line += lineDiff;
+        targetCursor.line += lineDiff;
+        if (lineDiff > 0) {
+            // If jumping to later lines, reset columns to the beginnings
+            // of those lines.
+            sourceCursor.column = 0;
+            targetCursor.column = 0;
+        }
+        else {
+            assert.strictEqual(lineDiff, 0);
+        }
+        while (comparePos(targetCursor, targetToPos) < 0 &&
+            targetLines.nextPos(targetCursor, true)) {
+            assert.ok(sourceLines.nextPos(sourceCursor, true));
+            assert.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
+        }
+    }
+    else {
+        // Skipping backward.
+        sourceCursor =
+            sourceLines.skipSpaces(sourceFromPos, true) || sourceLines.firstPos();
+        targetCursor =
+            targetLines.skipSpaces(targetFromPos, true) || targetLines.firstPos();
+        const lineDiff = targetToPos.line - targetCursor.line;
+        sourceCursor.line += lineDiff;
+        targetCursor.line += lineDiff;
+        if (lineDiff < 0) {
+            // If jumping to earlier lines, reset columns to the ends of
+            // those lines.
+            sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);
+            targetCursor.column = targetLines.getLineLength(targetCursor.line);
+        }
+        else {
+            assert.strictEqual(lineDiff, 0);
+        }
+        while (comparePos(targetToPos, targetCursor) < 0 &&
+            targetLines.prevPos(targetCursor, true)) {
+            assert.ok(sourceLines.prevPos(sourceCursor, true));
+            assert.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
+        }
+    }
+    return sourceCursor;
+}
diff --git a/node_modules/recast/esm/lib/options.d.ts b/node_modules/recast/esm/lib/options.d.ts
new file mode 100644
index 0000000..61488a9
--- /dev/null
+++ b/node_modules/recast/esm/lib/options.d.ts
@@ -0,0 +1,147 @@
+/**
+ * All Recast API functions take second parameter with configuration options,
+ * documented in options.js
+ */
+export interface Options extends DeprecatedOptions {
+    /**
+     * If you want to use a different branch of esprima, or any other module
+     * that supports a .parse function, pass that module object to
+     * recast.parse as options.parser (legacy synonym: options.esprima).
+     * @default require("recast/parsers/esprima")
+     */
+    parser?: any;
+    /**
+     * Number of spaces the pretty-printer should use per tab for
+     * indentation. If you do not pass this option explicitly, it will be
+     * (quite reliably!) inferred from the original code.
+     * @default 4
+     */
+    tabWidth?: number;
+    /**
+     * If you really want the pretty-printer to use tabs instead of spaces,
+     * make this option true.
+     * @default false
+     */
+    useTabs?: boolean;
+    /**
+     * The reprinting code leaves leading whitespace untouched unless it has
+     * to reindent a line, or you pass false for this option.
+     * @default true
+     */
+    reuseWhitespace?: boolean;
+    /**
+     * Override this option to use a different line terminator, e.g. \r\n.
+     * @default require("os").EOL || "\n"
+     */
+    lineTerminator?: string;
+    /**
+     * Some of the pretty-printer code (such as that for printing function
+     * parameter lists) makes a valiant attempt to prevent really long
+     * lines. You can adjust the limit by changing this option; however,
+     * there is no guarantee that line length will fit inside this limit.
+     * @default 74
+     */
+    wrapColumn?: number;
+    /**
+     * Pass a string as options.sourceFileName to recast.parse to tell the
+     * reprinter to keep track of reused code so that it can construct a
+     * source map automatically.
+     * @default null
+     */
+    sourceFileName?: string | null;
+    /**
+     * Pass a string as options.sourceMapName to recast.print, and (provided
+     * you passed options.sourceFileName earlier) the PrintResult of
+     * recast.print will have a .map property for the generated source map.
+     * @default null
+     */
+    sourceMapName?: string | null;
+    /**
+     * If provided, this option will be passed along to the source map
+     * generator as a root directory for relative source file paths.
+     * @default null
+     */
+    sourceRoot?: string | null;
+    /**
+     * If you provide a source map that was generated from a previous call
+     * to recast.print as options.inputSourceMap, the old source map will be
+     * composed with the new source map.
+     * @default null
+     */
+    inputSourceMap?: string | null;
+    /**
+     * If you want esprima to generate .range information (recast only uses
+     * .loc internally), pass true for this option.
+     * @default false
+     */
+    range?: boolean;
+    /**
+     * If you want esprima not to throw exceptions when it encounters
+     * non-fatal errors, keep this option true.
+     * @default true
+     */
+    tolerant?: boolean;
+    /**
+     * If you want to override the quotes used in string literals, specify
+     * either "single", "double", or "auto" here ("auto" will select the one
+     * which results in the shorter literal) Otherwise, use double quotes.
+     * @default null
+     */
+    quote?: "single" | "double" | "auto" | null;
+    /**
+     * Controls the printing of trailing commas in object literals, array
+     * expressions and function parameters.
+     *
+     * This option could either be:
+     * * Boolean - enable/disable in all contexts (objects, arrays and function params).
+     * * Object - enable/disable per context.
+     *
+     * Example:
+     * trailingComma: {
+     *   objects: true,
+     *   arrays: true,
+     *   parameters: false,
+     * }
+     *
+     * @default false
+     */
+    trailingComma?: boolean;
+    /**
+     * Controls the printing of spaces inside array brackets.
+     * See: http://eslint.org/docs/rules/array-bracket-spacing
+     * @default false
+     */
+    arrayBracketSpacing?: boolean;
+    /**
+     * Controls the printing of spaces inside object literals,
+     * destructuring assignments, and import/export specifiers.
+     * See: http://eslint.org/docs/rules/object-curly-spacing
+     * @default true
+     */
+    objectCurlySpacing?: boolean;
+    /**
+     * If you want parenthesis to wrap single-argument arrow function
+     * parameter lists, pass true for this option.
+     * @default false
+     */
+    arrowParensAlways?: boolean;
+    /**
+     * There are 2 supported syntaxes (`,` and `;`) in Flow Object Types;
+     * The use of commas is in line with the more popular style and matches
+     * how objects are defined in JS, making it a bit more natural to write.
+     * @default true
+     */
+    flowObjectCommas?: boolean;
+    /**
+     * Whether to return an array of .tokens on the root AST node.
+     * @default true
+     */
+    tokens?: boolean;
+}
+interface DeprecatedOptions {
+    /** @deprecated */
+    esprima?: any;
+}
+export type NormalizedOptions = Required<Omit<Options, keyof DeprecatedOptions>>;
+export declare function normalize(opts?: Options): NormalizedOptions;
+export {};
diff --git a/node_modules/recast/esm/lib/options.mjs b/node_modules/recast/esm/lib/options.mjs
new file mode 100644
index 0000000..0862c71
--- /dev/null
+++ b/node_modules/recast/esm/lib/options.mjs
@@ -0,0 +1,52 @@
+import { getLineTerminator } from "./util.mjs";
+import * as esprima from "../parsers/esprima.mjs";
+const defaults = {
+    parser: esprima,
+    tabWidth: 4,
+    useTabs: false,
+    reuseWhitespace: true,
+    lineTerminator: getLineTerminator(),
+    wrapColumn: 74,
+    sourceFileName: null,
+    sourceMapName: null,
+    sourceRoot: null,
+    inputSourceMap: null,
+    range: false,
+    tolerant: true,
+    quote: null,
+    trailingComma: false,
+    arrayBracketSpacing: false,
+    objectCurlySpacing: true,
+    arrowParensAlways: false,
+    flowObjectCommas: true,
+    tokens: true,
+};
+const hasOwn = defaults.hasOwnProperty;
+// Copy options and fill in default values.
+export function normalize(opts) {
+    const options = opts || defaults;
+    function get(key) {
+        return hasOwn.call(options, key) ? options[key] : defaults[key];
+    }
+    return {
+        tabWidth: +get("tabWidth"),
+        useTabs: !!get("useTabs"),
+        reuseWhitespace: !!get("reuseWhitespace"),
+        lineTerminator: get("lineTerminator"),
+        wrapColumn: Math.max(get("wrapColumn"), 0),
+        sourceFileName: get("sourceFileName"),
+        sourceMapName: get("sourceMapName"),
+        sourceRoot: get("sourceRoot"),
+        inputSourceMap: get("inputSourceMap"),
+        parser: get("esprima") || get("parser"),
+        range: get("range"),
+        tolerant: get("tolerant"),
+        quote: get("quote"),
+        trailingComma: get("trailingComma"),
+        arrayBracketSpacing: get("arrayBracketSpacing"),
+        objectCurlySpacing: get("objectCurlySpacing"),
+        arrowParensAlways: get("arrowParensAlways"),
+        flowObjectCommas: get("flowObjectCommas"),
+        tokens: !!get("tokens"),
+    };
+}
diff --git a/node_modules/recast/esm/lib/parser.d.ts b/node_modules/recast/esm/lib/parser.d.ts
new file mode 100644
index 0000000..3a5795d
--- /dev/null
+++ b/node_modules/recast/esm/lib/parser.d.ts
@@ -0,0 +1,2 @@
+import { Options } from "./options.js";
+export declare function parse(source: string, options?: Partial<Options>): any;
diff --git a/node_modules/recast/esm/lib/parser.mjs b/node_modules/recast/esm/lib/parser.mjs
new file mode 100644
index 0000000..96243c6
--- /dev/null
+++ b/node_modules/recast/esm/lib/parser.mjs
@@ -0,0 +1,246 @@
+import assert from "assert";
+import * as types from "ast-types";
+const b = types.builders;
+const isObject = types.builtInTypes.object;
+const isArray = types.builtInTypes.array;
+import { normalize as normalizeOptions } from "./options.mjs";
+import { fromString } from "./lines.mjs";
+import { attach as attachComments } from "./comments.mjs";
+import * as util from "./util.mjs";
+import * as esprima from "esprima";
+export function parse(source, options) {
+    options = normalizeOptions(options);
+    const lines = fromString(source, options);
+    const sourceWithoutTabs = lines.toString({
+        tabWidth: options.tabWidth,
+        reuseWhitespace: false,
+        useTabs: false,
+    });
+    let comments = [];
+    const ast = options.parser.parse(sourceWithoutTabs, {
+        jsx: true,
+        loc: true,
+        locations: true,
+        range: options.range,
+        comment: true,
+        onComment: comments,
+        tolerant: util.getOption(options, "tolerant", true),
+        ecmaVersion: 6,
+        sourceType: util.getOption(options, "sourceType", "module"),
+    });
+    // Use ast.tokens if possible, and otherwise fall back to the Esprima
+    // tokenizer. All the preconfigured ../parsers/* expose ast.tokens
+    // automatically, but custom parsers might need additional configuration
+    // to avoid this fallback.
+    const tokens = Array.isArray(ast.tokens)
+        ? ast.tokens
+        : esprima.tokenize(sourceWithoutTabs, {
+            loc: true,
+        });
+    // We will reattach the tokens array to the file object below.
+    delete ast.tokens;
+    // Make sure every token has a token.value string.
+    tokens.forEach(function (token) {
+        if (typeof token.value !== "string") {
+            token.value = lines.sliceString(token.loc.start, token.loc.end);
+        }
+    });
+    if (Array.isArray(ast.comments)) {
+        comments = ast.comments;
+        delete ast.comments;
+    }
+    if (ast.loc) {
+        // If the source was empty, some parsers give loc.{start,end}.line
+        // values of 0, instead of the minimum of 1.
+        util.fixFaultyLocations(ast, lines);
+    }
+    else {
+        ast.loc = {
+            start: lines.firstPos(),
+            end: lines.lastPos(),
+        };
+    }
+    ast.loc.lines = lines;
+    ast.loc.indent = 0;
+    let file;
+    let program;
+    if (ast.type === "Program") {
+        program = ast;
+        // In order to ensure we reprint leading and trailing program
+        // comments, wrap the original Program node with a File node. Only
+        // ESTree parsers (Acorn and Esprima) return a Program as the root AST
+        // node. Most other (Babylon-like) parsers return a File.
+        file = b.file(ast, options.sourceFileName || null);
+        file.loc = {
+            start: lines.firstPos(),
+            end: lines.lastPos(),
+            lines: lines,
+            indent: 0,
+        };
+    }
+    else if (ast.type === "File") {
+        file = ast;
+        program = file.program;
+    }
+    // Expose file.tokens unless the caller passed false for options.tokens.
+    if (options.tokens) {
+        file.tokens = tokens;
+    }
+    // Expand the Program's .loc to include all comments (not just those
+    // attached to the Program node, as its children may have comments as
+    // well), since sometimes program.loc.{start,end} will coincide with the
+    // .loc.{start,end} of the first and last *statements*, mistakenly
+    // excluding comments that fall outside that region.
+    const trueProgramLoc = util.getTrueLoc({
+        type: program.type,
+        loc: program.loc,
+        body: [],
+        comments,
+    }, lines);
+    program.loc.start = trueProgramLoc.start;
+    program.loc.end = trueProgramLoc.end;
+    // Passing file.program here instead of just file means that initial
+    // comments will be attached to program.body[0] instead of program.
+    attachComments(comments, program.body.length ? file.program : file, lines);
+    // Return a copy of the original AST so that any changes made may be
+    // compared to the original.
+    return new TreeCopier(lines, tokens).copy(file);
+}
+const TreeCopier = function TreeCopier(lines, tokens) {
+    assert.ok(this instanceof TreeCopier);
+    this.lines = lines;
+    this.tokens = tokens;
+    this.startTokenIndex = 0;
+    this.endTokenIndex = tokens.length;
+    this.indent = 0;
+    this.seen = new Map();
+};
+const TCp = TreeCopier.prototype;
+TCp.copy = function (node) {
+    if (this.seen.has(node)) {
+        return this.seen.get(node);
+    }
+    if (isArray.check(node)) {
+        const copy = new Array(node.length);
+        this.seen.set(node, copy);
+        node.forEach(function (item, i) {
+            copy[i] = this.copy(item);
+        }, this);
+        return copy;
+    }
+    if (!isObject.check(node)) {
+        return node;
+    }
+    util.fixFaultyLocations(node, this.lines);
+    const copy = Object.create(Object.getPrototypeOf(node), {
+        original: {
+            // Provide a link from the copy to the original.
+            value: node,
+            configurable: false,
+            enumerable: false,
+            writable: true,
+        },
+    });
+    this.seen.set(node, copy);
+    const loc = node.loc;
+    const oldIndent = this.indent;
+    let newIndent = oldIndent;
+    const oldStartTokenIndex = this.startTokenIndex;
+    const oldEndTokenIndex = this.endTokenIndex;
+    if (loc) {
+        // When node is a comment, we set node.loc.indent to
+        // node.loc.start.column so that, when/if we print the comment by
+        // itself, we can strip that much whitespace from the left margin of
+        // the comment. This only really matters for multiline Block comments,
+        // but it doesn't hurt for Line comments.
+        if (node.type === "Block" ||
+            node.type === "Line" ||
+            node.type === "CommentBlock" ||
+            node.type === "CommentLine" ||
+            this.lines.isPrecededOnlyByWhitespace(loc.start)) {
+            newIndent = this.indent = loc.start.column;
+        }
+        // Every node.loc has a reference to the original source lines as well
+        // as a complete list of source tokens.
+        loc.lines = this.lines;
+        loc.tokens = this.tokens;
+        loc.indent = newIndent;
+        // Set loc.start.token and loc.end.token such that
+        // loc.tokens.slice(loc.start.token, loc.end.token) returns a list of
+        // all the tokens that make up this node.
+        this.findTokenRange(loc);
+    }
+    const keys = Object.keys(node);
+    const keyCount = keys.length;
+    for (let i = 0; i < keyCount; ++i) {
+        const key = keys[i];
+        if (key === "loc") {
+            copy[key] = node[key];
+        }
+        else if (key === "tokens" && node.type === "File") {
+            // Preserve file.tokens (uncopied) in case client code cares about
+            // it, even though Recast ignores it when reprinting.
+            copy[key] = node[key];
+        }
+        else {
+            copy[key] = this.copy(node[key]);
+        }
+    }
+    this.indent = oldIndent;
+    this.startTokenIndex = oldStartTokenIndex;
+    this.endTokenIndex = oldEndTokenIndex;
+    return copy;
+};
+// If we didn't have any idea where in loc.tokens to look for tokens
+// contained by this loc, a binary search would be appropriate, but
+// because we maintain this.startTokenIndex and this.endTokenIndex as we
+// traverse the AST, we only need to make small (linear) adjustments to
+// those indexes with each recursive iteration.
+TCp.findTokenRange = function (loc) {
+    // In the unlikely event that loc.tokens[this.startTokenIndex] starts
+    // *after* loc.start, we need to rewind this.startTokenIndex first.
+    while (this.startTokenIndex > 0) {
+        const token = loc.tokens[this.startTokenIndex];
+        if (util.comparePos(loc.start, token.loc.start) < 0) {
+            --this.startTokenIndex;
+        }
+        else
+            break;
+    }
+    // In the unlikely event that loc.tokens[this.endTokenIndex - 1] ends
+    // *before* loc.end, we need to fast-forward this.endTokenIndex first.
+    while (this.endTokenIndex < loc.tokens.length) {
+        const token = loc.tokens[this.endTokenIndex];
+        if (util.comparePos(token.loc.end, loc.end) < 0) {
+            ++this.endTokenIndex;
+        }
+        else
+            break;
+    }
+    // Increment this.startTokenIndex until we've found the first token
+    // contained by this node.
+    while (this.startTokenIndex < this.endTokenIndex) {
+        const token = loc.tokens[this.startTokenIndex];
+        if (util.comparePos(token.loc.start, loc.start) < 0) {
+            ++this.startTokenIndex;
+        }
+        else
+            break;
+    }
+    // Index into loc.tokens of the first token within this node.
+    loc.start.token = this.startTokenIndex;
+    // Decrement this.endTokenIndex until we've found the first token after
+    // this node (not contained by the node).
+    while (this.endTokenIndex > this.startTokenIndex) {
+        const token = loc.tokens[this.endTokenIndex - 1];
+        if (util.comparePos(loc.end, token.loc.end) < 0) {
+            --this.endTokenIndex;
+        }
+        else
+            break;
+    }
+    // Index into loc.tokens of the first token *after* this node.
+    // If loc.start.token === loc.end.token, the node contains no tokens,
+    // and the index is that of the next token following this node.
+    loc.end.token = this.endTokenIndex;
+};
diff --git a/node_modules/recast/esm/lib/patcher.d.ts b/node_modules/recast/esm/lib/patcher.d.ts
new file mode 100644
index 0000000..dcc065c
--- /dev/null
+++ b/node_modules/recast/esm/lib/patcher.d.ts
@@ -0,0 +1,12 @@
+interface PatcherType {
+    replace(loc: any, lines: any): any;
+    get(loc?: any): any;
+    tryToReprintComments(newNode: any, oldNode: any, print: any): any;
+    deleteComments(node: any): any;
+}
+interface PatcherConstructor {
+    new (lines: any): PatcherType;
+}
+declare const Patcher: PatcherConstructor;
+export { Patcher };
+export declare function getReprinter(path: any): ((print: any) => any) | undefined;
diff --git a/node_modules/recast/esm/lib/patcher.mjs b/node_modules/recast/esm/lib/patcher.mjs
new file mode 100644
index 0000000..baa32b7
--- /dev/null
+++ b/node_modules/recast/esm/lib/patcher.mjs
@@ -0,0 +1,381 @@
+import assert from "assert";
+import * as linesModule from "./lines.mjs";
+import * as types from "ast-types";
+const Printable = types.namedTypes.Printable;
+const Expression = types.namedTypes.Expression;
+const ReturnStatement = types.namedTypes.ReturnStatement;
+const SourceLocation = types.namedTypes.SourceLocation;
+import { comparePos, copyPos, getUnionOfKeys } from "./util.mjs";
+import FastPath from "./fast-path.mjs";
+const isObject = types.builtInTypes.object;
+const isArray = types.builtInTypes.array;
+const isString = types.builtInTypes.string;
+const riskyAdjoiningCharExp = /[0-9a-z_$]/i;
+const Patcher = function Patcher(lines) {
+    assert.ok(this instanceof Patcher);
+    assert.ok(lines instanceof linesModule.Lines);
+    const self = this, replacements = [];
+    self.replace = function (loc, lines) {
+        if (isString.check(lines))
+            lines = linesModule.fromString(lines);
+        replacements.push({
+            lines: lines,
+            start: loc.start,
+            end: loc.end,
+        });
+    };
+    self.get = function (loc) {
+        // If no location is provided, return the complete Lines object.
+        loc = loc || {
+            start: { line: 1, column: 0 },
+            end: { line: lines.length, column: lines.getLineLength(lines.length) },
+        };
+        let sliceFrom = loc.start, toConcat = [];
+        function pushSlice(from, to) {
+            assert.ok(comparePos(from, to) <= 0);
+            toConcat.push(lines.slice(from, to));
+        }
+        replacements
+            .sort((a, b) => comparePos(a.start, b.start))
+            .forEach(function (rep) {
+            if (comparePos(sliceFrom, rep.start) > 0) {
+                // Ignore nested replacement ranges.
+            }
+            else {
+                pushSlice(sliceFrom, rep.start);
+                toConcat.push(rep.lines);
+                sliceFrom = rep.end;
+            }
+        });
+        pushSlice(sliceFrom, loc.end);
+        return linesModule.concat(toConcat);
+    };
+};
+export { Patcher };
+const Pp = Patcher.prototype;
+Pp.tryToReprintComments = function (newNode, oldNode, print) {
+    const patcher = this;
+    if (!newNode.comments && !oldNode.comments) {
+        // We were (vacuously) able to reprint all the comments!
+        return true;
+    }
+    const newPath = FastPath.from(newNode);
+    const oldPath = FastPath.from(oldNode);
+    newPath.stack.push("comments", getSurroundingComments(newNode));
+    oldPath.stack.push("comments", getSurroundingComments(oldNode));
+    const reprints = [];
+    const ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);
+    // No need to pop anything from newPath.stack or oldPath.stack, since
+    // newPath and oldPath are fresh local variables.
+    if (ableToReprintComments && reprints.length > 0) {
+        reprints.forEach(function (reprint) {
+            const oldComment = reprint.oldPath.getValue();
+            assert.ok(oldComment.leading || oldComment.trailing);
+            patcher.replace(oldComment.loc, 
+            // Comments can't have .comments, so it doesn't matter whether we
+            // print with comments or without.
+            print(reprint.newPath).indentTail(oldComment.loc.indent));
+        });
+    }
+    return ableToReprintComments;
+};
+// Get all comments that are either leading or trailing, ignoring any
+// comments that occur inside node.loc. Returns an empty array for nodes
+// with no leading or trailing comments.
+function getSurroundingComments(node) {
+    const result = [];
+    if (node.comments && node.comments.length > 0) {
+        node.comments.forEach(function (comment) {
+            if (comment.leading || comment.trailing) {
+                result.push(comment);
+            }
+        });
+    }
+    return result;
+}
+Pp.deleteComments = function (node) {
+    if (!node.comments) {
+        return;
+    }
+    const patcher = this;
+    node.comments.forEach(function (comment) {
+        if (comment.leading) {
+            // Delete leading comments along with any trailing whitespace they
+            // might have.
+            patcher.replace({
+                start: comment.loc.start,
+                end: node.loc.lines.skipSpaces(comment.loc.end, false, false),
+            }, "");
+        }
+        else if (comment.trailing) {
+            // Delete trailing comments along with any leading whitespace they
+            // might have.
+            patcher.replace({
+                start: node.loc.lines.skipSpaces(comment.loc.start, true, false),
+                end: comment.loc.end,
+            }, "");
+        }
+    });
+};
+export function getReprinter(path) {
+    assert.ok(path instanceof FastPath);
+    // Make sure that this path refers specifically to a Node, rather than
+    // some non-Node subproperty of a Node.
+    const node = path.getValue();
+    if (!Printable.check(node))
+        return;
+    const orig = node.original;
+    const origLoc = orig && orig.loc;
+    const lines = origLoc && origLoc.lines;
+    const reprints = [];
+    if (!lines || !findReprints(path, reprints))
+        return;
+    return function (print) {
+        const patcher = new Patcher(lines);
+        reprints.forEach(function (reprint) {
+            const newNode = reprint.newPath.getValue();
+            const oldNode = reprint.oldPath.getValue();
+            SourceLocation.assert(oldNode.loc, true);
+            const needToPrintNewPathWithComments = !patcher.tryToReprintComments(newNode, oldNode, print);
+            if (needToPrintNewPathWithComments) {
+                // Since we were not able to preserve all leading/trailing
+                // comments, we delete oldNode's comments, print newPath with
+                // comments, and then patch the resulting lines where oldNode used
+                // to be.
+                patcher.deleteComments(oldNode);
+            }
+            let newLines = print(reprint.newPath, {
+                includeComments: needToPrintNewPathWithComments,
+                // If the oldNode we're replacing already had parentheses, we may
+                // not need to print the new node with any extra parentheses,
+                // because the existing parentheses will suffice. However, if the
+                // newNode has a different type than the oldNode, let the printer
+                // decide if reprint.newPath needs parentheses, as usual.
+                avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens(),
+            }).indentTail(oldNode.loc.indent);
+            const nls = needsLeadingSpace(lines, oldNode.loc, newLines);
+            const nts = needsTrailingSpace(lines, oldNode.loc, newLines);
+            // If we try to replace the argument of a ReturnStatement like
+            // return"asdf" with e.g. a literal null expression, we run the risk
+            // of ending up with returnnull, so we need to add an extra leading
+            // space in situations where that might happen. Likewise for
+            // "asdf"in obj. See #170.
+            if (nls || nts) {
+                const newParts = [];
+                nls && newParts.push(" ");
+                newParts.push(newLines);
+                nts && newParts.push(" ");
+                newLines = linesModule.concat(newParts);
+            }
+            patcher.replace(oldNode.loc, newLines);
+        });
+        // Recall that origLoc is the .loc of an ancestor node that is
+        // guaranteed to contain all the reprinted nodes and comments.
+        const patchedLines = patcher.get(origLoc).indentTail(-orig.loc.indent);
+        if (path.needsParens()) {
+            return linesModule.concat(["(", patchedLines, ")"]);
+        }
+        return patchedLines;
+    };
+}
+// If the last character before oldLoc and the first character of newLines
+// are both identifier characters, they must be separated by a space,
+// otherwise they will most likely get fused together into a single token.
+function needsLeadingSpace(oldLines, oldLoc, newLines) {
+    const posBeforeOldLoc = copyPos(oldLoc.start);
+    // The character just before the location occupied by oldNode.
+    const charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);
+    // First character of the reprinted node.
+    const newFirstChar = newLines.charAt(newLines.firstPos());
+    return (charBeforeOldLoc &&
+        riskyAdjoiningCharExp.test(charBeforeOldLoc) &&
+        newFirstChar &&
+        riskyAdjoiningCharExp.test(newFirstChar));
+}
+// If the last character of newLines and the first character after oldLoc
+// are both identifier characters, they must be separated by a space,
+// otherwise they will most likely get fused together into a single token.
+function needsTrailingSpace(oldLines, oldLoc, newLines) {
+    // The character just after the location occupied by oldNode.
+    const charAfterOldLoc = oldLines.charAt(oldLoc.end);
+    const newLastPos = newLines.lastPos();
+    // Last character of the reprinted node.
+    const newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);
+    return (newLastChar &&
+        riskyAdjoiningCharExp.test(newLastChar) &&
+        charAfterOldLoc &&
+        riskyAdjoiningCharExp.test(charAfterOldLoc));
+}
+function findReprints(newPath, reprints) {
+    const newNode = newPath.getValue();
+    Printable.assert(newNode);
+    const oldNode = newNode.original;
+    Printable.assert(oldNode);
+    assert.deepEqual(reprints, []);
+    if (newNode.type !== oldNode.type) {
+        return false;
+    }
+    const oldPath = new FastPath(oldNode);
+    const canReprint = findChildReprints(newPath, oldPath, reprints);
+    if (!canReprint) {
+        // Make absolutely sure the calling code does not attempt to reprint
+        // any nodes.
+        reprints.length = 0;
+    }
+    return canReprint;
+}
+function findAnyReprints(newPath, oldPath, reprints) {
+    const newNode = newPath.getValue();
+    const oldNode = oldPath.getValue();
+    if (newNode === oldNode)
+        return true;
+    if (isArray.check(newNode))
+        return findArrayReprints(newPath, oldPath, reprints);
+    if (isObject.check(newNode))
+        return findObjectReprints(newPath, oldPath, reprints);
+    return false;
+}
+function findArrayReprints(newPath, oldPath, reprints) {
+    const newNode = newPath.getValue();
+    const oldNode = oldPath.getValue();
+    if (newNode === oldNode ||
+        newPath.valueIsDuplicate() ||
+        oldPath.valueIsDuplicate()) {
+        return true;
+    }
+    isArray.assert(newNode);
+    const len = newNode.length;
+    if (!(isArray.check(oldNode) && oldNode.length === len))
+        return false;
+    for (let i = 0; i < len; ++i) {
+        newPath.stack.push(i, newNode[i]);
+        oldPath.stack.push(i, oldNode[i]);
+        const canReprint = findAnyReprints(newPath, oldPath, reprints);
+        newPath.stack.length -= 2;
+        oldPath.stack.length -= 2;
+        if (!canReprint) {
+            return false;
+        }
+    }
+    return true;
+}
+function findObjectReprints(newPath, oldPath, reprints) {
+    const newNode = newPath.getValue();
+    isObject.assert(newNode);
+    if (newNode.original === null) {
+        // If newNode.original node was set to null, reprint the node.
+        return false;
+    }
+    const oldNode = oldPath.getValue();
+    if (!isObject.check(oldNode))
+        return false;
+    if (newNode === oldNode ||
+        newPath.valueIsDuplicate() ||
+        oldPath.valueIsDuplicate()) {
+        return true;
+    }
+    if (Printable.check(newNode)) {
+        if (!Printable.check(oldNode)) {
+            return false;
+        }
+        const newParentNode = newPath.getParentNode();
+        const oldParentNode = oldPath.getParentNode();
+        if (oldParentNode !== null &&
+            oldParentNode.type === "FunctionTypeAnnotation" &&
+            newParentNode !== null &&
+            newParentNode.type === "FunctionTypeAnnotation") {
+            const oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;
+            const newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;
+            if (!oldNeedsParens && newNeedParens) {
+                return false;
+            }
+        }
+        // Here we need to decide whether the reprinted code for newNode is
+        // appropriate for patching into the location of oldNode.
+        if (newNode.type === oldNode.type) {
+            const childReprints = [];
+            if (findChildReprints(newPath, oldPath, childReprints)) {
+                reprints.push.apply(reprints, childReprints);
+            }
+            else if (oldNode.loc) {
+                // If we have no .loc information for oldNode, then we won't be
+                // able to reprint it.
+                reprints.push({
+                    oldPath: oldPath.copy(),
+                    newPath: newPath.copy(),
+                });
+            }
+            else {
+                return false;
+            }
+            return true;
+        }
+        if (Expression.check(newNode) &&
+            Expression.check(oldNode) &&
+            // If we have no .loc information for oldNode, then we won't be
+            // able to reprint it.
+            oldNode.loc) {
+            // If both nodes are subtypes of Expression, then we should be able
+            // to fill the location occupied by the old node with code printed
+            // for the new node with no ill consequences.
+            reprints.push({
+                oldPath: oldPath.copy(),
+                newPath: newPath.copy(),
+            });
+            return true;
+        }
+        // The nodes have different types, and at least one of the types is
+        // not a subtype of the Expression type, so we cannot safely assume
+        // the nodes are syntactically interchangeable.
+        return false;
+    }
+    return findChildReprints(newPath, oldPath, reprints);
+}
+function findChildReprints(newPath, oldPath, reprints) {
+    const newNode = newPath.getValue();
+    const oldNode = oldPath.getValue();
+    isObject.assert(newNode);
+    isObject.assert(oldNode);
+    if (newNode.original === null) {
+        // If newNode.original node was set to null, reprint the node.
+        return false;
+    }
+    // If this node needs parentheses and will not be wrapped with
+    // parentheses when reprinted, then return false to skip reprinting and
+    // let it be printed generically.
+    if (newPath.needsParens() && !oldPath.hasParens()) {
+        return false;
+    }
+    const keys = getUnionOfKeys(oldNode, newNode);
+    if (oldNode.type === "File" || newNode.type === "File") {
+        // Don't bother traversing file.tokens, an often very large array
+        // returned by Babylon, and useless for our purposes.
+        delete keys.tokens;
+    }
+    // Don't bother traversing .loc objects looking for reprintable nodes.
+    delete keys.loc;
+    const originalReprintCount = reprints.length;
+    for (let k in keys) {
+        if (k.charAt(0) === "_") {
+            // Ignore "private" AST properties added by e.g. Babel plugins and
+            // parsers like Babylon.
+            continue;
+        }
+        newPath.stack.push(k, types.getFieldValue(newNode, k));
+        oldPath.stack.push(k, types.getFieldValue(oldNode, k));
+        const canReprint = findAnyReprints(newPath, oldPath, reprints);
+        newPath.stack.length -= 2;
+        oldPath.stack.length -= 2;
+        if (!canReprint) {
+            return false;
+        }
+    }
+    // Return statements might end up running into ASI issues due to
+    // comments inserted deep within the tree, so reprint them if anything
+    // changed within them.
+    if (ReturnStatement.check(newPath.getNode()) &&
+        reprints.length > originalReprintCount) {
+        return false;
+    }
+    return true;
+}
diff --git a/node_modules/recast/esm/lib/printer.d.ts b/node_modules/recast/esm/lib/printer.d.ts
new file mode 100644
index 0000000..d8e2cfa
--- /dev/null
+++ b/node_modules/recast/esm/lib/printer.d.ts
@@ -0,0 +1,14 @@
+export interface PrintResultType {
+    code: string;
+    map?: any;
+    toString(): string;
+}
+interface PrinterType {
+    print(ast: any): PrintResultType;
+    printGenerically(ast: any): PrintResultType;
+}
+interface PrinterConstructor {
+    new (config?: any): PrinterType;
+}
+declare const Printer: PrinterConstructor;
+export { Printer };
diff --git a/node_modules/recast/esm/lib/printer.mjs b/node_modules/recast/esm/lib/printer.mjs
new file mode 100644
index 0000000..496bf7a
--- /dev/null
+++ b/node_modules/recast/esm/lib/printer.mjs
@@ -0,0 +1,2373 @@
+import assert from "assert";
+import * as types from "ast-types";
+import { printComments } from "./comments.mjs";
+import FastPath from "./fast-path.mjs";
+import { concat, fromString } from "./lines.mjs";
+import { normalize as normalizeOptions } from "./options.mjs";
+import { getReprinter } from "./patcher.mjs";
+import * as util from "./util.mjs";
+const namedTypes = types.namedTypes;
+const isString = types.builtInTypes.string;
+const isObject = types.builtInTypes.object;
+const PrintResult = function PrintResult(code, sourceMap) {
+    assert.ok(this instanceof PrintResult);
+    isString.assert(code);
+    this.code = code;
+    if (sourceMap) {
+        isObject.assert(sourceMap);
+        this.map = sourceMap;
+    }
+};
+const PRp = PrintResult.prototype;
+let warnedAboutToString = false;
+PRp.toString = function () {
+    if (!warnedAboutToString) {
+        console.warn("Deprecation warning: recast.print now returns an object with " +
+            "a .code property. You appear to be treating the object as a " +
+            "string, which might still work but is strongly discouraged.");
+        warnedAboutToString = true;
+    }
+    return this.code;
+};
+const emptyPrintResult = new PrintResult("");
+const Printer = function Printer(config) {
+    assert.ok(this instanceof Printer);
+    const explicitTabWidth = config && config.tabWidth;
+    config = normalizeOptions(config);
+    // It's common for client code to pass the same options into both
+    // recast.parse and recast.print, but the Printer doesn't need (and
+    // can be confused by) config.sourceFileName, so we null it out.
+    config.sourceFileName = null;
+    // Non-destructively modifies options with overrides, and returns a
+    // new print function that uses the modified options.
+    function makePrintFunctionWith(options, overrides) {
+        options = Object.assign({}, options, overrides);
+        return (path) => print(path, options);
+    }
+    function print(path, options) {
+        assert.ok(path instanceof FastPath);
+        options = options || {};
+        if (options.includeComments) {
+            return printComments(path, makePrintFunctionWith(options, {
+                includeComments: false,
+            }));
+        }
+        const oldTabWidth = config.tabWidth;
+        if (!explicitTabWidth) {
+            const loc = path.getNode().loc;
+            if (loc && loc.lines && loc.lines.guessTabWidth) {
+                config.tabWidth = loc.lines.guessTabWidth();
+            }
+        }
+        const reprinter = getReprinter(path);
+        const lines = reprinter
+            ? // Since the print function that we pass to the reprinter will
+                // be used to print "new" nodes, it's tempting to think we
+                // should pass printRootGenerically instead of print, to avoid
+                // calling maybeReprint again, but that would be a mistake
+                // because the new nodes might not be entirely new, but merely
+                // moved from elsewhere in the AST. The print function is the
+                // right choice because it gives us the opportunity to reprint
+                // such nodes using their original source.
+                reprinter(print)
+            : genericPrint(path, config, options, makePrintFunctionWith(options, {
+                includeComments: true,
+                avoidRootParens: false,
+            }));
+        config.tabWidth = oldTabWidth;
+        return lines;
+    }
+    this.print = function (ast) {
+        if (!ast) {
+            return emptyPrintResult;
+        }
+        const lines = print(FastPath.from(ast), {
+            includeComments: true,
+            avoidRootParens: false,
+        });
+        return new PrintResult(lines.toString(config), util.composeSourceMaps(config.inputSourceMap, lines.getSourceMap(config.sourceMapName, config.sourceRoot)));
+    };
+    this.printGenerically = function (ast) {
+        if (!ast) {
+            return emptyPrintResult;
+        }
+        // Print the entire AST generically.
+        function printGenerically(path) {
+            return printComments(path, (path) => genericPrint(path, config, {
+                includeComments: true,
+                avoidRootParens: false,
+            }, printGenerically));
+        }
+        const path = FastPath.from(ast);
+        const oldReuseWhitespace = config.reuseWhitespace;
+        // Do not reuse whitespace (or anything else, for that matter)
+        // when printing generically.
+        config.reuseWhitespace = false;
+        // TODO Allow printing of comments?
+        const pr = new PrintResult(printGenerically(path).toString(config));
+        config.reuseWhitespace = oldReuseWhitespace;
+        return pr;
+    };
+};
+export { Printer };
+function genericPrint(path, config, options, printPath) {
+    assert.ok(path instanceof FastPath);
+    const node = path.getValue();
+    const parts = [];
+    const linesWithoutParens = genericPrintNoParens(path, config, printPath);
+    if (!node || linesWithoutParens.isEmpty()) {
+        return linesWithoutParens;
+    }
+    let shouldAddParens = false;
+    const decoratorsLines = printDecorators(path, printPath);
+    if (decoratorsLines.isEmpty()) {
+        // Nodes with decorators can't have parentheses, so we can avoid
+        // computing path.needsParens() except in this case.
+        if (!options.avoidRootParens) {
+            shouldAddParens = path.needsParens();
+        }
+    }
+    else {
+        parts.push(decoratorsLines);
+    }
+    if (shouldAddParens) {
+        parts.unshift("(");
+    }
+    parts.push(linesWithoutParens);
+    if (shouldAddParens) {
+        parts.push(")");
+    }
+    return concat(parts);
+}
+// Note that the `options` parameter of this function is what other
+// functions in this file call the `config` object (that is, the
+// configuration object originally passed into the Printer constructor).
+// Its properties are documented in lib/options.js.
+function genericPrintNoParens(path, options, print) {
+    const n = path.getValue();
+    if (!n) {
+        return fromString("");
+    }
+    if (typeof n === "string") {
+        return fromString(n, options);
+    }
+    namedTypes.Printable.assert(n);
+    const parts = [];
+    switch (n.type) {
+        case "File":
+            return path.call(print, "program");
+        case "Program":
+            // Babel 6
+            if (n.directives) {
+                path.each(function (childPath) {
+                    parts.push(print(childPath), ";\n");
+                }, "directives");
+            }
+            if (n.interpreter) {
+                parts.push(path.call(print, "interpreter"));
+            }
+            parts.push(path.call((bodyPath) => printStatementSequence(bodyPath, options, print), "body"));
+            return concat(parts);
+        case "Noop": // Babel extension.
+        case "EmptyStatement":
+            return fromString("");
+        case "ExpressionStatement":
+            return concat([path.call(print, "expression"), ";"]);
+        case "ParenthesizedExpression": // Babel extension.
+            return concat(["(", path.call(print, "expression"), ")"]);
+        case "BinaryExpression":
+        case "LogicalExpression":
+        case "AssignmentExpression":
+            return fromString(" ").join([
+                path.call(print, "left"),
+                n.operator,
+                path.call(print, "right"),
+            ]);
+        case "AssignmentPattern":
+            return concat([
+                path.call(print, "left"),
+                " = ",
+                path.call(print, "right"),
+            ]);
+        case "MemberExpression":
+        case "OptionalMemberExpression": {
+            parts.push(path.call(print, "object"));
+            const property = path.call(print, "property");
+            // Like n.optional, except with defaults applied, so optional
+            // defaults to true for OptionalMemberExpression nodes.
+            const optional = types.getFieldValue(n, "optional");
+            if (n.computed) {
+                parts.push(optional ? "?.[" : "[", property, "]");
+            }
+            else {
+                parts.push(optional ? "?." : ".", property);
+            }
+            return concat(parts);
+        }
+        case "ChainExpression":
+            return path.call(print, "expression");
+        case "MetaProperty":
+            return concat([
+                path.call(print, "meta"),
+                ".",
+                path.call(print, "property"),
+            ]);
+        case "BindExpression":
+            if (n.object) {
+                parts.push(path.call(print, "object"));
+            }
+            parts.push("::", path.call(print, "callee"));
+            return concat(parts);
+        case "Path":
+            return fromString(".").join(n.body);
+        case "Identifier":
+            return concat([
+                fromString(n.name, options),
+                n.optional ? "?" : "",
+                path.call(print, "typeAnnotation"),
+            ]);
+        case "SpreadElement":
+        case "SpreadElementPattern":
+        case "RestProperty": // Babel 6 for ObjectPattern
+        case "SpreadProperty":
+        case "SpreadPropertyPattern":
+        case "ObjectTypeSpreadProperty":
+        case "RestElement":
+            return concat([
+                "...",
+                path.call(print, "argument"),
+                path.call(print, "typeAnnotation"),
+            ]);
+        case "FunctionDeclaration":
+        case "FunctionExpression":
+        case "TSDeclareFunction":
+            if (n.declare) {
+                parts.push("declare ");
+            }
+            if (n.async) {
+                parts.push("async ");
+            }
+            parts.push("function");
+            if (n.generator)
+                parts.push("*");
+            if (n.id) {
+                parts.push(" ", path.call(print, "id"), path.call(print, "typeParameters"));
+            }
+            else {
+                if (n.typeParameters) {
+                    parts.push(path.call(print, "typeParameters"));
+                }
+            }
+            parts.push("(", printFunctionParams(path, options, print), ")", path.call(print, "returnType"));
+            if (n.body) {
+                parts.push(" ", path.call(print, "body"));
+            }
+            return concat(parts);
+        case "ArrowFunctionExpression":
+            if (n.async) {
+                parts.push("async ");
+            }
+            if (n.typeParameters) {
+                parts.push(path.call(print, "typeParameters"));
+            }
+            if (!options.arrowParensAlways &&
+                n.params.length === 1 &&
+                !n.rest &&
+                n.params[0].type === "Identifier" &&
+                !n.params[0].typeAnnotation &&
+                !n.returnType) {
+                parts.push(path.call(print, "params", 0));
+            }
+            else {
+                parts.push("(", printFunctionParams(path, options, print), ")", path.call(print, "returnType"));
+            }
+            parts.push(" => ", path.call(print, "body"));
+            return concat(parts);
+        case "MethodDefinition":
+            return printMethod(path, options, print);
+        case "YieldExpression":
+            parts.push("yield");
+            if (n.delegate)
+                parts.push("*");
+            if (n.argument)
+                parts.push(" ", path.call(print, "argument"));
+            return concat(parts);
+        case "AwaitExpression":
+            parts.push("await");
+            if (n.all)
+                parts.push("*");
+            if (n.argument)
+                parts.push(" ", path.call(print, "argument"));
+            return concat(parts);
+        case "ModuleExpression":
+            return concat([
+                "module {\n",
+                path.call(print, "body").indent(options.tabWidth),
+                "\n}",
+            ]);
+        case "ModuleDeclaration":
+            parts.push("module", path.call(print, "id"));
+            if (n.source) {
+                assert.ok(!n.body);
+                parts.push("from", path.call(print, "source"));
+            }
+            else {
+                parts.push(path.call(print, "body"));
+            }
+            return fromString(" ").join(parts);
+        case "ImportSpecifier":
+            if (n.importKind && n.importKind !== "value") {
+                parts.push(n.importKind + " ");
+            }
+            if (n.imported) {
+                parts.push(path.call(print, "imported"));
+                if (n.local && n.local.name !== n.imported.name) {
+                    parts.push(" as ", path.call(print, "local"));
+                }
+            }
+            else if (n.id) {
+                parts.push(path.call(print, "id"));
+                if (n.name) {
+                    parts.push(" as ", path.call(print, "name"));
+                }
+            }
+            return concat(parts);
+        case "ExportSpecifier":
+            if (n.local) {
+                parts.push(path.call(print, "local"));
+                if (n.exported && n.exported.name !== n.local.name) {
+                    parts.push(" as ", path.call(print, "exported"));
+                }
+            }
+            else if (n.id) {
+                parts.push(path.call(print, "id"));
+                if (n.name) {
+                    parts.push(" as ", path.call(print, "name"));
+                }
+            }
+            return concat(parts);
+        case "ExportBatchSpecifier":
+            return fromString("*");
+        case "ImportNamespaceSpecifier":
+            parts.push("* as ");
+            if (n.local) {
+                parts.push(path.call(print, "local"));
+            }
+            else if (n.id) {
+                parts.push(path.call(print, "id"));
+            }
+            return concat(parts);
+        case "ImportDefaultSpecifier":
+            if (n.local) {
+                return path.call(print, "local");
+            }
+            return path.call(print, "id");
+        case "TSExportAssignment":
+            return concat(["export = ", path.call(print, "expression")]);
+        case "ExportDeclaration":
+        case "ExportDefaultDeclaration":
+        case "ExportNamedDeclaration":
+            return printExportDeclaration(path, options, print);
+        case "ExportAllDeclaration":
+            parts.push("export *");
+            if (n.exported) {
+                parts.push(" as ", path.call(print, "exported"));
+            }
+            parts.push(" from ", path.call(print, "source"), ";");
+            return concat(parts);
+        case "TSNamespaceExportDeclaration":
+            parts.push("export as namespace ", path.call(print, "id"));
+            return maybeAddSemicolon(concat(parts));
+        case "ExportNamespaceSpecifier":
+            return concat(["* as ", path.call(print, "exported")]);
+        case "ExportDefaultSpecifier":
+            return path.call(print, "exported");
+        case "Import":
+            return fromString("import", options);
+        // Recast and ast-types currently support dynamic import(...) using
+        // either this dedicated ImportExpression type or a CallExpression
+        // whose callee has type Import.
+        // https://github.com/benjamn/ast-types/pull/365#issuecomment-605214486
+        case "ImportExpression":
+            return concat(["import(", path.call(print, "source"), ")"]);
+        case "ImportDeclaration": {
+            parts.push("import ");
+            if (n.importKind && n.importKind !== "value") {
+                parts.push(n.importKind + " ");
+            }
+            if (n.specifiers && n.specifiers.length > 0) {
+                const unbracedSpecifiers = [];
+                const bracedSpecifiers = [];
+                path.each(function (specifierPath) {
+                    const spec = specifierPath.getValue();
+                    if (spec.type === "ImportSpecifier") {
+                        bracedSpecifiers.push(print(specifierPath));
+                    }
+                    else if (spec.type === "ImportDefaultSpecifier" ||
+                        spec.type === "ImportNamespaceSpecifier") {
+                        unbracedSpecifiers.push(print(specifierPath));
+                    }
+                }, "specifiers");
+                unbracedSpecifiers.forEach((lines, i) => {
+                    if (i > 0) {
+                        parts.push(", ");
+                    }
+                    parts.push(lines);
+                });
+                if (bracedSpecifiers.length > 0) {
+                    let lines = fromString(", ").join(bracedSpecifiers);
+                    if (lines.getLineLength(1) > options.wrapColumn) {
+                        lines = concat([
+                            fromString(",\n").join(bracedSpecifiers).indent(options.tabWidth),
+                            ",",
+                        ]);
+                    }
+                    if (unbracedSpecifiers.length > 0) {
+                        parts.push(", ");
+                    }
+                    if (lines.length > 1) {
+                        parts.push("{\n", lines, "\n}");
+                    }
+                    else if (options.objectCurlySpacing) {
+                        parts.push("{ ", lines, " }");
+                    }
+                    else {
+                        parts.push("{", lines, "}");
+                    }
+                }
+                parts.push(" from ");
+            }
+            parts.push(path.call(print, "source"), maybePrintImportAssertions(path, options, print), ";");
+            return concat(parts);
+        }
+        case "ImportAttribute":
+            return concat([path.call(print, "key"), ": ", path.call(print, "value")]);
+        case "StaticBlock":
+            parts.push("static ");
+        // Intentionally fall through to BlockStatement below.
+        case "BlockStatement": {
+            const naked = path.call((bodyPath) => printStatementSequence(bodyPath, options, print), "body");
+            if (naked.isEmpty()) {
+                if (!n.directives || n.directives.length === 0) {
+                    parts.push("{}");
+                    return concat(parts);
+                }
+            }
+            parts.push("{\n");
+            // Babel 6
+            if (n.directives) {
+                path.each(function (childPath) {
+                    parts.push(maybeAddSemicolon(print(childPath).indent(options.tabWidth)), n.directives.length > 1 || !naked.isEmpty() ? "\n" : "");
+                }, "directives");
+            }
+            parts.push(naked.indent(options.tabWidth));
+            parts.push("\n}");
+            return concat(parts);
+        }
+        case "ReturnStatement": {
+            parts.push("return");
+            if (n.argument) {
+                const argLines = path.call(print, "argument");
+                if (argLines.startsWithComment() ||
+                    (argLines.length > 1 &&
+                        namedTypes.JSXElement &&
+                        namedTypes.JSXElement.check(n.argument))) {
+                    parts.push(" (\n", argLines.indent(options.tabWidth), "\n)");
+                }
+                else {
+                    parts.push(" ", argLines);
+                }
+            }
+            parts.push(";");
+            return concat(parts);
+        }
+        case "CallExpression":
+        case "OptionalCallExpression":
+            parts.push(path.call(print, "callee"));
+            if (n.typeParameters) {
+                parts.push(path.call(print, "typeParameters"));
+            }
+            if (n.typeArguments) {
+                parts.push(path.call(print, "typeArguments"));
+            }
+            // Like n.optional, but defaults to true for OptionalCallExpression
+            // nodes that are missing an n.optional property (unusual),
+            // according to the OptionalCallExpression definition in ast-types.
+            if (types.getFieldValue(n, "optional")) {
+                parts.push("?.");
+            }
+            parts.push(printArgumentsList(path, options, print));
+            return concat(parts);
+        case "RecordExpression":
+            parts.push("#");
+        // Intentionally fall through to printing the object literal...
+        case "ObjectExpression":
+        case "ObjectPattern":
+        case "ObjectTypeAnnotation": {
+            const isTypeAnnotation = n.type === "ObjectTypeAnnotation";
+            const separator = options.flowObjectCommas
+                ? ","
+                : isTypeAnnotation
+                    ? ";"
+                    : ",";
+            const fields = [];
+            let allowBreak = false;
+            if (isTypeAnnotation) {
+                fields.push("indexers", "callProperties");
+                if (n.internalSlots != null) {
+                    fields.push("internalSlots");
+                }
+            }
+            fields.push("properties");
+            let len = 0;
+            fields.forEach(function (field) {
+                len += n[field].length;
+            });
+            const oneLine = (isTypeAnnotation && len === 1) || len === 0;
+            const leftBrace = n.exact ? "{|" : "{";
+            const rightBrace = n.exact ? "|}" : "}";
+            parts.push(oneLine ? leftBrace : leftBrace + "\n");
+            const leftBraceIndex = parts.length - 1;
+            let i = 0;
+            fields.forEach(function (field) {
+                path.each(function (childPath) {
+                    let lines = print(childPath);
+                    if (!oneLine) {
+                        lines = lines.indent(options.tabWidth);
+                    }
+                    const multiLine = !isTypeAnnotation && lines.length > 1;
+                    if (multiLine && allowBreak) {
+                        // Similar to the logic for BlockStatement.
+                        parts.push("\n");
+                    }
+                    parts.push(lines);
+                    if (i < len - 1) {
+                        // Add an extra line break if the previous object property
+                        // had a multi-line value.
+                        parts.push(separator + (multiLine ? "\n\n" : "\n"));
+                        allowBreak = !multiLine;
+                    }
+                    else if (len !== 1 && isTypeAnnotation) {
+                        parts.push(separator);
+                    }
+                    else if (!oneLine &&
+                        util.isTrailingCommaEnabled(options, "objects") &&
+                        childPath.getValue().type !== "RestElement") {
+                        parts.push(separator);
+                    }
+                    i++;
+                }, field);
+            });
+            if (n.inexact) {
+                const line = fromString("...", options);
+                if (oneLine) {
+                    if (len > 0) {
+                        parts.push(separator, " ");
+                    }
+                    parts.push(line);
+                }
+                else {
+                    // No trailing separator after ... to maintain parity with prettier.
+                    parts.push("\n", line.indent(options.tabWidth));
+                }
+            }
+            parts.push(oneLine ? rightBrace : "\n" + rightBrace);
+            if (i !== 0 && oneLine && options.objectCurlySpacing) {
+                parts[leftBraceIndex] = leftBrace + " ";
+                parts[parts.length - 1] = " " + rightBrace;
+            }
+            if (n.typeAnnotation) {
+                parts.push(path.call(print, "typeAnnotation"));
+            }
+            return concat(parts);
+        }
+        case "PropertyPattern":
+            return concat([
+                path.call(print, "key"),
+                ": ",
+                path.call(print, "pattern"),
+            ]);
+        case "ObjectProperty": // Babel 6
+        case "Property": {
+            // Non-standard AST node type.
+            if (n.method || n.kind === "get" || n.kind === "set") {
+                return printMethod(path, options, print);
+            }
+            if (n.shorthand && n.value.type === "AssignmentPattern") {
+                return path.call(print, "value");
+            }
+            const key = path.call(print, "key");
+            if (n.computed) {
+                parts.push("[", key, "]");
+            }
+            else {
+                parts.push(key);
+            }
+            if (!n.shorthand || n.key.name !== n.value.name) {
+                parts.push(": ", path.call(print, "value"));
+            }
+            return concat(parts);
+        }
+        case "ClassMethod": // Babel 6
+        case "ObjectMethod": // Babel 6
+        case "ClassPrivateMethod":
+        case "TSDeclareMethod":
+            return printMethod(path, options, print);
+        case "PrivateName":
+            return concat(["#", path.call(print, "id")]);
+        case "Decorator":
+            return concat(["@", path.call(print, "expression")]);
+        case "TupleExpression":
+            parts.push("#");
+        // Intentionally fall through to printing the tuple elements...
+        case "ArrayExpression":
+        case "ArrayPattern": {
+            const elems = n.elements;
+            const len = elems.length;
+            const printed = path.map(print, "elements");
+            const joined = fromString(", ").join(printed);
+            const oneLine = joined.getLineLength(1) <= options.wrapColumn;
+            if (oneLine) {
+                if (options.arrayBracketSpacing) {
+                    parts.push("[ ");
+                }
+                else {
+                    parts.push("[");
+                }
+            }
+            else {
+                parts.push("[\n");
+            }
+            path.each(function (elemPath) {
+                const i = elemPath.getName();
+                const elem = elemPath.getValue();
+                if (!elem) {
+                    // If the array expression ends with a hole, that hole
+                    // will be ignored by the interpreter, but if it ends with
+                    // two (or more) holes, we need to write out two (or more)
+                    // commas so that the resulting code is interpreted with
+                    // both (all) of the holes.
+                    parts.push(",");
+                }
+                else {
+                    let lines = printed[i];
+                    if (oneLine) {
+                        if (i > 0)
+                            parts.push(" ");
+                    }
+                    else {
+                        lines = lines.indent(options.tabWidth);
+                    }
+                    parts.push(lines);
+                    if (i < len - 1 ||
+                        (!oneLine && util.isTrailingCommaEnabled(options, "arrays")))
+                        parts.push(",");
+                    if (!oneLine)
+                        parts.push("\n");
+                }
+            }, "elements");
+            if (oneLine && options.arrayBracketSpacing) {
+                parts.push(" ]");
+            }
+            else {
+                parts.push("]");
+            }
+            if (n.typeAnnotation) {
+                parts.push(path.call(print, "typeAnnotation"));
+            }
+            return concat(parts);
+        }
+        case "SequenceExpression":
+            return fromString(", ").join(path.map(print, "expressions"));
+        case "ThisExpression":
+            return fromString("this");
+        case "Super":
+            return fromString("super");
+        case "NullLiteral": // Babel 6 Literal split
+            return fromString("null");
+        case "RegExpLiteral": // Babel 6 Literal split
+            return fromString(getPossibleRaw(n) || `/${n.pattern}/${n.flags || ""}`, options);
+        case "BigIntLiteral": // Babel 7 Literal split
+            return fromString(getPossibleRaw(n) || n.value + "n", options);
+        case "NumericLiteral": // Babel 6 Literal Split
+            return fromString(getPossibleRaw(n) || n.value, options);
+        case "DecimalLiteral":
+            return fromString(getPossibleRaw(n) || n.value + "m", options);
+        case "StringLiteral":
+            return fromString(nodeStr(n.value, options));
+        case "BooleanLiteral": // Babel 6 Literal split
+        case "Literal":
+            return fromString(getPossibleRaw(n) ||
+                (typeof n.value === "string" ? nodeStr(n.value, options) : n.value), options);
+        case "Directive": // Babel 6
+            return path.call(print, "value");
+        case "DirectiveLiteral": // Babel 6
+            return fromString(getPossibleRaw(n) || nodeStr(n.value, options), options);
+        case "InterpreterDirective":
+            return fromString(`#!${n.value}\n`, options);
+        case "ModuleSpecifier":
+            if (n.local) {
+                throw new Error("The ESTree ModuleSpecifier type should be abstract");
+            }
+            // The Esprima ModuleSpecifier type is just a string-valued
+            // Literal identifying the imported-from module.
+            return fromString(nodeStr(n.value, options), options);
+        case "UnaryExpression":
+            parts.push(n.operator);
+            if (/[a-z]$/.test(n.operator))
+                parts.push(" ");
+            parts.push(path.call(print, "argument"));
+            return concat(parts);
+        case "UpdateExpression":
+            parts.push(path.call(print, "argument"), n.operator);
+            if (n.prefix)
+                parts.reverse();
+            return concat(parts);
+        case "ConditionalExpression":
+            return concat([
+                path.call(print, "test"),
+                " ? ",
+                path.call(print, "consequent"),
+                " : ",
+                path.call(print, "alternate"),
+            ]);
+        case "NewExpression": {
+            parts.push("new ", path.call(print, "callee"));
+            if (n.typeParameters) {
+                parts.push(path.call(print, "typeParameters"));
+            }
+            if (n.typeArguments) {
+                parts.push(path.call(print, "typeArguments"));
+            }
+            const args = n.arguments;
+            if (args) {
+                parts.push(printArgumentsList(path, options, print));
+            }
+            return concat(parts);
+        }
+        case "VariableDeclaration": {
+            if (n.declare) {
+                parts.push("declare ");
+            }
+            parts.push(n.kind, " ");
+            let maxLen = 0;
+            const printed = path.map(function (childPath) {
+                const lines = print(childPath);
+                maxLen = Math.max(lines.length, maxLen);
+                return lines;
+            }, "declarations");
+            if (maxLen === 1) {
+                parts.push(fromString(", ").join(printed));
+            }
+            else if (printed.length > 1) {
+                parts.push(fromString(",\n")
+                    .join(printed)
+                    .indentTail(n.kind.length + 1));
+            }
+            else {
+                parts.push(printed[0]);
+            }
+            // We generally want to terminate all variable declarations with a
+            // semicolon, except when they are children of for loops.
+            const parentNode = path.getParentNode();
+            if (!namedTypes.ForStatement.check(parentNode) &&
+                !namedTypes.ForInStatement.check(parentNode) &&
+                !(namedTypes.ForOfStatement &&
+                    namedTypes.ForOfStatement.check(parentNode)) &&
+                !(namedTypes.ForAwaitStatement &&
+                    namedTypes.ForAwaitStatement.check(parentNode))) {
+                parts.push(";");
+            }
+            return concat(parts);
+        }
+        case "VariableDeclarator":
+            return n.init
+                ? fromString(" = ").join([
+                    path.call(print, "id"),
+                    path.call(print, "init"),
+                ])
+                : path.call(print, "id");
+        case "WithStatement":
+            return concat([
+                "with (",
+                path.call(print, "object"),
+                ") ",
+                path.call(print, "body"),
+            ]);
+        case "IfStatement": {
+            const con = adjustClause(path.call(print, "consequent"), options);
+            parts.push("if (", path.call(print, "test"), ")", con);
+            if (n.alternate)
+                parts.push(endsWithBrace(con) ? " else" : "\nelse", adjustClause(path.call(print, "alternate"), options));
+            return concat(parts);
+        }
+        case "ForStatement": {
+            // TODO Get the for (;;) case right.
+            const init = path.call(print, "init");
+            const sep = init.length > 1 ? ";\n" : "; ";
+            const forParen = "for (";
+            const indented = fromString(sep)
+                .join([init, path.call(print, "test"), path.call(print, "update")])
+                .indentTail(forParen.length);
+            const head = concat([forParen, indented, ")"]);
+            let clause = adjustClause(path.call(print, "body"), options);
+            parts.push(head);
+            if (head.length > 1) {
+                parts.push("\n");
+                clause = clause.trimLeft();
+            }
+            parts.push(clause);
+            return concat(parts);
+        }
+        case "WhileStatement":
+            return concat([
+                "while (",
+                path.call(print, "test"),
+                ")",
+                adjustClause(path.call(print, "body"), options),
+            ]);
+        case "ForInStatement":
+            // Note: esprima can't actually parse "for each (".
+            return concat([
+                n.each ? "for each (" : "for (",
+                path.call(print, "left"),
+                " in ",
+                path.call(print, "right"),
+                ")",
+                adjustClause(path.call(print, "body"), options),
+            ]);
+        case "ForOfStatement":
+        case "ForAwaitStatement":
+            parts.push("for ");
+            if (n.await || n.type === "ForAwaitStatement") {
+                parts.push("await ");
+            }
+            parts.push("(", path.call(print, "left"), " of ", path.call(print, "right"), ")", adjustClause(path.call(print, "body"), options));
+            return concat(parts);
+        case "DoWhileStatement": {
+            const doBody = concat([
+                "do",
+                adjustClause(path.call(print, "body"), options),
+            ]);
+            parts.push(doBody);
+            if (endsWithBrace(doBody))
+                parts.push(" while");
+            else
+                parts.push("\nwhile");
+            parts.push(" (", path.call(print, "test"), ");");
+            return concat(parts);
+        }
+        case "DoExpression": {
+            const statements = path.call((bodyPath) => printStatementSequence(bodyPath, options, print), "body");
+            return concat(["do {\n", statements.indent(options.tabWidth), "\n}"]);
+        }
+        case "BreakStatement":
+            parts.push("break");
+            if (n.label)
+                parts.push(" ", path.call(print, "label"));
+            parts.push(";");
+            return concat(parts);
+        case "ContinueStatement":
+            parts.push("continue");
+            if (n.label)
+                parts.push(" ", path.call(print, "label"));
+            parts.push(";");
+            return concat(parts);
+        case "LabeledStatement":
+            return concat([
+                path.call(print, "label"),
+                ":\n",
+                path.call(print, "body"),
+            ]);
+        case "TryStatement":
+            parts.push("try ", path.call(print, "block"));
+            if (n.handler) {
+                parts.push(" ", path.call(print, "handler"));
+            }
+            else if (n.handlers) {
+                path.each(function (handlerPath) {
+                    parts.push(" ", print(handlerPath));
+                }, "handlers");
+            }
+            if (n.finalizer) {
+                parts.push(" finally ", path.call(print, "finalizer"));
+            }
+            return concat(parts);
+        case "CatchClause":
+            parts.push("catch ");
+            if (n.param) {
+                parts.push("(", path.call(print, "param"));
+            }
+            if (n.guard) {
+                // Note: esprima does not recognize conditional catch clauses.
+                parts.push(" if ", path.call(print, "guard"));
+            }
+            if (n.param) {
+                parts.push(") ");
+            }
+            parts.push(path.call(print, "body"));
+            return concat(parts);
+        case "ThrowStatement":
+            return concat(["throw ", path.call(print, "argument"), ";"]);
+        case "SwitchStatement":
+            return concat([
+                "switch (",
+                path.call(print, "discriminant"),
+                ") {\n",
+                fromString("\n").join(path.map(print, "cases")),
+                "\n}",
+            ]);
+        // Note: ignoring n.lexical because it has no printing consequences.
+        case "SwitchCase":
+            if (n.test)
+                parts.push("case ", path.call(print, "test"), ":");
+            else
+                parts.push("default:");
+            if (n.consequent.length > 0) {
+                parts.push("\n", path
+                    .call((consequentPath) => printStatementSequence(consequentPath, options, print), "consequent")
+                    .indent(options.tabWidth));
+            }
+            return concat(parts);
+        case "DebuggerStatement":
+            return fromString("debugger;");
+        // JSX extensions below.
+        case "JSXAttribute":
+            parts.push(path.call(print, "name"));
+            if (n.value)
+                parts.push("=", path.call(print, "value"));
+            return concat(parts);
+        case "JSXIdentifier":
+            return fromString(n.name, options);
+        case "JSXNamespacedName":
+            return fromString(":").join([
+                path.call(print, "namespace"),
+                path.call(print, "name"),
+            ]);
+        case "JSXMemberExpression":
+            return fromString(".").join([
+                path.call(print, "object"),
+                path.call(print, "property"),
+            ]);
+        case "JSXSpreadAttribute":
+            return concat(["{...", path.call(print, "argument"), "}"]);
+        case "JSXSpreadChild":
+            return concat(["{...", path.call(print, "expression"), "}"]);
+        case "JSXExpressionContainer":
+            return concat(["{", path.call(print, "expression"), "}"]);
+        case "JSXElement":
+        case "JSXFragment": {
+            const openingPropName = "opening" + (n.type === "JSXElement" ? "Element" : "Fragment");
+            const closingPropName = "closing" + (n.type === "JSXElement" ? "Element" : "Fragment");
+            const openingLines = path.call(print, openingPropName);
+            if (n[openingPropName].selfClosing) {
+                assert.ok(!n[closingPropName], "unexpected " +
+                    closingPropName +
+                    " element in self-closing " +
+                    n.type);
+                return openingLines;
+            }
+            const childLines = concat(path.map(function (childPath) {
+                const child = childPath.getValue();
+                if (namedTypes.Literal.check(child) &&
+                    typeof child.value === "string") {
+                    if (/\S/.test(child.value)) {
+                        return child.value.replace(/^\s+|\s+$/g, "");
+                    }
+                    else if (/\n/.test(child.value)) {
+                        return "\n";
+                    }
+                }
+                return print(childPath);
+            }, "children")).indentTail(options.tabWidth);
+            const closingLines = path.call(print, closingPropName);
+            return concat([openingLines, childLines, closingLines]);
+        }
+        case "JSXOpeningElement": {
+            parts.push("<", path.call(print, "name"));
+            const attrParts = [];
+            path.each(function (attrPath) {
+                attrParts.push(" ", print(attrPath));
+            }, "attributes");
+            let attrLines = concat(attrParts);
+            const needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn;
+            if (needLineWrap) {
+                attrParts.forEach(function (part, i) {
+                    if (part === " ") {
+                        assert.strictEqual(i % 2, 0);
+                        attrParts[i] = "\n";
+                    }
+                });
+                attrLines = concat(attrParts).indentTail(options.tabWidth);
+            }
+            parts.push(attrLines, n.selfClosing ? " />" : ">");
+            return concat(parts);
+        }
+        case "JSXClosingElement":
+            return concat(["</", path.call(print, "name"), ">"]);
+        case "JSXOpeningFragment":
+            return fromString("<>");
+        case "JSXClosingFragment":
+            return fromString("</>");
+        case "JSXText":
+            return fromString(n.value, options);
+        case "JSXEmptyExpression":
+            return fromString("");
+        case "TypeAnnotatedIdentifier":
+            return concat([
+                path.call(print, "annotation"),
+                " ",
+                path.call(print, "identifier"),
+            ]);
+        case "ClassBody":
+            if (n.body.length === 0) {
+                return fromString("{}");
+            }
+            return concat([
+                "{\n",
+                path
+                    .call((bodyPath) => printStatementSequence(bodyPath, options, print), "body")
+                    .indent(options.tabWidth),
+                "\n}",
+            ]);
+        case "ClassPropertyDefinition":
+            parts.push("static ", path.call(print, "definition"));
+            if (!namedTypes.MethodDefinition.check(n.definition))
+                parts.push(";");
+            return concat(parts);
+        case "ClassProperty": {
+            if (n.declare) {
+                parts.push("declare ");
+            }
+            const access = n.accessibility || n.access;
+            if (typeof access === "string") {
+                parts.push(access, " ");
+            }
+            if (n.static) {
+                parts.push("static ");
+            }
+            if (n.abstract) {
+                parts.push("abstract ");
+            }
+            if (n.readonly) {
+                parts.push("readonly ");
+            }
+            let key = path.call(print, "key");
+            if (n.computed) {
+                key = concat(["[", key, "]"]);
+            }
+            if (n.variance) {
+                key = concat([printVariance(path, print), key]);
+            }
+            parts.push(key);
+            if (n.optional) {
+                parts.push("?");
+            }
+            if (n.definite) {
+                parts.push("!");
+            }
+            if (n.typeAnnotation) {
+                parts.push(path.call(print, "typeAnnotation"));
+            }
+            if (n.value) {
+                parts.push(" = ", path.call(print, "value"));
+            }
+            parts.push(";");
+            return concat(parts);
+        }
+        case "ClassPrivateProperty":
+            if (n.static) {
+                parts.push("static ");
+            }
+            parts.push(path.call(print, "key"));
+            if (n.typeAnnotation) {
+                parts.push(path.call(print, "typeAnnotation"));
+            }
+            if (n.value) {
+                parts.push(" = ", path.call(print, "value"));
+            }
+            parts.push(";");
+            return concat(parts);
+        case "ClassAccessorProperty": {
+            parts.push(...printClassMemberModifiers(n), "accessor ");
+            if (n.computed) {
+                parts.push("[", path.call(print, "key"), "]");
+            }
+            else {
+                parts.push(path.call(print, "key"));
+            }
+            if (n.optional) {
+                parts.push("?");
+            }
+            if (n.definite) {
+                parts.push("!");
+            }
+            if (n.typeAnnotation) {
+                parts.push(path.call(print, "typeAnnotation"));
+            }
+            if (n.value) {
+                parts.push(" = ", path.call(print, "value"));
+            }
+            parts.push(";");
+            return concat(parts);
+        }
+        case "ClassDeclaration":
+        case "ClassExpression":
+        case "DeclareClass":
+            if (n.declare) {
+                parts.push("declare ");
+            }
+            if (n.abstract) {
+                parts.push("abstract ");
+            }
+            parts.push("class");
+            if (n.id) {
+                parts.push(" ", path.call(print, "id"));
+            }
+            if (n.typeParameters) {
+                parts.push(path.call(print, "typeParameters"));
+            }
+            if (n.superClass) {
+                // ClassDeclaration and ClassExpression only
+                parts.push(" extends ", path.call(print, "superClass"), path.call(print, "superTypeParameters"));
+            }
+            if (n.extends && n.extends.length > 0) {
+                // DeclareClass only
+                parts.push(" extends ", fromString(", ").join(path.map(print, "extends")));
+            }
+            if (n["implements"] && n["implements"].length > 0) {
+                parts.push(" implements ", fromString(", ").join(path.map(print, "implements")));
+            }
+            parts.push(" ", path.call(print, "body"));
+            if (n.type === "DeclareClass") {
+                return printFlowDeclaration(path, parts);
+            }
+            else {
+                return concat(parts);
+            }
+        case "TemplateElement":
+            return fromString(n.value.raw, options).lockIndentTail();
+        case "TemplateLiteral": {
+            const expressions = path.map(print, "expressions");
+            parts.push("`");
+            path.each(function (childPath) {
+                const i = childPath.getName();
+                parts.push(print(childPath));
+                if (i < expressions.length) {
+                    parts.push("${", expressions[i], "}");
+                }
+            }, "quasis");
+            parts.push("`");
+            return concat(parts).lockIndentTail();
+        }
+        case "TaggedTemplateExpression":
+            return concat([path.call(print, "tag"), path.call(print, "quasi")]);
+        // These types are unprintable because they serve as abstract
+        // supertypes for other (printable) types.
+        case "Node":
+        case "Printable":
+        case "SourceLocation":
+        case "Position":
+        case "Statement":
+        case "Function":
+        case "Pattern":
+        case "Expression":
+        case "Declaration":
+        case "Specifier":
+        case "NamedSpecifier":
+        case "Comment": // Supertype of Block and Line
+        case "Flow": // Supertype of all Flow AST node types
+        case "FlowType": // Supertype of all Flow types
+        case "FlowPredicate": // Supertype of InferredPredicate and DeclaredPredicate
+        case "MemberTypeAnnotation": // Flow
+        case "Type": // Flow
+        case "TSHasOptionalTypeParameterInstantiation":
+        case "TSHasOptionalTypeParameters":
+        case "TSHasOptionalTypeAnnotation":
+        case "ChainElement": // Supertype of MemberExpression and CallExpression
+            throw new Error("unprintable type: " + JSON.stringify(n.type));
+        case "CommentBlock": // Babel block comment.
+        case "Block": // Esprima block comment.
+            return concat(["/*", fromString(n.value, options), "*/"]);
+        case "CommentLine": // Babel line comment.
+        case "Line": // Esprima line comment.
+            return concat(["//", fromString(n.value, options)]);
+        // Type Annotations for Facebook Flow, typically stripped out or
+        // transformed away before printing.
+        case "TypeAnnotation":
+            if (n.typeAnnotation) {
+                if (n.typeAnnotation.type !== "FunctionTypeAnnotation") {
+                    parts.push(": ");
+                }
+                parts.push(path.call(print, "typeAnnotation"));
+                return concat(parts);
+            }
+            return fromString("");
+        case "ExistentialTypeParam":
+        case "ExistsTypeAnnotation":
+            return fromString("*", options);
+        case "EmptyTypeAnnotation":
+            return fromString("empty", options);
+        case "AnyTypeAnnotation":
+            return fromString("any", options);
+        case "MixedTypeAnnotation":
+            return fromString("mixed", options);
+        case "ArrayTypeAnnotation":
+            return concat([path.call(print, "elementType"), "[]"]);
+        case "TupleTypeAnnotation": {
+            const printed = path.map(print, "types");
+            const joined = fromString(", ").join(printed);
+            const oneLine = joined.getLineLength(1) <= options.wrapColumn;
+            if (oneLine) {
+                if (options.arrayBracketSpacing) {
+                    parts.push("[ ");
+                }
+                else {
+                    parts.push("[");
+                }
+            }
+            else {
+                parts.push("[\n");
+            }
+            path.each(function (elemPath) {
+                const i = elemPath.getName();
+                const elem = elemPath.getValue();
+                if (!elem) {
+                    // If the array expression ends with a hole, that hole
+                    // will be ignored by the interpreter, but if it ends with
+                    // two (or more) holes, we need to write out two (or more)
+                    // commas so that the resulting code is interpreted with
+                    // both (all) of the holes.
+                    parts.push(",");
+                }
+                else {
+                    let lines = printed[i];
+                    if (oneLine) {
+                        if (i > 0)
+                            parts.push(" ");
+                    }
+                    else {
+                        lines = lines.indent(options.tabWidth);
+                    }
+                    parts.push(lines);
+                    if (i < n.types.length - 1 ||
+                        (!oneLine && util.isTrailingCommaEnabled(options, "arrays")))
+                        parts.push(",");
+                    if (!oneLine)
+                        parts.push("\n");
+                }
+            }, "types");
+            if (oneLine && options.arrayBracketSpacing) {
+                parts.push(" ]");
+            }
+            else {
+                parts.push("]");
+            }
+            return concat(parts);
+        }
+        case "BooleanTypeAnnotation":
+            return fromString("boolean", options);
+        case "BooleanLiteralTypeAnnotation":
+            assert.strictEqual(typeof n.value, "boolean");
+            return fromString("" + n.value, options);
+        case "InterfaceTypeAnnotation":
+            parts.push("interface");
+            if (n.extends && n.extends.length > 0) {
+                parts.push(" extends ", fromString(", ").join(path.map(print, "extends")));
+            }
+            parts.push(" ", path.call(print, "body"));
+            return concat(parts);
+        case "DeclareFunction":
+            return printFlowDeclaration(path, [
+                "function ",
+                path.call(print, "id"),
+                ";",
+            ]);
+        case "DeclareModule":
+            return printFlowDeclaration(path, [
+                "module ",
+                path.call(print, "id"),
+                " ",
+                path.call(print, "body"),
+            ]);
+        case "DeclareModuleExports":
+            return printFlowDeclaration(path, [
+                "module.exports",
+                path.call(print, "typeAnnotation"),
+            ]);
+        case "DeclareVariable":
+            return printFlowDeclaration(path, ["var ", path.call(print, "id"), ";"]);
+        case "DeclareExportDeclaration":
+        case "DeclareExportAllDeclaration":
+            return concat(["declare ", printExportDeclaration(path, options, print)]);
+        case "EnumDeclaration":
+            return concat([
+                "enum ",
+                path.call(print, "id"),
+                path.call(print, "body"),
+            ]);
+        case "EnumBooleanBody":
+        case "EnumNumberBody":
+        case "EnumStringBody":
+        case "EnumSymbolBody": {
+            if (n.type === "EnumSymbolBody" || n.explicitType) {
+                parts.push(" of ", 
+                // EnumBooleanBody => boolean, etc.
+                n.type.slice(4, -4).toLowerCase());
+            }
+            parts.push(" {\n", fromString("\n")
+                .join(path.map(print, "members"))
+                .indent(options.tabWidth), "\n}");
+            return concat(parts);
+        }
+        case "EnumDefaultedMember":
+            return concat([path.call(print, "id"), ","]);
+        case "EnumBooleanMember":
+        case "EnumNumberMember":
+        case "EnumStringMember":
+            return concat([
+                path.call(print, "id"),
+                " = ",
+                path.call(print, "init"),
+                ",",
+            ]);
+        case "InferredPredicate":
+            return fromString("%checks", options);
+        case "DeclaredPredicate":
+            return concat(["%checks(", path.call(print, "value"), ")"]);
+        case "FunctionTypeAnnotation": {
+            // FunctionTypeAnnotation is ambiguous:
+            // declare function(a: B): void; OR
+            // const A: (a: B) => void;
+            const parent = path.getParentNode(0);
+            const isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent) ||
+                (namedTypes.ObjectTypeInternalSlot.check(parent) && parent.method) ||
+                namedTypes.DeclareFunction.check(path.getParentNode(2)));
+            const needsColon = isArrowFunctionTypeAnnotation &&
+                !namedTypes.FunctionTypeParam.check(parent) &&
+                !namedTypes.TypeAlias.check(parent);
+            if (needsColon) {
+                parts.push(": ");
+            }
+            const hasTypeParameters = !!n.typeParameters;
+            const needsParens = hasTypeParameters || n.params.length !== 1 || n.params[0].name;
+            parts.push(hasTypeParameters ? path.call(print, "typeParameters") : "", needsParens ? "(" : "", printFunctionParams(path, options, print), needsParens ? ")" : "");
+            // The returnType is not wrapped in a TypeAnnotation, so the colon
+            // needs to be added separately.
+            if (n.returnType) {
+                parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path.call(print, "returnType"));
+            }
+            return concat(parts);
+        }
+        case "FunctionTypeParam": {
+            const name = path.call(print, "name");
+            parts.push(name);
+            if (n.optional) {
+                parts.push("?");
+            }
+            if (name.infos[0].line) {
+                parts.push(": ");
+            }
+            parts.push(path.call(print, "typeAnnotation"));
+            return concat(parts);
+        }
+        case "GenericTypeAnnotation":
+            return concat([
+                path.call(print, "id"),
+                path.call(print, "typeParameters"),
+            ]);
+        case "DeclareInterface":
+            parts.push("declare ");
+        // Fall through to InterfaceDeclaration...
+        case "InterfaceDeclaration":
+        case "TSInterfaceDeclaration":
+            if (n.declare) {
+                parts.push("declare ");
+            }
+            parts.push("interface ", path.call(print, "id"), path.call(print, "typeParameters"), " ");
+            if (n["extends"] && n["extends"].length > 0) {
+                parts.push("extends ", fromString(", ").join(path.map(print, "extends")), " ");
+            }
+            if (n.body) {
+                parts.push(path.call(print, "body"));
+            }
+            return concat(parts);
+        case "ClassImplements":
+        case "InterfaceExtends":
+            return concat([
+                path.call(print, "id"),
+                path.call(print, "typeParameters"),
+            ]);
+        case "IntersectionTypeAnnotation":
+            return fromString(" & ").join(path.map(print, "types"));
+        case "NullableTypeAnnotation":
+            return concat(["?", path.call(print, "typeAnnotation")]);
+        case "NullLiteralTypeAnnotation":
+            return fromString("null", options);
+        case "ThisTypeAnnotation":
+            return fromString("this", options);
+        case "NumberTypeAnnotation":
+            return fromString("number", options);
+        case "ObjectTypeCallProperty":
+            return path.call(print, "value");
+        case "ObjectTypeIndexer":
+            if (n.static) {
+                parts.push("static ");
+            }
+            parts.push(printVariance(path, print), "[");
+            if (n.id) {
+                parts.push(path.call(print, "id"), ": ");
+            }
+            parts.push(path.call(print, "key"), "]: ", path.call(print, "value"));
+            return concat(parts);
+        case "ObjectTypeProperty":
+            return concat([
+                printVariance(path, print),
+                path.call(print, "key"),
+                n.optional ? "?" : "",
+                ": ",
+                path.call(print, "value"),
+            ]);
+        case "ObjectTypeInternalSlot":
+            return concat([
+                n.static ? "static " : "",
+                "[[",
+                path.call(print, "id"),
+                "]]",
+                n.optional ? "?" : "",
+                n.value.type !== "FunctionTypeAnnotation" ? ": " : "",
+                path.call(print, "value"),
+            ]);
+        case "QualifiedTypeIdentifier":
+            return concat([
+                path.call(print, "qualification"),
+                ".",
+                path.call(print, "id"),
+            ]);
+        case "StringLiteralTypeAnnotation":
+            return fromString(nodeStr(n.value, options), options);
+        case "NumberLiteralTypeAnnotation":
+        case "NumericLiteralTypeAnnotation":
+            assert.strictEqual(typeof n.value, "number");
+            return fromString(JSON.stringify(n.value), options);
+        case "BigIntLiteralTypeAnnotation":
+            return fromString(n.raw, options);
+        case "StringTypeAnnotation":
+            return fromString("string", options);
+        case "DeclareTypeAlias":
+            parts.push("declare ");
+        // Fall through to TypeAlias...
+        case "TypeAlias":
+            return concat([
+                "type ",
+                path.call(print, "id"),
+                path.call(print, "typeParameters"),
+                " = ",
+                path.call(print, "right"),
+                ";",
+            ]);
+        case "DeclareOpaqueType":
+            parts.push("declare ");
+        // Fall through to OpaqueType...
+        case "OpaqueType":
+            parts.push("opaque type ", path.call(print, "id"), path.call(print, "typeParameters"));
+            if (n["supertype"]) {
+                parts.push(": ", path.call(print, "supertype"));
+            }
+            if (n["impltype"]) {
+                parts.push(" = ", path.call(print, "impltype"));
+            }
+            parts.push(";");
+            return concat(parts);
+        case "TypeCastExpression":
+            return concat([
+                "(",
+                path.call(print, "expression"),
+                path.call(print, "typeAnnotation"),
+                ")",
+            ]);
+        case "TypeParameterDeclaration":
+        case "TypeParameterInstantiation":
+            return concat([
+                "<",
+                fromString(", ").join(path.map(print, "params")),
+                ">",
+            ]);
+        case "Variance":
+            if (n.kind === "plus") {
+                return fromString("+");
+            }
+            if (n.kind === "minus") {
+                return fromString("-");
+            }
+            return fromString("");
+        case "TypeParameter":
+            if (n.variance) {
+                parts.push(printVariance(path, print));
+            }
+            parts.push(path.call(print, "name"));
+            if (n.bound) {
+                parts.push(path.call(print, "bound"));
+            }
+            if (n["default"]) {
+                parts.push("=", path.call(print, "default"));
+            }
+            return concat(parts);
+        case "TypeofTypeAnnotation":
+            return concat([
+                fromString("typeof ", options),
+                path.call(print, "argument"),
+            ]);
+        case "IndexedAccessType":
+        case "OptionalIndexedAccessType":
+            return concat([
+                path.call(print, "objectType"),
+                n.optional ? "?." : "",
+                "[",
+                path.call(print, "indexType"),
+                "]",
+            ]);
+        case "UnionTypeAnnotation":
+            return fromString(" | ").join(path.map(print, "types"));
+        case "VoidTypeAnnotation":
+            return fromString("void", options);
+        case "NullTypeAnnotation":
+            return fromString("null", options);
+        case "SymbolTypeAnnotation":
+            return fromString("symbol", options);
+        case "BigIntTypeAnnotation":
+            return fromString("bigint", options);
+        // Type Annotations for TypeScript (when using Babylon as parser)
+        case "TSType":
+            throw new Error("unprintable type: " + JSON.stringify(n.type));
+        case "TSNumberKeyword":
+            return fromString("number", options);
+        case "TSBigIntKeyword":
+            return fromString("bigint", options);
+        case "TSObjectKeyword":
+            return fromString("object", options);
+        case "TSBooleanKeyword":
+            return fromString("boolean", options);
+        case "TSStringKeyword":
+            return fromString("string", options);
+        case "TSSymbolKeyword":
+            return fromString("symbol", options);
+        case "TSAnyKeyword":
+            return fromString("any", options);
+        case "TSVoidKeyword":
+            return fromString("void", options);
+        case "TSIntrinsicKeyword":
+            return fromString("intrinsic", options);
+        case "TSThisType":
+            return fromString("this", options);
+        case "TSNullKeyword":
+            return fromString("null", options);
+        case "TSUndefinedKeyword":
+            return fromString("undefined", options);
+        case "TSUnknownKeyword":
+            return fromString("unknown", options);
+        case "TSNeverKeyword":
+            return fromString("never", options);
+        case "TSArrayType":
+            return concat([path.call(print, "elementType"), "[]"]);
+        case "TSLiteralType":
+            return path.call(print, "literal");
+        case "TSUnionType":
+            return fromString(" | ").join(path.map(print, "types"));
+        case "TSIntersectionType":
+            return fromString(" & ").join(path.map(print, "types"));
+        case "TSConditionalType":
+            parts.push(path.call(print, "checkType"), " extends ", path.call(print, "extendsType"), " ? ", path.call(print, "trueType"), " : ", path.call(print, "falseType"));
+            return concat(parts);
+        case "TSInferType":
+            parts.push("infer ", path.call(print, "typeParameter"));
+            return concat(parts);
+        case "TSParenthesizedType":
+            return concat(["(", path.call(print, "typeAnnotation"), ")"]);
+        case "TSFunctionType":
+            return concat([
+                path.call(print, "typeParameters"),
+                "(",
+                printFunctionParams(path, options, print),
+                ") => ",
+                path.call(print, "typeAnnotation", "typeAnnotation"),
+            ]);
+        case "TSConstructorType":
+            return concat([
+                "new ",
+                path.call(print, "typeParameters"),
+                "(",
+                printFunctionParams(path, options, print),
+                ") => ",
+                path.call(print, "typeAnnotation", "typeAnnotation"),
+            ]);
+        case "TSMappedType": {
+            parts.push(n.readonly ? "readonly " : "", "[", path.call(print, "typeParameter"), "]", n.optional ? "?" : "");
+            if (n.typeAnnotation) {
+                parts.push(": ", path.call(print, "typeAnnotation"), ";");
+            }
+            return concat(["{\n", concat(parts).indent(options.tabWidth), "\n}"]);
+        }
+        case "TSTupleType":
+            return concat([
+                "[",
+                fromString(", ").join(path.map(print, "elementTypes")),
+                "]",
+            ]);
+        case "TSNamedTupleMember":
+            parts.push(path.call(print, "label"));
+            if (n.optional) {
+                parts.push("?");
+            }
+            parts.push(": ", path.call(print, "elementType"));
+            return concat(parts);
+        case "TSRestType":
+            return concat(["...", path.call(print, "typeAnnotation")]);
+        case "TSOptionalType":
+            return concat([path.call(print, "typeAnnotation"), "?"]);
+        case "TSIndexedAccessType":
+            return concat([
+                path.call(print, "objectType"),
+                "[",
+                path.call(print, "indexType"),
+                "]",
+            ]);
+        case "TSTypeOperator":
+            return concat([
+                path.call(print, "operator"),
+                " ",
+                path.call(print, "typeAnnotation"),
+            ]);
+        case "TSTypeLiteral": {
+            const members = fromString("\n").join(path.map(print, "members").map((member) => {
+                if (lastNonSpaceCharacter(member) !== ";") {
+                    return member.concat(";");
+                }
+                return member;
+            }));
+            if (members.isEmpty()) {
+                return fromString("{}", options);
+            }
+            parts.push("{\n", members.indent(options.tabWidth), "\n}");
+            return concat(parts);
+        }
+        case "TSEnumMember":
+            parts.push(path.call(print, "id"));
+            if (n.initializer) {
+                parts.push(" = ", path.call(print, "initializer"));
+            }
+            return concat(parts);
+        case "TSTypeQuery":
+            return concat(["typeof ", path.call(print, "exprName")]);
+        case "TSParameterProperty":
+            if (n.accessibility) {
+                parts.push(n.accessibility, " ");
+            }
+            if (n.export) {
+                parts.push("export ");
+            }
+            if (n.static) {
+                parts.push("static ");
+            }
+            if (n.readonly) {
+                parts.push("readonly ");
+            }
+            parts.push(path.call(print, "parameter"));
+            return concat(parts);
+        case "TSTypeReference":
+            return concat([
+                path.call(print, "typeName"),
+                path.call(print, "typeParameters"),
+            ]);
+        case "TSQualifiedName":
+            return concat([path.call(print, "left"), ".", path.call(print, "right")]);
+        case "TSAsExpression":
+        case "TSSatisfiesExpression":
+            {
+                const expression = path.call(print, "expression");
+                parts.push(expression, n.type === "TSSatisfiesExpression" ? " satisfies " : " as ", path.call(print, "typeAnnotation"));
+                return concat(parts);
+            }
+        case "TSTypeCastExpression":
+            return concat([
+                path.call(print, "expression"),
+                path.call(print, "typeAnnotation"),
+            ]);
+        case "TSNonNullExpression":
+            return concat([path.call(print, "expression"), "!"]);
+        case "TSTypeAnnotation":
+            return concat([": ", path.call(print, "typeAnnotation")]);
+        case "TSIndexSignature":
+            return concat([
+                n.readonly ? "readonly " : "",
+                "[",
+                path.map(print, "parameters"),
+                "]",
+                path.call(print, "typeAnnotation"),
+            ]);
+        case "TSPropertySignature":
+            parts.push(printVariance(path, print), n.readonly ? "readonly " : "");
+            if (n.computed) {
+                parts.push("[", path.call(print, "key"), "]");
+            }
+            else {
+                parts.push(path.call(print, "key"));
+            }
+            parts.push(n.optional ? "?" : "", path.call(print, "typeAnnotation"));
+            return concat(parts);
+        case "TSMethodSignature":
+            if (n.computed) {
+                parts.push("[", path.call(print, "key"), "]");
+            }
+            else {
+                parts.push(path.call(print, "key"));
+            }
+            if (n.optional) {
+                parts.push("?");
+            }
+            parts.push(path.call(print, "typeParameters"), "(", printFunctionParams(path, options, print), ")", path.call(print, "typeAnnotation"));
+            return concat(parts);
+        case "TSTypePredicate":
+            if (n.asserts) {
+                parts.push("asserts ");
+            }
+            parts.push(path.call(print, "parameterName"));
+            if (n.typeAnnotation) {
+                parts.push(" is ", path.call(print, "typeAnnotation", "typeAnnotation"));
+            }
+            return concat(parts);
+        case "TSCallSignatureDeclaration":
+            return concat([
+                path.call(print, "typeParameters"),
+                "(",
+                printFunctionParams(path, options, print),
+                ")",
+                path.call(print, "typeAnnotation"),
+            ]);
+        case "TSConstructSignatureDeclaration":
+            if (n.typeParameters) {
+                parts.push("new", path.call(print, "typeParameters"));
+            }
+            else {
+                parts.push("new ");
+            }
+            parts.push("(", printFunctionParams(path, options, print), ")", path.call(print, "typeAnnotation"));
+            return concat(parts);
+        case "TSTypeAliasDeclaration":
+            return concat([
+                n.declare ? "declare " : "",
+                "type ",
+                path.call(print, "id"),
+                path.call(print, "typeParameters"),
+                " = ",
+                path.call(print, "typeAnnotation"),
+                ";",
+            ]);
+        case "TSTypeParameter": {
+            parts.push(path.call(print, "name"));
+            // ambiguous because of TSMappedType
+            const parent = path.getParentNode(0);
+            const isInMappedType = namedTypes.TSMappedType.check(parent);
+            if (n.constraint) {
+                parts.push(isInMappedType ? " in " : " extends ", path.call(print, "constraint"));
+            }
+            if (n["default"]) {
+                parts.push(" = ", path.call(print, "default"));
+            }
+            return concat(parts);
+        }
+        case "TSTypeAssertion": {
+            parts.push("<", path.call(print, "typeAnnotation"), "> ", path.call(print, "expression"));
+            return concat(parts);
+        }
+        case "TSTypeParameterDeclaration":
+        case "TSTypeParameterInstantiation":
+            return concat([
+                "<",
+                fromString(", ").join(path.map(print, "params")),
+                ">",
+            ]);
+        case "TSEnumDeclaration": {
+            parts.push(n.declare ? "declare " : "", n.const ? "const " : "", "enum ", path.call(print, "id"));
+            const memberLines = fromString(",\n").join(path.map(print, "members"));
+            if (memberLines.isEmpty()) {
+                parts.push(" {}");
+            }
+            else {
+                parts.push(" {\n", memberLines.indent(options.tabWidth), "\n}");
+            }
+            return concat(parts);
+        }
+        case "TSExpressionWithTypeArguments":
+            return concat([
+                path.call(print, "expression"),
+                path.call(print, "typeParameters"),
+            ]);
+        case "TSInterfaceBody": {
+            const lines = fromString("\n").join(path.map(print, "body").map((element) => {
+                if (lastNonSpaceCharacter(element) !== ";") {
+                    return element.concat(";");
+                }
+                return element;
+            }));
+            if (lines.isEmpty()) {
+                return fromString("{}", options);
+            }
+            return concat(["{\n", lines.indent(options.tabWidth), "\n}"]);
+        }
+        case "TSImportType":
+            parts.push("import(", path.call(print, "argument"), ")");
+            if (n.qualifier) {
+                parts.push(".", path.call(print, "qualifier"));
+            }
+            if (n.typeParameters) {
+                parts.push(path.call(print, "typeParameters"));
+            }
+            return concat(parts);
+        case "TSImportEqualsDeclaration":
+            if (n.isExport) {
+                parts.push("export ");
+            }
+            parts.push("import ", path.call(print, "id"), " = ", path.call(print, "moduleReference"));
+            return maybeAddSemicolon(concat(parts));
+        case "TSExternalModuleReference":
+            return concat(["require(", path.call(print, "expression"), ")"]);
+        case "TSModuleDeclaration": {
+            const parent = path.getParentNode();
+            if (parent.type === "TSModuleDeclaration") {
+                parts.push(".");
+            }
+            else {
+                if (n.declare) {
+                    parts.push("declare ");
+                }
+                if (!n.global) {
+                    const isExternal = n.id.type === "StringLiteral" ||
+                        (n.id.type === "Literal" && typeof n.id.value === "string");
+                    if (isExternal) {
+                        parts.push("module ");
+                    }
+                    else if (n.loc && n.loc.lines && n.id.loc) {
+                        const prefix = n.loc.lines.sliceString(n.loc.start, n.id.loc.start);
+                        // These keywords are fundamentally ambiguous in the
+                        // Babylon parser, and not reflected in the AST, so
+                        // the best we can do is to match the original code,
+                        // when possible.
+                        if (prefix.indexOf("module") >= 0) {
+                            parts.push("module ");
+                        }
+                        else {
+                            parts.push("namespace ");
+                        }
+                    }
+                    else {
+                        parts.push("namespace ");
+                    }
+                }
+            }
+            parts.push(path.call(print, "id"));
+            if (n.body) {
+                parts.push(" ");
+                parts.push(path.call(print, "body"));
+            }
+            return concat(parts);
+        }
+        case "TSModuleBlock": {
+            const naked = path.call((bodyPath) => printStatementSequence(bodyPath, options, print), "body");
+            if (naked.isEmpty()) {
+                parts.push("{}");
+            }
+            else {
+                parts.push("{\n", naked.indent(options.tabWidth), "\n}");
+            }
+            return concat(parts);
+        }
+        case "TSInstantiationExpression": {
+            parts.push(path.call(print, "expression"), path.call(print, "typeParameters"));
+            return concat(parts);
+        }
+        // https://github.com/babel/babel/pull/10148
+        case "V8IntrinsicIdentifier":
+            return concat(["%", path.call(print, "name")]);
+        // https://github.com/babel/babel/pull/13191
+        case "TopicReference":
+            return fromString("#");
+        // Unhandled types below. If encountered, nodes of these types should
+        // be either left alone or desugared into AST types that are fully
+        // supported by the pretty-printer.
+        case "ClassHeritage": // TODO
+        case "ComprehensionBlock": // TODO
+        case "ComprehensionExpression": // TODO
+        case "Glob": // TODO
+        case "GeneratorExpression": // TODO
+        case "LetStatement": // TODO
+        case "LetExpression": // TODO
+        case "GraphExpression": // TODO
+        case "GraphIndexExpression": // TODO
+        case "XMLDefaultDeclaration":
+        case "XMLAnyName":
+        case "XMLQualifiedIdentifier":
+        case "XMLFunctionQualifiedIdentifier":
+        case "XMLAttributeSelector":
+        case "XMLFilterExpression":
+        case "XML":
+        case "XMLElement":
+        case "XMLList":
+        case "XMLEscape":
+        case "XMLText":
+        case "XMLStartTag":
+        case "XMLEndTag":
+        case "XMLPointTag":
+        case "XMLName":
+        case "XMLAttribute":
+        case "XMLCdata":
+        case "XMLComment":
+        case "XMLProcessingInstruction":
+        default:
+            debugger;
+            throw new Error("unknown type: " + JSON.stringify(n.type));
+    }
+}
+function printDecorators(path, printPath) {
+    const parts = [];
+    const node = path.getValue();
+    if (node.decorators &&
+        node.decorators.length > 0 &&
+        // If the parent node is an export declaration, it will be
+        // responsible for printing node.decorators.
+        !util.getParentExportDeclaration(path)) {
+        path.each(function (decoratorPath) {
+            parts.push(printPath(decoratorPath), "\n");
+        }, "decorators");
+    }
+    else if (util.isExportDeclaration(node) &&
+        node.declaration &&
+        node.declaration.decorators) {
+        // Export declarations are responsible for printing any decorators
+        // that logically apply to node.declaration.
+        path.each(function (decoratorPath) {
+            parts.push(printPath(decoratorPath), "\n");
+        }, "declaration", "decorators");
+    }
+    return concat(parts);
+}
+function printStatementSequence(path, options, print) {
+    const filtered = [];
+    let sawComment = false;
+    let sawStatement = false;
+    path.each(function (stmtPath) {
+        const stmt = stmtPath.getValue();
+        // Just in case the AST has been modified to contain falsy
+        // "statements," it's safer simply to skip them.
+        if (!stmt) {
+            return;
+        }
+        // Skip printing EmptyStatement nodes to avoid leaving stray
+        // semicolons lying around.
+        if (stmt.type === "EmptyStatement" &&
+            !(stmt.comments && stmt.comments.length > 0)) {
+            return;
+        }
+        if (namedTypes.Comment.check(stmt)) {
+            // The pretty printer allows a dangling Comment node to act as
+            // a Statement when the Comment can't be attached to any other
+            // non-Comment node in the tree.
+            sawComment = true;
+        }
+        else if (namedTypes.Statement.check(stmt)) {
+            sawStatement = true;
+        }
+        else {
+            // When the pretty printer encounters a string instead of an
+            // AST node, it just prints the string. This behavior can be
+            // useful for fine-grained formatting decisions like inserting
+            // blank lines.
+            isString.assert(stmt);
+        }
+        // We can't hang onto stmtPath outside of this function, because
+        // it's just a reference to a mutable FastPath object, so we have
+        // to go ahead and print it here.
+        filtered.push({
+            node: stmt,
+            printed: print(stmtPath),
+        });
+    });
+    if (sawComment) {
+        assert.strictEqual(sawStatement, false, "Comments may appear as statements in otherwise empty statement " +
+            "lists, but may not coexist with non-Comment nodes.");
+    }
+    let prevTrailingSpace = null;
+    const len = filtered.length;
+    const parts = [];
+    filtered.forEach(function (info, i) {
+        const printed = info.printed;
+        const stmt = info.node;
+        const multiLine = printed.length > 1;
+        const notFirst = i > 0;
+        const notLast = i < len - 1;
+        let leadingSpace;
+        let trailingSpace;
+        const lines = stmt && stmt.loc && stmt.loc.lines;
+        const trueLoc = lines && options.reuseWhitespace && util.getTrueLoc(stmt, lines);
+        if (notFirst) {
+            if (trueLoc) {
+                const beforeStart = lines.skipSpaces(trueLoc.start, true);
+                const beforeStartLine = beforeStart ? beforeStart.line : 1;
+                const leadingGap = trueLoc.start.line - beforeStartLine;
+                leadingSpace = Array(leadingGap + 1).join("\n");
+            }
+            else {
+                leadingSpace = multiLine ? "\n\n" : "\n";
+            }
+        }
+        else {
+            leadingSpace = "";
+        }
+        if (notLast) {
+            if (trueLoc) {
+                const afterEnd = lines.skipSpaces(trueLoc.end);
+                const afterEndLine = afterEnd ? afterEnd.line : lines.length;
+                const trailingGap = afterEndLine - trueLoc.end.line;
+                trailingSpace = Array(trailingGap + 1).join("\n");
+            }
+            else {
+                trailingSpace = multiLine ? "\n\n" : "\n";
+            }
+        }
+        else {
+            trailingSpace = "";
+        }
+        parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);
+        if (notLast) {
+            prevTrailingSpace = trailingSpace;
+        }
+        else if (trailingSpace) {
+            parts.push(trailingSpace);
+        }
+    });
+    return concat(parts);
+}
+function maxSpace(s1, s2) {
+    if (!s1 && !s2) {
+        return fromString("");
+    }
+    if (!s1) {
+        return fromString(s2);
+    }
+    if (!s2) {
+        return fromString(s1);
+    }
+    const spaceLines1 = fromString(s1);
+    const spaceLines2 = fromString(s2);
+    if (spaceLines2.length > spaceLines1.length) {
+        return spaceLines2;
+    }
+    return spaceLines1;
+}
+function printClassMemberModifiers(node) {
+    const parts = [];
+    if (node.declare) {
+        parts.push("declare ");
+    }
+    const access = node.accessibility || node.access;
+    if (typeof access === "string") {
+        parts.push(access, " ");
+    }
+    if (node.static) {
+        parts.push("static ");
+    }
+    if (node.override) {
+        parts.push("override ");
+    }
+    if (node.abstract) {
+        parts.push("abstract ");
+    }
+    if (node.readonly) {
+        parts.push("readonly ");
+    }
+    return parts;
+}
+function printMethod(path, options, print) {
+    const node = path.getNode();
+    const kind = node.kind;
+    const parts = [];
+    let nodeValue = node.value;
+    if (!namedTypes.FunctionExpression.check(nodeValue)) {
+        nodeValue = node;
+    }
+    parts.push(...printClassMemberModifiers(node));
+    if (nodeValue.async) {
+        parts.push("async ");
+    }
+    if (nodeValue.generator) {
+        parts.push("*");
+    }
+    if (kind === "get" || kind === "set") {
+        parts.push(kind, " ");
+    }
+    let key = path.call(print, "key");
+    if (node.computed) {
+        key = concat(["[", key, "]"]);
+    }
+    parts.push(key);
+    if (node.optional) {
+        parts.push("?");
+    }
+    if (node === nodeValue) {
+        parts.push(path.call(print, "typeParameters"), "(", printFunctionParams(path, options, print), ")", path.call(print, "returnType"));
+        if (node.body) {
+            parts.push(" ", path.call(print, "body"));
+        }
+        else {
+            parts.push(";");
+        }
+    }
+    else {
+        parts.push(path.call(print, "value", "typeParameters"), "(", path.call((valuePath) => printFunctionParams(valuePath, options, print), "value"), ")", path.call(print, "value", "returnType"));
+        if (nodeValue.body) {
+            parts.push(" ", path.call(print, "value", "body"));
+        }
+        else {
+            parts.push(";");
+        }
+    }
+    return concat(parts);
+}
+function printArgumentsList(path, options, print) {
+    const printed = path.map(print, "arguments");
+    const trailingComma = util.isTrailingCommaEnabled(options, "parameters");
+    let joined = fromString(", ").join(printed);
+    if (joined.getLineLength(1) > options.wrapColumn) {
+        joined = fromString(",\n").join(printed);
+        return concat([
+            "(\n",
+            joined.indent(options.tabWidth),
+            trailingComma ? ",\n)" : "\n)",
+        ]);
+    }
+    return concat(["(", joined, ")"]);
+}
+function printFunctionParams(path, options, print) {
+    const fun = path.getValue();
+    let params;
+    let printed = [];
+    if (fun.params) {
+        params = fun.params;
+        printed = path.map(print, "params");
+    }
+    else if (fun.parameters) {
+        params = fun.parameters;
+        printed = path.map(print, "parameters");
+    }
+    if (fun.defaults) {
+        path.each(function (defExprPath) {
+            const i = defExprPath.getName();
+            const p = printed[i];
+            if (p && defExprPath.getValue()) {
+                printed[i] = concat([p, " = ", print(defExprPath)]);
+            }
+        }, "defaults");
+    }
+    if (fun.rest) {
+        printed.push(concat(["...", path.call(print, "rest")]));
+    }
+    let joined = fromString(", ").join(printed);
+    if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {
+        joined = fromString(",\n").join(printed);
+        if (util.isTrailingCommaEnabled(options, "parameters") &&
+            !fun.rest &&
+            params[params.length - 1].type !== "RestElement") {
+            joined = concat([joined, ",\n"]);
+        }
+        else {
+            joined = concat([joined, "\n"]);
+        }
+        return concat(["\n", joined.indent(options.tabWidth)]);
+    }
+    return joined;
+}
+function maybePrintImportAssertions(path, options, print) {
+    const n = path.getValue();
+    if (n.assertions && n.assertions.length > 0) {
+        const parts = [" assert {"];
+        const printed = path.map(print, "assertions");
+        const flat = fromString(", ").join(printed);
+        if (flat.length > 1 || flat.getLineLength(1) > options.wrapColumn) {
+            parts.push("\n", fromString(",\n").join(printed).indent(options.tabWidth), "\n}");
+        }
+        else {
+            parts.push(" ", flat, " }");
+        }
+        return concat(parts);
+    }
+    return fromString("");
+}
+function printExportDeclaration(path, options, print) {
+    const decl = path.getValue();
+    const parts = ["export "];
+    if (decl.exportKind && decl.exportKind === "type") {
+        if (!decl.declaration) {
+            parts.push("type ");
+        }
+    }
+    const shouldPrintSpaces = options.objectCurlySpacing;
+    namedTypes.Declaration.assert(decl);
+    if (decl["default"] || decl.type === "ExportDefaultDeclaration") {
+        parts.push("default ");
+    }
+    if (decl.declaration) {
+        parts.push(path.call(print, "declaration"));
+    }
+    else if (decl.specifiers) {
+        if (decl.specifiers.length === 1 &&
+            decl.specifiers[0].type === "ExportBatchSpecifier") {
+            parts.push("*");
+        }
+        else if (decl.specifiers.length === 0) {
+            parts.push("{}");
+        }
+        else if (decl.specifiers[0].type === "ExportDefaultSpecifier") {
+            const unbracedSpecifiers = [];
+            const bracedSpecifiers = [];
+            path.each(function (specifierPath) {
+                const spec = specifierPath.getValue();
+                if (spec.type === "ExportDefaultSpecifier") {
+                    unbracedSpecifiers.push(print(specifierPath));
+                }
+                else {
+                    bracedSpecifiers.push(print(specifierPath));
+                }
+            }, "specifiers");
+            unbracedSpecifiers.forEach((lines, i) => {
+                if (i > 0) {
+                    parts.push(", ");
+                }
+                parts.push(lines);
+            });
+            if (bracedSpecifiers.length > 0) {
+                let lines = fromString(", ").join(bracedSpecifiers);
+                if (lines.getLineLength(1) > options.wrapColumn) {
+                    lines = concat([
+                        fromString(",\n").join(bracedSpecifiers).indent(options.tabWidth),
+                        ",",
+                    ]);
+                }
+                if (unbracedSpecifiers.length > 0) {
+                    parts.push(", ");
+                }
+                if (lines.length > 1) {
+                    parts.push("{\n", lines, "\n}");
+                }
+                else if (options.objectCurlySpacing) {
+                    parts.push("{ ", lines, " }");
+                }
+                else {
+                    parts.push("{", lines, "}");
+                }
+            }
+        }
+        else {
+            parts.push(shouldPrintSpaces ? "{ " : "{", fromString(", ").join(path.map(print, "specifiers")), shouldPrintSpaces ? " }" : "}");
+        }
+        if (decl.source) {
+            parts.push(" from ", path.call(print, "source"), maybePrintImportAssertions(path, options, print));
+        }
+    }
+    let lines = concat(parts);
+    if (lastNonSpaceCharacter(lines) !== ";" &&
+        !(decl.declaration &&
+            (decl.declaration.type === "FunctionDeclaration" ||
+                decl.declaration.type === "ClassDeclaration" ||
+                decl.declaration.type === "TSModuleDeclaration" ||
+                decl.declaration.type === "TSInterfaceDeclaration" ||
+                decl.declaration.type === "TSEnumDeclaration"))) {
+        lines = concat([lines, ";"]);
+    }
+    return lines;
+}
+function printFlowDeclaration(path, parts) {
+    const parentExportDecl = util.getParentExportDeclaration(path);
+    if (parentExportDecl) {
+        assert.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
+    }
+    else {
+        // If the parent node has type DeclareExportDeclaration, then it
+        // will be responsible for printing the "declare" token. Otherwise
+        // it needs to be printed with this non-exported declaration node.
+        parts.unshift("declare ");
+    }
+    return concat(parts);
+}
+function printVariance(path, print) {
+    return path.call(function (variancePath) {
+        const value = variancePath.getValue();
+        if (value) {
+            if (value === "plus") {
+                return fromString("+");
+            }
+            if (value === "minus") {
+                return fromString("-");
+            }
+            return print(variancePath);
+        }
+        return fromString("");
+    }, "variance");
+}
+function adjustClause(clause, options) {
+    if (clause.length > 1)
+        return concat([" ", clause]);
+    return concat(["\n", maybeAddSemicolon(clause).indent(options.tabWidth)]);
+}
+function lastNonSpaceCharacter(lines) {
+    const pos = lines.lastPos();
+    do {
+        const ch = lines.charAt(pos);
+        if (/\S/.test(ch))
+            return ch;
+    } while (lines.prevPos(pos));
+}
+function endsWithBrace(lines) {
+    return lastNonSpaceCharacter(lines) === "}";
+}
+function swapQuotes(str) {
+    return str.replace(/['"]/g, (m) => (m === '"' ? "'" : '"'));
+}
+function getPossibleRaw(node) {
+    const value = types.getFieldValue(node, "value");
+    const extra = types.getFieldValue(node, "extra");
+    if (extra && typeof extra.raw === "string" && value == extra.rawValue) {
+        return extra.raw;
+    }
+    if (node.type === "Literal") {
+        const raw = node.raw;
+        if (typeof raw === "string" && value == raw) {
+            return raw;
+        }
+    }
+}
+function jsSafeStringify(str) {
+    return JSON.stringify(str).replace(/[\u2028\u2029]/g, function (m) {
+        return "\\u" + m.charCodeAt(0).toString(16);
+    });
+}
+function nodeStr(str, options) {
+    isString.assert(str);
+    switch (options.quote) {
+        case "auto": {
+            const double = jsSafeStringify(str);
+            const single = swapQuotes(jsSafeStringify(swapQuotes(str)));
+            return double.length > single.length ? single : double;
+        }
+        case "single":
+            return swapQuotes(jsSafeStringify(swapQuotes(str)));
+        case "double":
+        default:
+            return jsSafeStringify(str);
+    }
+}
+function maybeAddSemicolon(lines) {
+    const eoc = lastNonSpaceCharacter(lines);
+    if (!eoc || "\n};".indexOf(eoc) < 0)
+        return concat([lines, ";"]);
+    return lines;
+}
diff --git a/node_modules/recast/esm/lib/util.d.ts b/node_modules/recast/esm/lib/util.d.ts
new file mode 100644
index 0000000..be90a93
--- /dev/null
+++ b/node_modules/recast/esm/lib/util.d.ts
@@ -0,0 +1,18 @@
+export declare function getLineTerminator(): string;
+export declare function isBrowser(): boolean;
+export declare function getOption(options: any, key: any, defaultValue: any): any;
+export declare function getUnionOfKeys(...args: any[]): any;
+export declare function comparePos(pos1: any, pos2: any): number;
+export declare function copyPos(pos: any): {
+    line: any;
+    column: any;
+};
+export declare function composeSourceMaps(formerMap: any, latterMap: any): any;
+export declare function getTrueLoc(node: any, lines: any): {
+    start: any;
+    end: any;
+} | null;
+export declare function fixFaultyLocations(node: any, lines: any): void;
+export declare function isExportDeclaration(node: any): boolean;
+export declare function getParentExportDeclaration(path: any): any;
+export declare function isTrailingCommaEnabled(options: any, context: any): boolean;
diff --git a/node_modules/recast/esm/lib/util.mjs b/node_modules/recast/esm/lib/util.mjs
new file mode 100644
index 0000000..125cb9b
--- /dev/null
+++ b/node_modules/recast/esm/lib/util.mjs
@@ -0,0 +1,312 @@
+import assert from "assert";
+import * as types from "ast-types";
+const n = types.namedTypes;
+import sourceMap from "source-map";
+import { EOL } from "os";
+const SourceMapConsumer = sourceMap.SourceMapConsumer;
+const SourceMapGenerator = sourceMap.SourceMapGenerator;
+const hasOwn = Object.prototype.hasOwnProperty;
+export function getLineTerminator() {
+    return isBrowser() ? "\n" : EOL || "\n";
+}
+export function isBrowser() {
+    return (typeof window !== "undefined" && typeof window.document !== "undefined");
+}
+export function getOption(options, key, defaultValue) {
+    if (options && hasOwn.call(options, key)) {
+        return options[key];
+    }
+    return defaultValue;
+}
+export function getUnionOfKeys(...args) {
+    const result = {};
+    const argc = args.length;
+    for (let i = 0; i < argc; ++i) {
+        const keys = Object.keys(args[i]);
+        const keyCount = keys.length;
+        for (let j = 0; j < keyCount; ++j) {
+            result[keys[j]] = true;
+        }
+    }
+    return result;
+}
+export function comparePos(pos1, pos2) {
+    return pos1.line - pos2.line || pos1.column - pos2.column;
+}
+export function copyPos(pos) {
+    return {
+        line: pos.line,
+        column: pos.column,
+    };
+}
+export function composeSourceMaps(formerMap, latterMap) {
+    if (formerMap) {
+        if (!latterMap) {
+            return formerMap;
+        }
+    }
+    else {
+        return latterMap || null;
+    }
+    const smcFormer = new SourceMapConsumer(formerMap);
+    const smcLatter = new SourceMapConsumer(latterMap);
+    const smg = new SourceMapGenerator({
+        file: latterMap.file,
+        sourceRoot: latterMap.sourceRoot,
+    });
+    const sourcesToContents = {};
+    smcLatter.eachMapping(function (mapping) {
+        const origPos = smcFormer.originalPositionFor({
+            line: mapping.originalLine,
+            column: mapping.originalColumn,
+        });
+        const sourceName = origPos.source;
+        if (sourceName === null) {
+            return;
+        }
+        smg.addMapping({
+            source: sourceName,
+            original: copyPos(origPos),
+            generated: {
+                line: mapping.generatedLine,
+                column: mapping.generatedColumn,
+            },
+            name: mapping.name,
+        });
+        const sourceContent = smcFormer.sourceContentFor(sourceName);
+        if (sourceContent && !hasOwn.call(sourcesToContents, sourceName)) {
+            sourcesToContents[sourceName] = sourceContent;
+            smg.setSourceContent(sourceName, sourceContent);
+        }
+    });
+    return smg.toJSON();
+}
+export function getTrueLoc(node, lines) {
+    // It's possible that node is newly-created (not parsed by Esprima),
+    // in which case it probably won't have a .loc property (or an
+    // .original property for that matter). That's fine; we'll just
+    // pretty-print it as usual.
+    if (!node.loc) {
+        return null;
+    }
+    const result = {
+        start: node.loc.start,
+        end: node.loc.end,
+    };
+    function include(node) {
+        expandLoc(result, node.loc);
+    }
+    // If the node is an export declaration and its .declaration has any
+    // decorators, their locations might contribute to the true start/end
+    // positions of the export declaration node.
+    if (node.declaration &&
+        node.declaration.decorators &&
+        isExportDeclaration(node)) {
+        node.declaration.decorators.forEach(include);
+    }
+    if (comparePos(result.start, result.end) < 0) {
+        // Trim leading whitespace.
+        result.start = copyPos(result.start);
+        lines.skipSpaces(result.start, false, true);
+        if (comparePos(result.start, result.end) < 0) {
+            // Trim trailing whitespace, if the end location is not already the
+            // same as the start location.
+            result.end = copyPos(result.end);
+            lines.skipSpaces(result.end, true, true);
+        }
+    }
+    // If the node has any comments, their locations might contribute to
+    // the true start/end positions of the node.
+    if (node.comments) {
+        node.comments.forEach(include);
+    }
+    return result;
+}
+function expandLoc(parentLoc, childLoc) {
+    if (parentLoc && childLoc) {
+        if (comparePos(childLoc.start, parentLoc.start) < 0) {
+            parentLoc.start = childLoc.start;
+        }
+        if (comparePos(parentLoc.end, childLoc.end) < 0) {
+            parentLoc.end = childLoc.end;
+        }
+    }
+}
+export function fixFaultyLocations(node, lines) {
+    const loc = node.loc;
+    if (loc) {
+        if (loc.start.line < 1) {
+            loc.start.line = 1;
+        }
+        if (loc.end.line < 1) {
+            loc.end.line = 1;
+        }
+    }
+    if (node.type === "File") {
+        // Babylon returns File nodes whose .loc.{start,end} do not include
+        // leading or trailing whitespace.
+        loc.start = lines.firstPos();
+        loc.end = lines.lastPos();
+    }
+    fixForLoopHead(node, lines);
+    fixTemplateLiteral(node, lines);
+    if (loc && node.decorators) {
+        // Expand the .loc of the node responsible for printing the decorators
+        // (here, the decorated node) so that it includes node.decorators.
+        node.decorators.forEach(function (decorator) {
+            expandLoc(loc, decorator.loc);
+        });
+    }
+    else if (node.declaration && isExportDeclaration(node)) {
+        // Nullify .loc information for the child declaration so that we never
+        // try to reprint it without also reprinting the export declaration.
+        node.declaration.loc = null;
+        // Expand the .loc of the node responsible for printing the decorators
+        // (here, the export declaration) so that it includes node.decorators.
+        const decorators = node.declaration.decorators;
+        if (decorators) {
+            decorators.forEach(function (decorator) {
+                expandLoc(loc, decorator.loc);
+            });
+        }
+    }
+    else if ((n.MethodDefinition && n.MethodDefinition.check(node)) ||
+        (n.Property.check(node) && (node.method || node.shorthand))) {
+        // If the node is a MethodDefinition or a .method or .shorthand
+        // Property, then the location information stored in
+        // node.value.loc is very likely untrustworthy (just the {body}
+        // part of a method, or nothing in the case of shorthand
+        // properties), so we null out that information to prevent
+        // accidental reuse of bogus source code during reprinting.
+        node.value.loc = null;
+        if (n.FunctionExpression.check(node.value)) {
+            // FunctionExpression method values should be anonymous,
+            // because their .id fields are ignored anyway.
+            node.value.id = null;
+        }
+    }
+    else if (node.type === "ObjectTypeProperty") {
+        const loc = node.loc;
+        let end = loc && loc.end;
+        if (end) {
+            end = copyPos(end);
+            if (lines.prevPos(end) && lines.charAt(end) === ",") {
+                // Some parsers accidentally include trailing commas in the
+                // .loc.end information for ObjectTypeProperty nodes.
+                if ((end = lines.skipSpaces(end, true, true))) {
+                    loc.end = end;
+                }
+            }
+        }
+    }
+}
+function fixForLoopHead(node, lines) {
+    if (node.type !== "ForStatement") {
+        return;
+    }
+    function fix(child) {
+        const loc = child && child.loc;
+        const start = loc && loc.start;
+        const end = loc && copyPos(loc.end);
+        while (start && end && comparePos(start, end) < 0) {
+            lines.prevPos(end);
+            if (lines.charAt(end) === ";") {
+                // Update child.loc.end to *exclude* the ';' character.
+                loc.end.line = end.line;
+                loc.end.column = end.column;
+            }
+            else {
+                break;
+            }
+        }
+    }
+    fix(node.init);
+    fix(node.test);
+    fix(node.update);
+}
+function fixTemplateLiteral(node, lines) {
+    if (node.type !== "TemplateLiteral") {
+        return;
+    }
+    if (node.quasis.length === 0) {
+        // If there are no quasi elements, then there is nothing to fix.
+        return;
+    }
+    // node.loc is not present when using export default with a template literal
+    if (node.loc) {
+        // First we need to exclude the opening ` from the .loc of the first
+        // quasi element, in case the parser accidentally decided to include it.
+        const afterLeftBackTickPos = copyPos(node.loc.start);
+        assert.strictEqual(lines.charAt(afterLeftBackTickPos), "`");
+        assert.ok(lines.nextPos(afterLeftBackTickPos));
+        const firstQuasi = node.quasis[0];
+        if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {
+            firstQuasi.loc.start = afterLeftBackTickPos;
+        }
+        // Next we need to exclude the closing ` from the .loc of the last quasi
+        // element, in case the parser accidentally decided to include it.
+        const rightBackTickPos = copyPos(node.loc.end);
+        assert.ok(lines.prevPos(rightBackTickPos));
+        assert.strictEqual(lines.charAt(rightBackTickPos), "`");
+        const lastQuasi = node.quasis[node.quasis.length - 1];
+        if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {
+            lastQuasi.loc.end = rightBackTickPos;
+        }
+    }
+    // Now we need to exclude ${ and } characters from the .loc's of all
+    // quasi elements, since some parsers accidentally include them.
+    node.expressions.forEach(function (expr, i) {
+        // Rewind from expr.loc.start over any whitespace and the ${ that
+        // precedes the expression. The position of the $ should be the same
+        // as the .loc.end of the preceding quasi element, but some parsers
+        // accidentally include the ${ in the .loc of the quasi element.
+        const dollarCurlyPos = lines.skipSpaces(expr.loc.start, true, false);
+        if (lines.prevPos(dollarCurlyPos) &&
+            lines.charAt(dollarCurlyPos) === "{" &&
+            lines.prevPos(dollarCurlyPos) &&
+            lines.charAt(dollarCurlyPos) === "$") {
+            const quasiBefore = node.quasis[i];
+            if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {
+                quasiBefore.loc.end = dollarCurlyPos;
+            }
+        }
+        // Likewise, some parsers accidentally include the } that follows
+        // the expression in the .loc of the following quasi element.
+        const rightCurlyPos = lines.skipSpaces(expr.loc.end, false, false);
+        if (lines.charAt(rightCurlyPos) === "}") {
+            assert.ok(lines.nextPos(rightCurlyPos));
+            // Now rightCurlyPos is technically the position just after the }.
+            const quasiAfter = node.quasis[i + 1];
+            if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {
+                quasiAfter.loc.start = rightCurlyPos;
+            }
+        }
+    });
+}
+export function isExportDeclaration(node) {
+    if (node)
+        switch (node.type) {
+            case "ExportDeclaration":
+            case "ExportDefaultDeclaration":
+            case "ExportDefaultSpecifier":
+            case "DeclareExportDeclaration":
+            case "ExportNamedDeclaration":
+            case "ExportAllDeclaration":
+                return true;
+        }
+    return false;
+}
+export function getParentExportDeclaration(path) {
+    const parentNode = path.getParentNode();
+    if (path.getName() === "declaration" && isExportDeclaration(parentNode)) {
+        return parentNode;
+    }
+    return null;
+}
+export function isTrailingCommaEnabled(options, context) {
+    const trailingComma = options.trailingComma;
+    if (typeof trailingComma === "object") {
+        return !!trailingComma[context];
+    }
+    return !!trailingComma;
+}
diff --git a/node_modules/recast/esm/main.d.ts b/node_modules/recast/esm/main.d.ts
new file mode 100644
index 0000000..767c0cb
--- /dev/null
+++ b/node_modules/recast/esm/main.d.ts
@@ -0,0 +1,50 @@
+import * as types from "ast-types";
+import { parse } from "./lib/parser.js";
+import { Options } from "./lib/options.js";
+export { 
+/**
+ * Parse a string of code into an augmented syntax tree suitable for
+ * arbitrary modification and reprinting.
+ */
+parse, 
+/**
+ * Convenient shorthand for the ast-types package.
+ */
+types, };
+/**
+ * Traverse and potentially modify an abstract syntax tree using a
+ * convenient visitor syntax:
+ *
+ *   recast.visit(ast, {
+ *     names: [],
+ *     visitIdentifier: function(path) {
+ *       var node = path.value;
+ *       this.visitor.names.push(node.name);
+ *       this.traverse(path);
+ *     }
+ *   });
+ */
+export { visit } from "ast-types";
+/**
+ * Options shared between parsing and printing.
+ */
+export { Options } from "./lib/options.js";
+/**
+ * Reprint a modified syntax tree using as much of the original source
+ * code as possible.
+ */
+export declare function print(node: types.ASTNode, options?: Options): import("./lib/printer.js").PrintResultType;
+/**
+ * Print without attempting to reuse any original source code.
+ */
+export declare function prettyPrint(node: types.ASTNode, options?: Options): import("./lib/printer.js").PrintResultType;
+/**
+ * Convenient command-line interface (see e.g. example/add-braces).
+ */
+export declare function run(transformer: Transformer, options?: RunOptions): void;
+export interface Transformer {
+    (ast: types.ASTNode, callback: (ast: types.ASTNode) => void): void;
+}
+export interface RunOptions extends Options {
+    writeback?(code: string): void;
+}
diff --git a/node_modules/recast/esm/main.mjs b/node_modules/recast/esm/main.mjs
new file mode 100644
index 0000000..d7dba06
--- /dev/null
+++ b/node_modules/recast/esm/main.mjs
@@ -0,0 +1,65 @@
+import fs from "fs";
+import * as types from "ast-types";
+import { parse } from "./lib/parser.mjs";
+import { Printer } from "./lib/printer.mjs";
+export { 
+/**
+ * Parse a string of code into an augmented syntax tree suitable for
+ * arbitrary modification and reprinting.
+ */
+parse, 
+/**
+ * Convenient shorthand for the ast-types package.
+ */
+types, };
+/**
+ * Traverse and potentially modify an abstract syntax tree using a
+ * convenient visitor syntax:
+ *
+ *   recast.visit(ast, {
+ *     names: [],
+ *     visitIdentifier: function(path) {
+ *       var node = path.value;
+ *       this.visitor.names.push(node.name);
+ *       this.traverse(path);
+ *     }
+ *   });
+ */
+export { visit } from "ast-types";
+/**
+ * Reprint a modified syntax tree using as much of the original source
+ * code as possible.
+ */
+export function print(node, options) {
+    return new Printer(options).print(node);
+}
+/**
+ * Print without attempting to reuse any original source code.
+ */
+export function prettyPrint(node, options) {
+    return new Printer(options).printGenerically(node);
+}
+/**
+ * Convenient command-line interface (see e.g. example/add-braces).
+ */
+export function run(transformer, options) {
+    return runFile(process.argv[2], transformer, options);
+}
+function runFile(path, transformer, options) {
+    fs.readFile(path, "utf-8", function (err, code) {
+        if (err) {
+            console.error(err);
+            return;
+        }
+        runString(code, transformer, options);
+    });
+}
+function defaultWriteback(output) {
+    process.stdout.write(output);
+}
+function runString(code, transformer, options) {
+    const writeback = (options && options.writeback) || defaultWriteback;
+    transformer(parse(code, options), function (node) {
+        writeback(print(node, options).code);
+    });
+}
diff --git a/node_modules/recast/esm/parsers/_babel_options.d.ts b/node_modules/recast/esm/parsers/_babel_options.d.ts
new file mode 100644
index 0000000..76c9cf8
--- /dev/null
+++ b/node_modules/recast/esm/parsers/_babel_options.d.ts
@@ -0,0 +1,8 @@
+import { ParserOptions, ParserPlugin } from "@babel/parser";
+export type Overrides = Partial<{
+    sourceType: ParserOptions["sourceType"];
+    strictMode: ParserOptions["strictMode"];
+}>;
+export default function getBabelOptions(options?: Overrides): ParserOptions & {
+    plugins: ParserPlugin[];
+};
diff --git a/node_modules/recast/esm/parsers/_babel_options.mjs b/node_modules/recast/esm/parsers/_babel_options.mjs
new file mode 100644
index 0000000..824516f
--- /dev/null
+++ b/node_modules/recast/esm/parsers/_babel_options.mjs
@@ -0,0 +1,54 @@
+import { getOption } from "../lib/util.mjs";
+export default function getBabelOptions(options) {
+    // The goal here is to tolerate as much syntax as possible, since Recast
+    // is not in the business of forbidding anything. If you want your
+    // parser to be more restrictive for some reason, you can always pass
+    // your own parser object to recast.parse.
+    return {
+        sourceType: getOption(options, "sourceType", "module"),
+        strictMode: getOption(options, "strictMode", false),
+        allowImportExportEverywhere: true,
+        allowReturnOutsideFunction: true,
+        startLine: 1,
+        tokens: true,
+        plugins: [
+            "asyncGenerators",
+            "bigInt",
+            "classPrivateMethods",
+            "classPrivateProperties",
+            "classProperties",
+            "classStaticBlock",
+            "decimal",
+            "decorators-legacy",
+            "doExpressions",
+            "dynamicImport",
+            "exportDefaultFrom",
+            "exportExtensions",
+            "exportNamespaceFrom",
+            "functionBind",
+            "functionSent",
+            "importAssertions",
+            "importMeta",
+            "nullishCoalescingOperator",
+            "numericSeparator",
+            "objectRestSpread",
+            "optionalCatchBinding",
+            "optionalChaining",
+            [
+                "pipelineOperator",
+                {
+                    proposal: "minimal",
+                },
+            ],
+            [
+                "recordAndTuple",
+                {
+                    syntaxType: "hash",
+                },
+            ],
+            "throwExpressions",
+            "topLevelAwait",
+            "v8intrinsic",
+        ],
+    };
+}
diff --git a/node_modules/recast/esm/parsers/acorn.d.ts b/node_modules/recast/esm/parsers/acorn.d.ts
new file mode 100644
index 0000000..7456674
--- /dev/null
+++ b/node_modules/recast/esm/parsers/acorn.d.ts
@@ -0,0 +1,2 @@
+import * as acorn from "acorn";
+export declare function parse(source: string, options?: any): acorn.Node;
diff --git a/node_modules/recast/esm/parsers/acorn.mjs b/node_modules/recast/esm/parsers/acorn.mjs
new file mode 100644
index 0000000..7dc2e41
--- /dev/null
+++ b/node_modules/recast/esm/parsers/acorn.mjs
@@ -0,0 +1,34 @@
+// This module is suitable for passing as options.parser when calling
+// recast.parse to process JavaScript code with Acorn:
+//
+//   const ast = recast.parse(source, {
+//     parser: require("recast/parsers/acorn")
+//   });
+//
+import { getOption } from "../lib/util.mjs";
+import * as acorn from "acorn";
+export function parse(source, options) {
+    const comments = [];
+    const tokens = [];
+    const ast = acorn.parse(source, {
+        allowHashBang: true,
+        allowImportExportEverywhere: true,
+        allowReturnOutsideFunction: true,
+        ecmaVersion: getOption(options, "ecmaVersion", 8),
+        sourceType: getOption(options, "sourceType", "module"),
+        locations: true,
+        onComment: comments,
+        onToken: tokens,
+    });
+    // @ts-expect-error
+    if (!ast.comments) {
+        // @ts-expect-error
+        ast.comments = comments;
+    }
+    // @ts-expect-error
+    if (!ast.tokens) {
+        // @ts-expect-error
+        ast.tokens = tokens;
+    }
+    return ast;
+}
diff --git a/node_modules/recast/esm/parsers/babel-ts.d.ts b/node_modules/recast/esm/parsers/babel-ts.d.ts
new file mode 100644
index 0000000..3ce3fec
--- /dev/null
+++ b/node_modules/recast/esm/parsers/babel-ts.d.ts
@@ -0,0 +1,4 @@
+import { parser } from "./babel.js";
+import { Overrides } from "./_babel_options.js";
+export { parser };
+export declare function parse(source: string, options?: Overrides): import("@babel/parser").ParseResult<import("@babel/types").File>;
diff --git a/node_modules/recast/esm/parsers/babel-ts.mjs b/node_modules/recast/esm/parsers/babel-ts.mjs
new file mode 100644
index 0000000..bda04cf
--- /dev/null
+++ b/node_modules/recast/esm/parsers/babel-ts.mjs
@@ -0,0 +1,8 @@
+import { parser } from "./babel.mjs";
+import getBabelOptions from "./_babel_options.mjs";
+export { parser };
+export function parse(source, options) {
+    const babelOptions = getBabelOptions(options);
+    babelOptions.plugins.push("jsx", "typescript");
+    return parser.parse(source, babelOptions);
+}
diff --git a/node_modules/recast/esm/parsers/babel.d.ts b/node_modules/recast/esm/parsers/babel.d.ts
new file mode 100644
index 0000000..de6a538
--- /dev/null
+++ b/node_modules/recast/esm/parsers/babel.d.ts
@@ -0,0 +1,9 @@
+import { parse as babelParse } from "@babel/parser";
+import { Overrides } from "./_babel_options.js";
+import * as babelParser from "@babel/parser";
+type BabelParser = {
+    parse: typeof babelParse;
+};
+export declare const parser: BabelParser;
+export declare function parse(source: string, options?: Overrides): babelParser.ParseResult<import("@babel/types").File>;
+export {};
diff --git a/node_modules/recast/esm/parsers/babel.mjs b/node_modules/recast/esm/parsers/babel.mjs
new file mode 100644
index 0000000..047183d
--- /dev/null
+++ b/node_modules/recast/esm/parsers/babel.mjs
@@ -0,0 +1,31 @@
+import getBabelOptions from "./_babel_options.mjs";
+import * as babelParser from "@babel/parser";
+import * as babylon from "babylon";
+// Prefer the new @babel/parser package, but fall back to babylon if
+// that's what's available.babel
+export const parser = (function () {
+    try {
+        return babelParser;
+    }
+    catch {
+        try {
+            // @ts-expect-error
+            return babylon;
+        }
+        catch {
+            throw new Error("Install @babel/parser to use the `typescript`, `flow`, or `babel` parsers");
+        }
+    }
+})();
+// This module is suitable for passing as options.parser when calling
+// recast.parse to process JavaScript code with Babel:
+//
+//   const ast = recast.parse(source, {
+//     parser: require("recast/parsers/babel")
+//   });
+//
+export function parse(source, options) {
+    const babelOptions = getBabelOptions(options);
+    babelOptions.plugins.push("jsx", "flow", "decoratorAutoAccessors");
+    return parser.parse(source, babelOptions);
+}
diff --git a/node_modules/recast/esm/parsers/babylon.d.ts b/node_modules/recast/esm/parsers/babylon.d.ts
new file mode 100644
index 0000000..e89d904
--- /dev/null
+++ b/node_modules/recast/esm/parsers/babylon.d.ts
@@ -0,0 +1 @@
+export * from "./babel.js";
diff --git a/node_modules/recast/esm/parsers/babylon.mjs b/node_modules/recast/esm/parsers/babylon.mjs
new file mode 100644
index 0000000..aabc28b
--- /dev/null
+++ b/node_modules/recast/esm/parsers/babylon.mjs
@@ -0,0 +1 @@
+export * from "./babel.mjs";
diff --git a/node_modules/recast/esm/parsers/esprima.d.ts b/node_modules/recast/esm/parsers/esprima.d.ts
new file mode 100644
index 0000000..6437ad3
--- /dev/null
+++ b/node_modules/recast/esm/parsers/esprima.d.ts
@@ -0,0 +1,2 @@
+import * as esprima from "esprima";
+export declare function parse(source: string, options?: any): esprima.Program;
diff --git a/node_modules/recast/esm/parsers/esprima.mjs b/node_modules/recast/esm/parsers/esprima.mjs
new file mode 100644
index 0000000..be6761e
--- /dev/null
+++ b/node_modules/recast/esm/parsers/esprima.mjs
@@ -0,0 +1,29 @@
+"use strict";
+// This module is suitable for passing as options.parser when calling
+// recast.parse to process ECMAScript code with Esprima:
+//
+//   const ast = recast.parse(source, {
+//     parser: require("recast/parsers/esprima")
+//   });
+//
+import { getOption } from "../lib/util.mjs";
+import * as esprima from "esprima";
+export function parse(source, options) {
+    const comments = [];
+    const ast = esprima.parse(source, {
+        loc: true,
+        // @ts-expect-error
+        locations: true,
+        comment: true,
+        onComment: comments,
+        range: getOption(options, "range", false),
+        tolerant: getOption(options, "tolerant", true),
+        tokens: true,
+        jsx: getOption(options, "jsx", false),
+        sourceType: getOption(options, "sourceType", "module"),
+    });
+    if (!Array.isArray(ast.comments)) {
+        ast.comments = comments;
+    }
+    return ast;
+}
diff --git a/node_modules/recast/esm/parsers/flow.d.ts b/node_modules/recast/esm/parsers/flow.d.ts
new file mode 100644
index 0000000..0a65345
--- /dev/null
+++ b/node_modules/recast/esm/parsers/flow.d.ts
@@ -0,0 +1,2 @@
+import { Overrides } from "./_babel_options.js";
+export declare function parse(source: string, options?: Overrides): import("@babel/parser").ParseResult<import("@babel/types").File>;
diff --git a/node_modules/recast/esm/parsers/flow.mjs b/node_modules/recast/esm/parsers/flow.mjs
new file mode 100644
index 0000000..e85f141
--- /dev/null
+++ b/node_modules/recast/esm/parsers/flow.mjs
@@ -0,0 +1,14 @@
+import { parser } from "./babel.mjs";
+import getBabelOptions from "./_babel_options.mjs";
+// This module is suitable for passing as options.parser when calling
+// recast.parse to process Flow code:
+//
+//   const ast = recast.parse(source, {
+//     parser: require("recast/parsers/flow")
+//   });
+//
+export function parse(source, options) {
+    const babelOptions = getBabelOptions(options);
+    babelOptions.plugins.push("jsx", "flow");
+    return parser.parse(source, babelOptions);
+}
diff --git a/node_modules/recast/esm/parsers/typescript.d.ts b/node_modules/recast/esm/parsers/typescript.d.ts
new file mode 100644
index 0000000..0a65345
--- /dev/null
+++ b/node_modules/recast/esm/parsers/typescript.d.ts
@@ -0,0 +1,2 @@
+import { Overrides } from "./_babel_options.js";
+export declare function parse(source: string, options?: Overrides): import("@babel/parser").ParseResult<import("@babel/types").File>;
diff --git a/node_modules/recast/esm/parsers/typescript.mjs b/node_modules/recast/esm/parsers/typescript.mjs
new file mode 100644
index 0000000..bcd4667
--- /dev/null
+++ b/node_modules/recast/esm/parsers/typescript.mjs
@@ -0,0 +1,14 @@
+import { parser } from "./babel.mjs";
+import getBabelOptions from "./_babel_options.mjs";
+// This module is suitable for passing as options.parser when calling
+// recast.parse to process TypeScript code:
+//
+//   const ast = recast.parse(source, {
+//     parser: require("recast/parsers/typescript")
+//   });
+//
+export function parse(source, options) {
+    const babelOptions = getBabelOptions(options);
+    babelOptions.plugins.push("typescript");
+    return parser.parse(source, babelOptions);
+}
diff --git a/node_modules/recast/lib/comments.js b/node_modules/recast/lib/comments.js
index 6c171c4..6a0d64f 100644
--- a/node_modules/recast/lib/comments.js
+++ b/node_modules/recast/lib/comments.js
@@ -7,8 +7,8 @@ var types = tslib_1.__importStar(require("ast-types"));
 var n = types.namedTypes;
 var isArray = types.builtInTypes.array;
 var isObject = types.builtInTypes.object;
-var lines_1 = require("./lines");
-var util_1 = require("./util");
+var lines_js_1 = require("./lines.js");
+var util_js_1 = require("./util.js");
 var childNodesCache = new WeakMap();
 // TODO Move a non-caching implementation of this function into ast-types,
 // and implement a caching wrapper function here.
@@ -20,7 +20,7 @@ function getSortedChildNodes(node, lines, resultArray) {
     // are fixed by this utility function. Specifically, if it decides to
     // set node.loc to null, indicating that the node's .loc information
     // is unreliable, then we don't want to add node to the resultArray.
-    (0, util_1.fixFaultyLocations)(node, lines);
+    (0, util_js_1.fixFaultyLocations)(node, lines);
     if (resultArray) {
         if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {
             // This reverse insertion sort almost always takes constant
@@ -31,7 +31,7 @@ function getSortedChildNodes(node, lines, resultArray) {
                 var child = resultArray[i];
                 if (child &&
                     child.loc &&
-                    (0, util_1.comparePos)(child.loc.end, node.loc.start) <= 0) {
+                    (0, util_js_1.comparePos)(child.loc.end, node.loc.start) <= 0) {
                     break;
                 }
             }
@@ -76,13 +76,13 @@ function decorateComment(node, comment, lines) {
     while (typeof right === "number" && left < right) {
         var middle = (left + right) >> 1;
         var child = childNodes[middle];
-        if ((0, util_1.comparePos)(child.loc.start, comment.loc.start) <= 0 &&
-            (0, util_1.comparePos)(comment.loc.end, child.loc.end) <= 0) {
+        if ((0, util_js_1.comparePos)(child.loc.start, comment.loc.start) <= 0 &&
+            (0, util_js_1.comparePos)(comment.loc.end, child.loc.end) <= 0) {
             // The comment is completely contained by this child node.
             decorateComment((comment.enclosingNode = child), comment, lines);
             return; // Abandon the binary search at this level.
         }
-        if ((0, util_1.comparePos)(child.loc.end, comment.loc.start) <= 0) {
+        if ((0, util_js_1.comparePos)(child.loc.end, comment.loc.start) <= 0) {
             // This child node falls completely before the comment.
             // Because we will never consider this node or any nodes
             // before it again, this node must be the closest preceding
@@ -91,7 +91,7 @@ function decorateComment(node, comment, lines) {
             left = middle + 1;
             continue;
         }
-        if ((0, util_1.comparePos)(comment.loc.end, child.loc.start) <= 0) {
+        if ((0, util_js_1.comparePos)(comment.loc.end, child.loc.start) <= 0) {
             // This child node falls completely after the comment.
             // Because we will never consider this node or any nodes after
             // it again, this node must be the closest following node we
@@ -241,7 +241,7 @@ function printLeadingComment(commentPath, print) {
         // want to bring any trailing spaces along.
         parts.push("\n");
     }
-    else if (lines instanceof lines_1.Lines) {
+    else if (lines instanceof lines_js_1.Lines) {
         var trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end) || lines.lastPos());
         if (trailingSpace.length === 1) {
             // If the trailing space contains no newlines, then we want to
@@ -257,7 +257,7 @@ function printLeadingComment(commentPath, print) {
     else {
         parts.push("\n");
     }
-    return (0, lines_1.concat)(parts);
+    return (0, lines_js_1.concat)(parts);
 }
 function printTrailingComment(commentPath, print) {
     var comment = commentPath.getValue(commentPath);
@@ -265,7 +265,7 @@ function printTrailingComment(commentPath, print) {
     var loc = comment.loc;
     var lines = loc && loc.lines;
     var parts = [];
-    if (lines instanceof lines_1.Lines) {
+    if (lines instanceof lines_js_1.Lines) {
         var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();
         var leadingSpace = lines.slice(fromPos, loc.start);
         if (leadingSpace.length === 1) {
@@ -280,7 +280,7 @@ function printTrailingComment(commentPath, print) {
         }
     }
     parts.push(print(commentPath));
-    return (0, lines_1.concat)(parts);
+    return (0, lines_js_1.concat)(parts);
 }
 function printComments(path, print) {
     var value = path.getValue();
@@ -307,6 +307,6 @@ function printComments(path, print) {
         }
     }, "comments");
     leadingParts.push.apply(leadingParts, trailingParts);
-    return (0, lines_1.concat)(leadingParts);
+    return (0, lines_js_1.concat)(leadingParts);
 }
 exports.printComments = printComments;
diff --git a/node_modules/recast/lib/comments.ts b/node_modules/recast/lib/comments.ts
new file mode 100644
index 0000000..943c9bc
--- /dev/null
+++ b/node_modules/recast/lib/comments.ts
@@ -0,0 +1,371 @@
+import assert from "assert";
+import * as types from "ast-types";
+const n = types.namedTypes;
+const isArray = types.builtInTypes.array;
+const isObject = types.builtInTypes.object;
+import { Lines, concat } from "./lines.js";
+import { comparePos, fixFaultyLocations } from "./util.js";
+
+type Node = types.namedTypes.Node;
+type Comment = types.namedTypes.Comment;
+
+const childNodesCache = new WeakMap<Node, Node[]>();
+
+// TODO Move a non-caching implementation of this function into ast-types,
+// and implement a caching wrapper function here.
+function getSortedChildNodes(node: Node, lines: Lines, resultArray?: Node[]) {
+  if (!node) {
+    return resultArray;
+  }
+
+  // The .loc checks below are sensitive to some of the problems that
+  // are fixed by this utility function. Specifically, if it decides to
+  // set node.loc to null, indicating that the node's .loc information
+  // is unreliable, then we don't want to add node to the resultArray.
+  fixFaultyLocations(node, lines);
+
+  if (resultArray) {
+    if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {
+      // This reverse insertion sort almost always takes constant
+      // time because we almost always (maybe always?) append the
+      // nodes in order anyway.
+      let i = resultArray.length - 1;
+      for (; i >= 0; --i) {
+        const child = resultArray[i];
+        if (
+          child &&
+          child.loc &&
+          comparePos(child.loc.end, node.loc.start) <= 0
+        ) {
+          break;
+        }
+      }
+      resultArray.splice(i + 1, 0, node);
+      return resultArray;
+    }
+  } else {
+    const childNodes = childNodesCache.get(node);
+    if (childNodes) {
+      return childNodes;
+    }
+  }
+
+  let names: string[];
+  if (isArray.check(node)) {
+    names = Object.keys(node);
+  } else if (isObject.check(node)) {
+    names = types.getFieldNames(node);
+  } else {
+    return resultArray;
+  }
+
+  if (!resultArray) {
+    childNodesCache.set(node, (resultArray = []));
+  }
+
+  for (let i = 0, nameCount = names.length; i < nameCount; ++i) {
+    getSortedChildNodes((node as any)[names[i]], lines, resultArray);
+  }
+
+  return resultArray;
+}
+
+// As efficiently as possible, decorate the comment object with
+// .precedingNode, .enclosingNode, and/or .followingNode properties, at
+// least one of which is guaranteed to be defined.
+function decorateComment(node: Node, comment: Comment, lines: Lines) {
+  const childNodes = getSortedChildNodes(node, lines);
+
+  // Time to dust off the old binary search robes and wizard hat.
+  let left = 0;
+  let right = childNodes && childNodes.length;
+  let precedingNode: Node | undefined;
+  let followingNode: Node | undefined;
+
+  while (typeof right === "number" && left < right) {
+    const middle = (left + right) >> 1;
+    const child = childNodes![middle];
+
+    if (
+      comparePos(child.loc!.start, comment.loc!.start) <= 0 &&
+      comparePos(comment.loc!.end, child.loc!.end) <= 0
+    ) {
+      // The comment is completely contained by this child node.
+      decorateComment(((comment as any).enclosingNode = child), comment, lines);
+      return; // Abandon the binary search at this level.
+    }
+
+    if (comparePos(child.loc!.end, comment.loc!.start) <= 0) {
+      // This child node falls completely before the comment.
+      // Because we will never consider this node or any nodes
+      // before it again, this node must be the closest preceding
+      // node we have encountered so far.
+      precedingNode = child;
+      left = middle + 1;
+      continue;
+    }
+
+    if (comparePos(comment.loc!.end, child.loc!.start) <= 0) {
+      // This child node falls completely after the comment.
+      // Because we will never consider this node or any nodes after
+      // it again, this node must be the closest following node we
+      // have encountered so far.
+      followingNode = child;
+      right = middle;
+      continue;
+    }
+
+    throw new Error("Comment location overlaps with node location");
+  }
+
+  if (precedingNode) {
+    (comment as any).precedingNode = precedingNode;
+  }
+
+  if (followingNode) {
+    (comment as any).followingNode = followingNode;
+  }
+}
+
+export function attach(comments: any[], ast: any, lines: any) {
+  if (!isArray.check(comments)) {
+    return;
+  }
+
+  const tiesToBreak: any[] = [];
+
+  comments.forEach(function (comment) {
+    comment.loc.lines = lines;
+    decorateComment(ast, comment, lines);
+
+    const pn = comment.precedingNode;
+    const en = comment.enclosingNode;
+    const fn = comment.followingNode;
+
+    if (pn && fn) {
+      const tieCount = tiesToBreak.length;
+      if (tieCount > 0) {
+        const lastTie = tiesToBreak[tieCount - 1];
+
+        assert.strictEqual(
+          lastTie.precedingNode === comment.precedingNode,
+          lastTie.followingNode === comment.followingNode,
+        );
+
+        if (lastTie.followingNode !== comment.followingNode) {
+          breakTies(tiesToBreak, lines);
+        }
+      }
+
+      tiesToBreak.push(comment);
+    } else if (pn) {
+      // No contest: we have a trailing comment.
+      breakTies(tiesToBreak, lines);
+      addTrailingComment(pn, comment);
+    } else if (fn) {
+      // No contest: we have a leading comment.
+      breakTies(tiesToBreak, lines);
+      addLeadingComment(fn, comment);
+    } else if (en) {
+      // The enclosing node has no child nodes at all, so what we
+      // have here is a dangling comment, e.g. [/* crickets */].
+      breakTies(tiesToBreak, lines);
+      addDanglingComment(en, comment);
+    } else {
+      throw new Error("AST contains no nodes at all?");
+    }
+  });
+
+  breakTies(tiesToBreak, lines);
+
+  comments.forEach(function (comment) {
+    // These node references were useful for breaking ties, but we
+    // don't need them anymore, and they create cycles in the AST that
+    // may lead to infinite recursion if we don't delete them here.
+    delete comment.precedingNode;
+    delete comment.enclosingNode;
+    delete comment.followingNode;
+  });
+}
+
+function breakTies(tiesToBreak: any[], lines: any) {
+  const tieCount = tiesToBreak.length;
+  if (tieCount === 0) {
+    return;
+  }
+
+  const pn = tiesToBreak[0].precedingNode;
+  const fn = tiesToBreak[0].followingNode;
+  let gapEndPos = fn.loc.start;
+
+  // Iterate backwards through tiesToBreak, examining the gaps
+  // between the tied comments. In order to qualify as leading, a
+  // comment must be separated from fn by an unbroken series of
+  // whitespace-only gaps (or other comments).
+  let indexOfFirstLeadingComment = tieCount;
+  let comment;
+  for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
+    comment = tiesToBreak[indexOfFirstLeadingComment - 1];
+    assert.strictEqual(comment.precedingNode, pn);
+    assert.strictEqual(comment.followingNode, fn);
+
+    const gap = lines.sliceString(comment.loc.end, gapEndPos);
+    if (/\S/.test(gap)) {
+      // The gap string contained something other than whitespace.
+      break;
+    }
+
+    gapEndPos = comment.loc.start;
+  }
+
+  while (
+    indexOfFirstLeadingComment <= tieCount &&
+    (comment = tiesToBreak[indexOfFirstLeadingComment]) &&
+    // If the comment is a //-style comment and indented more
+    // deeply than the node itself, reconsider it as trailing.
+    (comment.type === "Line" || comment.type === "CommentLine") &&
+    comment.loc.start.column > fn.loc.start.column
+  ) {
+    ++indexOfFirstLeadingComment;
+  }
+
+  if (indexOfFirstLeadingComment) {
+    const { enclosingNode } = tiesToBreak[indexOfFirstLeadingComment - 1];
+
+    if (enclosingNode?.type === "CallExpression") {
+      --indexOfFirstLeadingComment;
+    }
+  }
+
+  tiesToBreak.forEach(function (comment, i) {
+    if (i < indexOfFirstLeadingComment) {
+      addTrailingComment(pn, comment);
+    } else {
+      addLeadingComment(fn, comment);
+    }
+  });
+
+  tiesToBreak.length = 0;
+}
+
+function addCommentHelper(node: any, comment: any) {
+  const comments = node.comments || (node.comments = []);
+  comments.push(comment);
+}
+
+function addLeadingComment(node: any, comment: any) {
+  comment.leading = true;
+  comment.trailing = false;
+  addCommentHelper(node, comment);
+}
+
+function addDanglingComment(node: any, comment: any) {
+  comment.leading = false;
+  comment.trailing = false;
+  addCommentHelper(node, comment);
+}
+
+function addTrailingComment(node: any, comment: any) {
+  comment.leading = false;
+  comment.trailing = true;
+  addCommentHelper(node, comment);
+}
+
+function printLeadingComment(commentPath: any, print: any) {
+  const comment = commentPath.getValue();
+  n.Comment.assert(comment);
+
+  const loc = comment.loc;
+  const lines = loc && loc.lines;
+  const parts = [print(commentPath)];
+
+  if (comment.trailing) {
+    // When we print trailing comments as leading comments, we don't
+    // want to bring any trailing spaces along.
+    parts.push("\n");
+  } else if (lines instanceof Lines) {
+    const trailingSpace = lines.slice(
+      loc.end,
+      lines.skipSpaces(loc.end) || lines.lastPos(),
+    );
+
+    if (trailingSpace.length === 1) {
+      // If the trailing space contains no newlines, then we want to
+      // preserve it exactly as we found it.
+      parts.push(trailingSpace);
+    } else {
+      // If the trailing space contains newlines, then replace it
+      // with just that many newlines, with all other spaces removed.
+      parts.push(new Array(trailingSpace.length).join("\n"));
+    }
+  } else {
+    parts.push("\n");
+  }
+
+  return concat(parts);
+}
+
+function printTrailingComment(commentPath: any, print: any) {
+  const comment = commentPath.getValue(commentPath);
+  n.Comment.assert(comment);
+
+  const loc = comment.loc;
+  const lines = loc && loc.lines;
+  const parts = [];
+
+  if (lines instanceof Lines) {
+    const fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();
+    const leadingSpace = lines.slice(fromPos, loc.start);
+
+    if (leadingSpace.length === 1) {
+      // If the leading space contains no newlines, then we want to
+      // preserve it exactly as we found it.
+      parts.push(leadingSpace);
+    } else {
+      // If the leading space contains newlines, then replace it
+      // with just that many newlines, sans all other spaces.
+      parts.push(new Array(leadingSpace.length).join("\n"));
+    }
+  }
+
+  parts.push(print(commentPath));
+
+  return concat(parts);
+}
+
+export function printComments(path: any, print: any) {
+  const value = path.getValue();
+  const innerLines = print(path);
+  const comments =
+    n.Node.check(value) && types.getFieldValue(value, "comments");
+
+  if (!comments || comments.length === 0) {
+    return innerLines;
+  }
+
+  const leadingParts: any[] = [];
+  const trailingParts = [innerLines];
+
+  path.each(function (commentPath: any) {
+    const comment = commentPath.getValue();
+    const leading = types.getFieldValue(comment, "leading");
+    const trailing = types.getFieldValue(comment, "trailing");
+
+    if (
+      leading ||
+      (trailing &&
+        !(
+          n.Statement.check(value) ||
+          comment.type === "Block" ||
+          comment.type === "CommentBlock"
+        ))
+    ) {
+      leadingParts.push(printLeadingComment(commentPath, print));
+    } else if (trailing) {
+      trailingParts.push(printTrailingComment(commentPath, print));
+    }
+  }, "comments");
+
+  leadingParts.push.apply(leadingParts, trailingParts);
+  return concat(leadingParts);
+}
diff --git a/node_modules/recast/lib/fast-path.js b/node_modules/recast/lib/fast-path.js
index aaa70b0..279e468 100644
--- a/node_modules/recast/lib/fast-path.js
+++ b/node_modules/recast/lib/fast-path.js
@@ -3,7 +3,7 @@ Object.defineProperty(exports, "__esModule", { value: true });
 var tslib_1 = require("tslib");
 var assert_1 = tslib_1.__importDefault(require("assert"));
 var types = tslib_1.__importStar(require("ast-types"));
-var util = tslib_1.__importStar(require("./util"));
+var util = tslib_1.__importStar(require("./util.js"));
 var n = types.namedTypes;
 var isArray = types.builtInTypes.array;
 var isNumber = types.builtInTypes.number;
diff --git a/node_modules/recast/lib/fast-path.ts b/node_modules/recast/lib/fast-path.ts
new file mode 100644
index 0000000..f1ef1f8
--- /dev/null
+++ b/node_modules/recast/lib/fast-path.ts
@@ -0,0 +1,693 @@
+import assert from "assert";
+import * as types from "ast-types";
+import * as util from "./util.js";
+
+const n = types.namedTypes;
+const isArray = types.builtInTypes.array;
+const isNumber = types.builtInTypes.number;
+
+const PRECEDENCE: any = {};
+[
+  ["??"],
+  ["||"],
+  ["&&"],
+  ["|"],
+  ["^"],
+  ["&"],
+  ["==", "===", "!=", "!=="],
+  ["<", ">", "<=", ">=", "in", "instanceof"],
+  [">>", "<<", ">>>"],
+  ["+", "-"],
+  ["*", "/", "%"],
+  ["**"],
+].forEach(function (tier, i) {
+  tier.forEach(function (op) {
+    PRECEDENCE[op] = i;
+  });
+});
+
+interface FastPathType {
+  stack: any[];
+  copy(): any;
+  getName(): any;
+  getValue(): any;
+  valueIsDuplicate(): any;
+  getNode(count?: number): any;
+  getParentNode(count?: number): any;
+  getRootValue(): any;
+  call(callback: any, ...names: any[]): any;
+  each(callback: any, ...names: any[]): any;
+  map(callback: any, ...names: any[]): any;
+  hasParens(): any;
+  getPrevToken(node: any): any;
+  getNextToken(node: any): any;
+  needsParens(assumeExpressionContext?: boolean): any;
+  canBeFirstInStatement(): any;
+  firstInStatement(): any;
+}
+
+interface FastPathConstructor {
+  new (value: any): FastPathType;
+  from(obj: any): any;
+}
+
+const FastPath = function FastPath(this: FastPathType, value: any) {
+  assert.ok(this instanceof FastPath);
+  this.stack = [value];
+} as any as FastPathConstructor;
+
+const FPp: FastPathType = FastPath.prototype;
+
+// Static convenience function for coercing a value to a FastPath.
+FastPath.from = function (obj) {
+  if (obj instanceof FastPath) {
+    // Return a defensive copy of any existing FastPath instances.
+    return obj.copy();
+  }
+
+  if (obj instanceof types.NodePath) {
+    // For backwards compatibility, unroll NodePath instances into
+    // lightweight FastPath [..., name, value] stacks.
+    const copy = Object.create(FastPath.prototype);
+    const stack = [obj.value];
+    for (let pp; (pp = obj.parentPath); obj = pp)
+      stack.push(obj.name, pp.value);
+    copy.stack = stack.reverse();
+    return copy;
+  }
+
+  // Otherwise use obj as the value of the new FastPath instance.
+  return new FastPath(obj);
+};
+
+FPp.copy = function copy() {
+  const copy = Object.create(FastPath.prototype);
+  copy.stack = this.stack.slice(0);
+  return copy;
+};
+
+// The name of the current property is always the penultimate element of
+// this.stack, and always a String.
+FPp.getName = function getName() {
+  const s = this.stack;
+  const len = s.length;
+  if (len > 1) {
+    return s[len - 2];
+  }
+  // Since the name is always a string, null is a safe sentinel value to
+  // return if we do not know the name of the (root) value.
+  return null;
+};
+
+// The value of the current property is always the final element of
+// this.stack.
+FPp.getValue = function getValue() {
+  const s = this.stack;
+  return s[s.length - 1];
+};
+
+FPp.valueIsDuplicate = function () {
+  const s = this.stack;
+  const valueIndex = s.length - 1;
+  return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;
+};
+
+function getNodeHelper(path: any, count: number) {
+  const s = path.stack;
+
+  for (let i = s.length - 1; i >= 0; i -= 2) {
+    const value = s[i];
+    if (n.Node.check(value) && --count < 0) {
+      return value;
+    }
+  }
+
+  return null;
+}
+
+FPp.getNode = function getNode(count = 0) {
+  return getNodeHelper(this, ~~count);
+};
+
+FPp.getParentNode = function getParentNode(count = 0) {
+  return getNodeHelper(this, ~~count + 1);
+};
+
+// The length of the stack can be either even or odd, depending on whether
+// or not we have a name for the root value. The difference between the
+// index of the root value and the index of the final value is always
+// even, though, which allows us to return the root value in constant time
+// (i.e. without iterating backwards through the stack).
+FPp.getRootValue = function getRootValue() {
+  const s = this.stack;
+  if (s.length % 2 === 0) {
+    return s[1];
+  }
+  return s[0];
+};
+
+// Temporarily push properties named by string arguments given after the
+// callback function onto this.stack, then call the callback with a
+// reference to this (modified) FastPath object. Note that the stack will
+// be restored to its original state after the callback is finished, so it
+// is probably a mistake to retain a reference to the path.
+FPp.call = function call(callback /*, name1, name2, ... */) {
+  const s = this.stack;
+  const origLen = s.length;
+  let value = s[origLen - 1];
+  const argc = arguments.length;
+  for (let i = 1; i < argc; ++i) {
+    const name = arguments[i];
+    value = value[name];
+    s.push(name, value);
+  }
+  const result = callback(this);
+  s.length = origLen;
+  return result;
+};
+
+// Similar to FastPath.prototype.call, except that the value obtained by
+// accessing this.getValue()[name1][name2]... should be array-like. The
+// callback will be called with a reference to this path object for each
+// element of the array.
+FPp.each = function each(callback /*, name1, name2, ... */) {
+  const s = this.stack;
+  const origLen = s.length;
+  let value = s[origLen - 1];
+  const argc = arguments.length;
+
+  for (let i = 1; i < argc; ++i) {
+    const name = arguments[i];
+    value = value[name];
+    s.push(name, value);
+  }
+
+  for (let i = 0; i < value.length; ++i) {
+    if (i in value) {
+      s.push(i, value[i]);
+      // If the callback needs to know the value of i, call
+      // path.getName(), assuming path is the parameter name.
+      callback(this);
+      s.length -= 2;
+    }
+  }
+
+  s.length = origLen;
+};
+
+// Similar to FastPath.prototype.each, except that the results of the
+// callback function invocations are stored in an array and returned at
+// the end of the iteration.
+FPp.map = function map(callback /*, name1, name2, ... */) {
+  const s = this.stack;
+  const origLen = s.length;
+  let value = s[origLen - 1];
+  const argc = arguments.length;
+
+  for (let i = 1; i < argc; ++i) {
+    const name = arguments[i];
+    value = value[name];
+    s.push(name, value);
+  }
+
+  const result = new Array(value.length);
+
+  for (let i = 0; i < value.length; ++i) {
+    if (i in value) {
+      s.push(i, value[i]);
+      result[i] = callback(this, i);
+      s.length -= 2;
+    }
+  }
+
+  s.length = origLen;
+
+  return result;
+};
+
+// Returns true if the node at the tip of the path is wrapped with
+// parentheses, OR if the only reason the node needed parentheses was that
+// it couldn't be the first expression in the enclosing statement (see
+// FastPath#canBeFirstInStatement), and it has an opening `(` character.
+// For example, the FunctionExpression in `(function(){}())` appears to
+// need parentheses only because it's the first expression in the AST, but
+// since it happens to be preceded by a `(` (which is not apparent from
+// the AST but can be determined using FastPath#getPrevToken), there is no
+// ambiguity about how to parse it, so it counts as having parentheses,
+// even though it is not immediately followed by a `)`.
+FPp.hasParens = function () {
+  const node = this.getNode();
+
+  const prevToken = this.getPrevToken(node);
+  if (!prevToken) {
+    return false;
+  }
+
+  const nextToken = this.getNextToken(node);
+  if (!nextToken) {
+    return false;
+  }
+
+  if (prevToken.value === "(") {
+    if (nextToken.value === ")") {
+      // If the node preceded by a `(` token and followed by a `)` token,
+      // then of course it has parentheses.
+      return true;
+    }
+
+    // If this is one of the few Expression types that can't come first in
+    // the enclosing statement because of parsing ambiguities (namely,
+    // FunctionExpression, ObjectExpression, and ClassExpression) and
+    // this.firstInStatement() returns true, and the node would not need
+    // parentheses in an expression context because this.needsParens(true)
+    // returns false, then it just needs an opening parenthesis to resolve
+    // the parsing ambiguity that made it appear to need parentheses.
+    const justNeedsOpeningParen =
+      !this.canBeFirstInStatement() &&
+      this.firstInStatement() &&
+      !this.needsParens(true);
+
+    if (justNeedsOpeningParen) {
+      return true;
+    }
+  }
+
+  return false;
+};
+
+FPp.getPrevToken = function (node) {
+  node = node || this.getNode();
+  const loc = node && node.loc;
+  const tokens = loc && loc.tokens;
+  if (tokens && loc.start.token > 0) {
+    const token = tokens[loc.start.token - 1];
+    if (token) {
+      // Do not return tokens that fall outside the root subtree.
+      const rootLoc = this.getRootValue().loc;
+      if (util.comparePos(rootLoc.start, token.loc.start) <= 0) {
+        return token;
+      }
+    }
+  }
+  return null;
+};
+
+FPp.getNextToken = function (node) {
+  node = node || this.getNode();
+  const loc = node && node.loc;
+  const tokens = loc && loc.tokens;
+  if (tokens && loc.end.token < tokens.length) {
+    const token = tokens[loc.end.token];
+    if (token) {
+      // Do not return tokens that fall outside the root subtree.
+      const rootLoc = this.getRootValue().loc;
+      if (util.comparePos(token.loc.end, rootLoc.end) <= 0) {
+        return token;
+      }
+    }
+  }
+  return null;
+};
+
+// Inspired by require("ast-types").NodePath.prototype.needsParens, but
+// more efficient because we're iterating backwards through a stack.
+FPp.needsParens = function (assumeExpressionContext) {
+  const node = this.getNode();
+
+  // This needs to come before `if (!parent) { return false }` because
+  // an object destructuring assignment requires parens for
+  // correctness even when it's the topmost expression.
+  if (
+    node.type === "AssignmentExpression" &&
+    node.left.type === "ObjectPattern"
+  ) {
+    return true;
+  }
+
+  const parent = this.getParentNode();
+
+  const name = this.getName();
+
+  // If the value of this path is some child of a Node and not a Node
+  // itself, then it doesn't need parentheses. Only Node objects (in fact,
+  // only Expression nodes) need parentheses.
+  if (this.getValue() !== node) {
+    return false;
+  }
+
+  // Only statements don't need parentheses.
+  if (n.Statement.check(node)) {
+    return false;
+  }
+
+  // Identifiers never need parentheses.
+  if (node.type === "Identifier") {
+    return false;
+  }
+
+  if (parent && parent.type === "ParenthesizedExpression") {
+    return false;
+  }
+
+  if (node.extra && node.extra.parenthesized) {
+    return true;
+  }
+
+  if (!parent) return false;
+
+  switch (node.type) {
+    case "UnaryExpression":
+    case "SpreadElement":
+    case "SpreadProperty":
+      return (
+        parent.type === "MemberExpression" &&
+        name === "object" &&
+        parent.object === node
+      );
+
+    case "BinaryExpression":
+    case "LogicalExpression":
+      switch (parent.type) {
+        case "CallExpression":
+          return name === "callee" && parent.callee === node;
+
+        case "UnaryExpression":
+        case "SpreadElement":
+        case "SpreadProperty":
+          return true;
+
+        case "MemberExpression":
+          return name === "object" && parent.object === node;
+
+        case "BinaryExpression":
+        case "LogicalExpression": {
+          const po = parent.operator;
+          const pp = PRECEDENCE[po];
+          const no = node.operator;
+          const np = PRECEDENCE[no];
+
+          if (pp > np) {
+            return true;
+          }
+
+          if (pp === np && name === "right") {
+            assert.strictEqual(parent.right, node);
+            return true;
+          }
+
+          break;
+        }
+
+        default:
+          return false;
+      }
+
+      break;
+
+    case "SequenceExpression":
+      switch (parent.type) {
+        case "ReturnStatement":
+          return false;
+
+        case "ForStatement":
+          // Although parentheses wouldn't hurt around sequence expressions in
+          // the head of for loops, traditional style dictates that e.g. i++,
+          // j++ should not be wrapped with parentheses.
+          return false;
+
+        case "ExpressionStatement":
+          return name !== "expression";
+
+        default:
+          // Otherwise err on the side of overparenthesization, adding
+          // explicit exceptions above if this proves overzealous.
+          return true;
+      }
+
+    case "OptionalIndexedAccessType":
+      return node.optional && parent.type === "IndexedAccessType";
+
+    case "IntersectionTypeAnnotation":
+    case "UnionTypeAnnotation":
+      return parent.type === "NullableTypeAnnotation";
+
+    case "Literal":
+      return (
+        parent.type === "MemberExpression" &&
+        isNumber.check(node.value) &&
+        name === "object" &&
+        parent.object === node
+      );
+
+    // Babel 6 Literal split
+    case "NumericLiteral":
+      return (
+        parent.type === "MemberExpression" &&
+        name === "object" &&
+        parent.object === node
+      );
+
+    case "YieldExpression":
+    case "AwaitExpression":
+    case "AssignmentExpression":
+    case "ConditionalExpression":
+      switch (parent.type) {
+        case "UnaryExpression":
+        case "SpreadElement":
+        case "SpreadProperty":
+        case "BinaryExpression":
+        case "LogicalExpression":
+          return true;
+
+        case "CallExpression":
+        case "NewExpression":
+          return name === "callee" && parent.callee === node;
+
+        case "ConditionalExpression":
+          return name === "test" && parent.test === node;
+
+        case "MemberExpression":
+          return name === "object" && parent.object === node;
+
+        default:
+          return false;
+      }
+
+    case "ArrowFunctionExpression":
+      if (
+        n.CallExpression.check(parent) &&
+        name === "callee" &&
+        parent.callee === node
+      ) {
+        return true;
+      }
+
+      if (
+        n.MemberExpression.check(parent) &&
+        name === "object" &&
+        parent.object === node
+      ) {
+        return true;
+      }
+
+      if (
+        n.TSAsExpression &&
+        n.TSAsExpression.check(parent) &&
+        name === "expression" &&
+        parent.expression === node
+      ) {
+        return true;
+      }
+
+      return isBinary(parent);
+
+    case "ObjectExpression":
+      if (
+        parent.type === "ArrowFunctionExpression" &&
+        name === "body" &&
+        parent.body === node
+      ) {
+        return true;
+      }
+
+      break;
+
+    case "TSAsExpression":
+      if (
+        parent.type === "ArrowFunctionExpression" &&
+        name === "body" &&
+        parent.body === node &&
+        node.expression.type === "ObjectExpression"
+      ) {
+        return true;
+      }
+      break;
+
+    case "CallExpression":
+      if (
+        name === "declaration" &&
+        n.ExportDefaultDeclaration.check(parent) &&
+        n.FunctionExpression.check(node.callee)
+      ) {
+        return true;
+      }
+  }
+
+  if (
+    parent.type === "NewExpression" &&
+    name === "callee" &&
+    parent.callee === node
+  ) {
+    return containsCallExpression(node);
+  }
+
+  if (
+    assumeExpressionContext !== true &&
+    !this.canBeFirstInStatement() &&
+    this.firstInStatement()
+  ) {
+    return true;
+  }
+
+  return false;
+};
+
+function isBinary(node: any) {
+  return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);
+}
+
+// @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]
+function isUnaryLike(node: any) {
+  return (
+    n.UnaryExpression.check(node) ||
+    // I considered making SpreadElement and SpreadProperty subtypes of
+    // UnaryExpression, but they're not really Expression nodes.
+    (n.SpreadElement && n.SpreadElement.check(node)) ||
+    (n.SpreadProperty && n.SpreadProperty.check(node))
+  );
+}
+
+function containsCallExpression(node: any): any {
+  if (n.CallExpression.check(node)) {
+    return true;
+  }
+
+  if (isArray.check(node)) {
+    return node.some(containsCallExpression);
+  }
+
+  if (n.Node.check(node)) {
+    return types.someField(node, (_name: any, child: any) =>
+      containsCallExpression(child),
+    );
+  }
+
+  return false;
+}
+
+FPp.canBeFirstInStatement = function () {
+  const node = this.getNode();
+
+  if (n.FunctionExpression.check(node)) {
+    return false;
+  }
+
+  if (n.ObjectExpression.check(node)) {
+    return false;
+  }
+
+  if (n.ClassExpression.check(node)) {
+    return false;
+  }
+
+  return true;
+};
+
+FPp.firstInStatement = function () {
+  const s = this.stack;
+  let parentName, parent;
+  let childName, child;
+
+  for (let i = s.length - 1; i >= 0; i -= 2) {
+    if (n.Node.check(s[i])) {
+      childName = parentName;
+      child = parent;
+      parentName = s[i - 1];
+      parent = s[i];
+    }
+
+    if (!parent || !child) {
+      continue;
+    }
+
+    if (
+      n.BlockStatement.check(parent) &&
+      parentName === "body" &&
+      childName === 0
+    ) {
+      assert.strictEqual(parent.body[0], child);
+      return true;
+    }
+
+    if (n.ExpressionStatement.check(parent) && childName === "expression") {
+      assert.strictEqual(parent.expression, child);
+      return true;
+    }
+
+    if (n.AssignmentExpression.check(parent) && childName === "left") {
+      assert.strictEqual(parent.left, child);
+      return true;
+    }
+
+    if (n.ArrowFunctionExpression.check(parent) && childName === "body") {
+      assert.strictEqual(parent.body, child);
+      return true;
+    }
+
+    // s[i + 1] and s[i + 2] represent the array between the parent
+    // SequenceExpression node and its child nodes
+    if (
+      n.SequenceExpression.check(parent) &&
+      s[i + 1] === "expressions" &&
+      childName === 0
+    ) {
+      assert.strictEqual(parent.expressions[0], child);
+      continue;
+    }
+
+    if (n.CallExpression.check(parent) && childName === "callee") {
+      assert.strictEqual(parent.callee, child);
+      continue;
+    }
+
+    if (n.MemberExpression.check(parent) && childName === "object") {
+      assert.strictEqual(parent.object, child);
+      continue;
+    }
+
+    if (n.ConditionalExpression.check(parent) && childName === "test") {
+      assert.strictEqual(parent.test, child);
+      continue;
+    }
+
+    if (isBinary(parent) && childName === "left") {
+      assert.strictEqual(parent.left, child);
+      continue;
+    }
+
+    if (
+      n.UnaryExpression.check(parent) &&
+      !parent.prefix &&
+      childName === "argument"
+    ) {
+      assert.strictEqual(parent.argument, child);
+      continue;
+    }
+
+    return false;
+  }
+
+  return true;
+};
+
+export default FastPath;
diff --git a/node_modules/recast/lib/lines.d.ts b/node_modules/recast/lib/lines.d.ts
index 550f620..a6c2ca0 100644
--- a/node_modules/recast/lib/lines.d.ts
+++ b/node_modules/recast/lib/lines.d.ts
@@ -1,4 +1,4 @@
-import { Options } from "./options";
+import { Options } from "./options.js";
 import { namedTypes } from "ast-types";
 type Pos = namedTypes.Position;
 type LineInfo = {
diff --git a/node_modules/recast/lib/lines.js b/node_modules/recast/lib/lines.js
index 34d1114..4b91500 100644
--- a/node_modules/recast/lib/lines.js
+++ b/node_modules/recast/lib/lines.js
@@ -4,9 +4,9 @@ exports.concat = exports.fromString = exports.countSpaces = exports.Lines = void
 var tslib_1 = require("tslib");
 var assert_1 = tslib_1.__importDefault(require("assert"));
 var source_map_1 = tslib_1.__importDefault(require("source-map"));
-var options_1 = require("./options");
-var util_1 = require("./util");
-var mapping_1 = tslib_1.__importDefault(require("./mapping"));
+var options_js_1 = require("./options.js");
+var util_js_1 = require("./util.js");
+var mapping_js_1 = tslib_1.__importDefault(require("./mapping.js"));
 var Lines = /** @class */ (function () {
     function Lines(infos, sourceFileName) {
         if (sourceFileName === void 0) { sourceFileName = null; }
@@ -18,7 +18,7 @@ var Lines = /** @class */ (function () {
         this.length = infos.length;
         this.name = sourceFileName || null;
         if (this.name) {
-            this.mappings.push(new mapping_1.default(this, {
+            this.mappings.push(new mapping_js_1.default(this, {
                 start: this.firstPos(),
                 end: this.lastPos(),
             }));
@@ -57,8 +57,8 @@ var Lines = /** @class */ (function () {
                 mapping.sourceLines.lastPos();
             var targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) ||
                 targetLines.lastPos();
-            while ((0, util_1.comparePos)(sourceCursor, mapping.sourceLoc.end) < 0 &&
-                (0, util_1.comparePos)(targetCursor, mapping.targetLoc.end) < 0) {
+            while ((0, util_js_1.comparePos)(sourceCursor, mapping.sourceLoc.end) < 0 &&
+                (0, util_js_1.comparePos)(targetCursor, mapping.targetLoc.end) < 0) {
                 var sourceChar = mapping.sourceLines.charAt(sourceCursor);
                 var targetChar = targetLines.charAt(targetCursor);
                 assert_1.default.strictEqual(sourceChar, targetChar);
@@ -403,7 +403,7 @@ var Lines = /** @class */ (function () {
     Lines.prototype.sliceString = function (start, end, options) {
         if (start === void 0) { start = this.firstPos(); }
         if (end === void 0) { end = this.lastPos(); }
-        var _a = (0, options_1.normalize)(options), tabWidth = _a.tabWidth, useTabs = _a.useTabs, reuseWhitespace = _a.reuseWhitespace, lineTerminator = _a.lineTerminator;
+        var _a = (0, options_js_1.normalize)(options), tabWidth = _a.tabWidth, useTabs = _a.useTabs, reuseWhitespace = _a.reuseWhitespace, lineTerminator = _a.lineTerminator;
         var parts = [];
         for (var line = start.line; line <= end.line; ++line) {
             var info = this.infos[line - 1];
@@ -591,7 +591,7 @@ function fromString(string, options) {
             sliceStart: spaces.length,
             sliceEnd: line.length,
         };
-    }), (0, options_1.normalize)(options).sourceFileName);
+    }), (0, options_js_1.normalize)(options).sourceFileName);
     if (cacheable)
         fromStringCache[string] = lines;
     return lines;
diff --git a/node_modules/recast/lib/lines.ts b/node_modules/recast/lib/lines.ts
new file mode 100644
index 0000000..b6713f1
--- /dev/null
+++ b/node_modules/recast/lib/lines.ts
@@ -0,0 +1,857 @@
+import assert from "assert";
+import sourceMap from "source-map";
+import { normalize as normalizeOptions, Options } from "./options.js";
+import { namedTypes } from "ast-types";
+import { comparePos } from "./util.js";
+import Mapping from "./mapping.js";
+
+type Pos = namedTypes.Position;
+
+// Goals:
+// 1. Minimize new string creation.
+// 2. Keep (de)identation O(lines) time.
+// 3. Permit negative indentations.
+// 4. Enforce immutability.
+// 5. No newline characters.
+
+type LineInfo = {
+  readonly line: string;
+  readonly indent: number;
+  readonly locked: boolean;
+  readonly sliceStart: number;
+  readonly sliceEnd: number;
+};
+
+export class Lines {
+  public readonly length: number;
+  public readonly name: string | null;
+  private mappings: Mapping[] = [];
+  private cachedSourceMap: any = null;
+  private cachedTabWidth: number | void = void 0;
+
+  constructor(private infos: LineInfo[], sourceFileName: string | null = null) {
+    assert.ok(infos.length > 0);
+    this.length = infos.length;
+    this.name = sourceFileName || null;
+
+    if (this.name) {
+      this.mappings.push(
+        new Mapping(this, {
+          start: this.firstPos(),
+          end: this.lastPos(),
+        }),
+      );
+    }
+  }
+
+  toString(options?: Options) {
+    return this.sliceString(this.firstPos(), this.lastPos(), options);
+  }
+
+  getSourceMap(sourceMapName: string, sourceRoot?: string) {
+    if (!sourceMapName) {
+      // Although we could make up a name or generate an anonymous
+      // source map, instead we assume that any consumer who does not
+      // provide a name does not actually want a source map.
+      return null;
+    }
+
+    const targetLines = this;
+
+    function updateJSON(json?: any) {
+      json = json || {};
+
+      json.file = sourceMapName;
+
+      if (sourceRoot) {
+        json.sourceRoot = sourceRoot;
+      }
+
+      return json;
+    }
+
+    if (targetLines.cachedSourceMap) {
+      // Since Lines objects are immutable, we can reuse any source map
+      // that was previously generated. Nevertheless, we return a new
+      // JSON object here to protect the cached source map from outside
+      // modification.
+      return updateJSON(targetLines.cachedSourceMap.toJSON());
+    }
+
+    const smg = new sourceMap.SourceMapGenerator(updateJSON());
+    const sourcesToContents: any = {};
+
+    targetLines.mappings.forEach(function (mapping: any) {
+      const sourceCursor =
+        mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) ||
+        mapping.sourceLines.lastPos();
+
+      const targetCursor =
+        targetLines.skipSpaces(mapping.targetLoc.start) ||
+        targetLines.lastPos();
+
+      while (
+        comparePos(sourceCursor, mapping.sourceLoc.end) < 0 &&
+        comparePos(targetCursor, mapping.targetLoc.end) < 0
+      ) {
+        const sourceChar = mapping.sourceLines.charAt(sourceCursor);
+        const targetChar = targetLines.charAt(targetCursor);
+        assert.strictEqual(sourceChar, targetChar);
+
+        const sourceName = mapping.sourceLines.name;
+
+        // Add mappings one character at a time for maximum resolution.
+        smg.addMapping({
+          source: sourceName,
+          original: { line: sourceCursor.line, column: sourceCursor.column },
+          generated: { line: targetCursor.line, column: targetCursor.column },
+        });
+
+        if (!hasOwn.call(sourcesToContents, sourceName)) {
+          const sourceContent = mapping.sourceLines.toString();
+          smg.setSourceContent(sourceName, sourceContent);
+          sourcesToContents[sourceName] = sourceContent;
+        }
+
+        targetLines.nextPos(targetCursor, true);
+        mapping.sourceLines.nextPos(sourceCursor, true);
+      }
+    });
+
+    targetLines.cachedSourceMap = smg;
+
+    return (smg as any).toJSON();
+  }
+
+  bootstrapCharAt(pos: Pos) {
+    assert.strictEqual(typeof pos, "object");
+    assert.strictEqual(typeof pos.line, "number");
+    assert.strictEqual(typeof pos.column, "number");
+
+    const line = pos.line,
+      column = pos.column,
+      strings = this.toString().split(lineTerminatorSeqExp),
+      string = strings[line - 1];
+
+    if (typeof string === "undefined") return "";
+
+    if (column === string.length && line < strings.length) return "\n";
+
+    if (column >= string.length) return "";
+
+    return string.charAt(column);
+  }
+
+  charAt(pos: Pos) {
+    assert.strictEqual(typeof pos, "object");
+    assert.strictEqual(typeof pos.line, "number");
+    assert.strictEqual(typeof pos.column, "number");
+
+    let line = pos.line,
+      column = pos.column,
+      secret = this,
+      infos = secret.infos,
+      info = infos[line - 1],
+      c = column;
+
+    if (typeof info === "undefined" || c < 0) return "";
+
+    const indent = this.getIndentAt(line);
+    if (c < indent) return " ";
+
+    c += info.sliceStart - indent;
+
+    if (c === info.sliceEnd && line < this.length) return "\n";
+
+    if (c >= info.sliceEnd) return "";
+
+    return info.line.charAt(c);
+  }
+
+  stripMargin(width: number, skipFirstLine: boolean) {
+    if (width === 0) return this;
+
+    assert.ok(width > 0, "negative margin: " + width);
+
+    if (skipFirstLine && this.length === 1) return this;
+
+    const lines = new Lines(
+      this.infos.map(function (info: any, i: any) {
+        if (info.line && (i > 0 || !skipFirstLine)) {
+          info = {
+            ...info,
+            indent: Math.max(0, info.indent - width),
+          };
+        }
+        return info;
+      }),
+    );
+
+    if (this.mappings.length > 0) {
+      const newMappings = lines.mappings;
+      assert.strictEqual(newMappings.length, 0);
+      this.mappings.forEach(function (mapping: any) {
+        newMappings.push(mapping.indent(width, skipFirstLine, true));
+      });
+    }
+
+    return lines;
+  }
+
+  indent(by: number) {
+    if (by === 0) {
+      return this;
+    }
+
+    const lines = new Lines(
+      this.infos.map(function (info: any) {
+        if (info.line && !info.locked) {
+          info = {
+            ...info,
+            indent: info.indent + by,
+          };
+        }
+        return info;
+      }),
+    );
+
+    if (this.mappings.length > 0) {
+      const newMappings = lines.mappings;
+      assert.strictEqual(newMappings.length, 0);
+      this.mappings.forEach(function (mapping: any) {
+        newMappings.push(mapping.indent(by));
+      });
+    }
+
+    return lines;
+  }
+
+  indentTail(by: number) {
+    if (by === 0) {
+      return this;
+    }
+
+    if (this.length < 2) {
+      return this;
+    }
+
+    const lines = new Lines(
+      this.infos.map(function (info: any, i: any) {
+        if (i > 0 && info.line && !info.locked) {
+          info = {
+            ...info,
+            indent: info.indent + by,
+          };
+        }
+
+        return info;
+      }),
+    );
+
+    if (this.mappings.length > 0) {
+      const newMappings = lines.mappings;
+      assert.strictEqual(newMappings.length, 0);
+      this.mappings.forEach(function (mapping: any) {
+        newMappings.push(mapping.indent(by, true));
+      });
+    }
+
+    return lines;
+  }
+
+  lockIndentTail() {
+    if (this.length < 2) {
+      return this;
+    }
+
+    return new Lines(
+      this.infos.map((info: any, i: any) => ({
+        ...info,
+        locked: i > 0,
+      })),
+    );
+  }
+
+  getIndentAt(line: number) {
+    assert.ok(line >= 1, "no line " + line + " (line numbers start from 1)");
+    return Math.max(this.infos[line - 1].indent, 0);
+  }
+
+  guessTabWidth() {
+    if (typeof this.cachedTabWidth === "number") {
+      return this.cachedTabWidth;
+    }
+
+    const counts: any[] = []; // Sparse array.
+    let lastIndent = 0;
+
+    for (let line = 1, last = this.length; line <= last; ++line) {
+      const info = this.infos[line - 1];
+      const sliced = info.line.slice(info.sliceStart, info.sliceEnd);
+
+      // Whitespace-only lines don't tell us much about the likely tab
+      // width of this code.
+      if (isOnlyWhitespace(sliced)) {
+        continue;
+      }
+
+      const diff = Math.abs(info.indent - lastIndent);
+      counts[diff] = ~~counts[diff] + 1;
+      lastIndent = info.indent;
+    }
+
+    let maxCount = -1;
+    let result = 2;
+
+    for (let tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {
+      if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {
+        maxCount = counts[tabWidth];
+        result = tabWidth;
+      }
+    }
+
+    return (this.cachedTabWidth = result);
+  }
+
+  // Determine if the list of lines has a first line that starts with a //
+  // or /* comment. If this is the case, the code may need to be wrapped in
+  // parens to avoid ASI issues.
+  startsWithComment() {
+    if (this.infos.length === 0) {
+      return false;
+    }
+    const firstLineInfo = this.infos[0],
+      sliceStart = firstLineInfo.sliceStart,
+      sliceEnd = firstLineInfo.sliceEnd,
+      firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();
+    return (
+      firstLine.length === 0 ||
+      firstLine.slice(0, 2) === "//" ||
+      firstLine.slice(0, 2) === "/*"
+    );
+  }
+
+  isOnlyWhitespace() {
+    return isOnlyWhitespace(this.toString());
+  }
+
+  isPrecededOnlyByWhitespace(pos: Pos) {
+    const info = this.infos[pos.line - 1];
+    const indent = Math.max(info.indent, 0);
+
+    const diff = pos.column - indent;
+    if (diff <= 0) {
+      // If pos.column does not exceed the indentation amount, then
+      // there must be only whitespace before it.
+      return true;
+    }
+
+    const start = info.sliceStart;
+    const end = Math.min(start + diff, info.sliceEnd);
+    const prefix = info.line.slice(start, end);
+
+    return isOnlyWhitespace(prefix);
+  }
+
+  getLineLength(line: number) {
+    const info = this.infos[line - 1];
+    return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;
+  }
+
+  nextPos(pos: Pos, skipSpaces: boolean = false) {
+    const l = Math.max(pos.line, 0),
+      c = Math.max(pos.column, 0);
+
+    if (c < this.getLineLength(l)) {
+      pos.column += 1;
+
+      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
+    }
+
+    if (l < this.length) {
+      pos.line += 1;
+      pos.column = 0;
+
+      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;
+    }
+
+    return false;
+  }
+
+  prevPos(pos: Pos, skipSpaces: boolean = false) {
+    let l = pos.line,
+      c = pos.column;
+
+    if (c < 1) {
+      l -= 1;
+
+      if (l < 1) return false;
+
+      c = this.getLineLength(l);
+    } else {
+      c = Math.min(c - 1, this.getLineLength(l));
+    }
+
+    pos.line = l;
+    pos.column = c;
+
+    return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;
+  }
+
+  firstPos() {
+    // Trivial, but provided for completeness.
+    return { line: 1, column: 0 };
+  }
+
+  lastPos() {
+    return {
+      line: this.length,
+      column: this.getLineLength(this.length),
+    };
+  }
+
+  skipSpaces(
+    pos: Pos,
+    backward: boolean = false,
+    modifyInPlace: boolean = false,
+  ) {
+    if (pos) {
+      pos = modifyInPlace
+        ? pos
+        : {
+            line: pos.line,
+            column: pos.column,
+          };
+    } else if (backward) {
+      pos = this.lastPos();
+    } else {
+      pos = this.firstPos();
+    }
+
+    if (backward) {
+      while (this.prevPos(pos)) {
+        if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {
+          return pos;
+        }
+      }
+
+      return null;
+    } else {
+      while (isOnlyWhitespace(this.charAt(pos))) {
+        if (!this.nextPos(pos)) {
+          return null;
+        }
+      }
+
+      return pos;
+    }
+  }
+
+  trimLeft() {
+    const pos = this.skipSpaces(this.firstPos(), false, true);
+    return pos ? this.slice(pos) : emptyLines;
+  }
+
+  trimRight() {
+    const pos = this.skipSpaces(this.lastPos(), true, true);
+    return pos ? this.slice(this.firstPos(), pos) : emptyLines;
+  }
+
+  trim() {
+    const start = this.skipSpaces(this.firstPos(), false, true);
+    if (start === null) {
+      return emptyLines;
+    }
+
+    const end = this.skipSpaces(this.lastPos(), true, true);
+    if (end === null) {
+      return emptyLines;
+    }
+
+    return this.slice(start, end);
+  }
+
+  eachPos(
+    callback: (pos: Pos) => any,
+    startPos: Pos = this.firstPos(),
+    skipSpaces: boolean = false,
+  ) {
+    const pos = this.firstPos();
+
+    if (startPos) {
+      (pos.line = startPos.line), (pos.column = startPos.column);
+    }
+
+    if (skipSpaces && !this.skipSpaces(pos, false, true)) {
+      return; // Encountered nothing but spaces.
+    }
+
+    do callback.call(this, pos);
+    while (this.nextPos(pos, skipSpaces));
+  }
+
+  bootstrapSlice(start: Pos, end: Pos) {
+    const strings = this.toString()
+      .split(lineTerminatorSeqExp)
+      .slice(start.line - 1, end.line);
+
+    if (strings.length > 0) {
+      strings.push(strings.pop()!.slice(0, end.column));
+      strings[0] = strings[0].slice(start.column);
+    }
+
+    return fromString(strings.join("\n"));
+  }
+
+  slice(start?: Pos, end?: Pos) {
+    if (!end) {
+      if (!start) {
+        // The client seems to want a copy of this Lines object, but
+        // Lines objects are immutable, so it's perfectly adequate to
+        // return the same object.
+        return this;
+      }
+
+      // Slice to the end if no end position was provided.
+      end = this.lastPos();
+    }
+
+    if (!start) {
+      throw new Error("cannot slice with end but not start");
+    }
+
+    const sliced = this.infos.slice(start.line - 1, end.line);
+
+    if (start.line === end.line) {
+      sliced[0] = sliceInfo(sliced[0], start.column, end.column);
+    } else {
+      assert.ok(start.line < end.line);
+      sliced[0] = sliceInfo(sliced[0], start.column);
+      sliced.push(sliceInfo(sliced.pop(), 0, end.column));
+    }
+
+    const lines = new Lines(sliced);
+
+    if (this.mappings.length > 0) {
+      const newMappings = lines.mappings;
+      assert.strictEqual(newMappings.length, 0);
+      this.mappings.forEach(function (this: any, mapping: any) {
+        const sliced = mapping.slice(this, start, end);
+        if (sliced) {
+          newMappings.push(sliced);
+        }
+      }, this);
+    }
+
+    return lines;
+  }
+
+  bootstrapSliceString(start: Pos, end: Pos, options?: Options) {
+    return this.slice(start, end).toString(options);
+  }
+
+  sliceString(
+    start: Pos = this.firstPos(),
+    end: Pos = this.lastPos(),
+    options?: Options,
+  ) {
+    const { tabWidth, useTabs, reuseWhitespace, lineTerminator } =
+      normalizeOptions(options);
+
+    const parts = [];
+
+    for (let line = start.line; line <= end.line; ++line) {
+      let info = this.infos[line - 1];
+
+      if (line === start.line) {
+        if (line === end.line) {
+          info = sliceInfo(info, start.column, end.column);
+        } else {
+          info = sliceInfo(info, start.column);
+        }
+      } else if (line === end.line) {
+        info = sliceInfo(info, 0, end.column);
+      }
+
+      const indent = Math.max(info.indent, 0);
+
+      const before = info.line.slice(0, info.sliceStart);
+      if (
+        reuseWhitespace &&
+        isOnlyWhitespace(before) &&
+        countSpaces(before, tabWidth) === indent
+      ) {
+        // Reuse original spaces if the indentation is correct.
+        parts.push(info.line.slice(0, info.sliceEnd));
+        continue;
+      }
+
+      let tabs = 0;
+      let spaces = indent;
+
+      if (useTabs) {
+        tabs = Math.floor(indent / tabWidth);
+        spaces -= tabs * tabWidth;
+      }
+
+      let result = "";
+
+      if (tabs > 0) {
+        result += new Array(tabs + 1).join("\t");
+      }
+
+      if (spaces > 0) {
+        result += new Array(spaces + 1).join(" ");
+      }
+
+      result += info.line.slice(info.sliceStart, info.sliceEnd);
+
+      parts.push(result);
+    }
+
+    return parts.join(lineTerminator);
+  }
+
+  isEmpty() {
+    return this.length < 2 && this.getLineLength(1) < 1;
+  }
+
+  join(elements: (string | Lines)[]) {
+    const separator = this;
+    const infos: any[] = [];
+    const mappings: any[] = [];
+    let prevInfo: any;
+
+    function appendLines(linesOrNull: Lines | null) {
+      if (linesOrNull === null) {
+        return;
+      }
+
+      if (prevInfo) {
+        const info = linesOrNull.infos[0];
+        const indent = new Array(info.indent + 1).join(" ");
+        const prevLine = infos.length;
+        const prevColumn =
+          Math.max(prevInfo.indent, 0) +
+          prevInfo.sliceEnd -
+          prevInfo.sliceStart;
+
+        prevInfo.line =
+          prevInfo.line.slice(0, prevInfo.sliceEnd) +
+          indent +
+          info.line.slice(info.sliceStart, info.sliceEnd);
+
+        // If any part of a line is indentation-locked, the whole line
+        // will be indentation-locked.
+        prevInfo.locked = prevInfo.locked || info.locked;
+
+        prevInfo.sliceEnd = prevInfo.line.length;
+
+        if (linesOrNull.mappings.length > 0) {
+          linesOrNull.mappings.forEach(function (mapping: any) {
+            mappings.push(mapping.add(prevLine, prevColumn));
+          });
+        }
+      } else if (linesOrNull.mappings.length > 0) {
+        mappings.push.apply(mappings, linesOrNull.mappings);
+      }
+
+      linesOrNull.infos.forEach(function (info: any, i: any) {
+        if (!prevInfo || i > 0) {
+          prevInfo = { ...info };
+          infos.push(prevInfo);
+        }
+      });
+    }
+
+    function appendWithSeparator(linesOrNull: Lines | null, i: number) {
+      if (i > 0) appendLines(separator);
+      appendLines(linesOrNull);
+    }
+
+    elements
+      .map(function (elem: any) {
+        const lines = fromString(elem);
+        if (lines.isEmpty()) return null;
+        return lines;
+      })
+      .forEach((linesOrNull, i) => {
+        if (separator.isEmpty()) {
+          appendLines(linesOrNull);
+        } else {
+          appendWithSeparator(linesOrNull, i);
+        }
+      });
+
+    if (infos.length < 1) return emptyLines;
+
+    const lines = new Lines(infos);
+
+    lines.mappings = mappings;
+
+    return lines;
+  }
+
+  concat(...args: (string | Lines)[]) {
+    const list: typeof args = [this];
+    list.push.apply(list, args);
+    assert.strictEqual(list.length, args.length + 1);
+    return emptyLines.join(list);
+  }
+}
+
+const fromStringCache: any = {};
+const hasOwn = fromStringCache.hasOwnProperty;
+const maxCacheKeyLen = 10;
+
+export function countSpaces(spaces: any, tabWidth?: number) {
+  let count = 0;
+  const len = spaces.length;
+
+  for (let i = 0; i < len; ++i) {
+    switch (spaces.charCodeAt(i)) {
+      case 9: {
+        // '\t'
+        assert.strictEqual(typeof tabWidth, "number");
+        assert.ok(tabWidth! > 0);
+
+        const next = Math.ceil(count / tabWidth!) * tabWidth!;
+        if (next === count) {
+          count += tabWidth!;
+        } else {
+          count = next;
+        }
+
+        break;
+      }
+
+      case 11: // '\v'
+      case 12: // '\f'
+      case 13: // '\r'
+      case 0xfeff: // zero-width non-breaking space
+        // These characters contribute nothing to indentation.
+        break;
+
+      case 32: // ' '
+      default:
+        // Treat all other whitespace like ' '.
+        count += 1;
+        break;
+    }
+  }
+
+  return count;
+}
+
+const leadingSpaceExp = /^\s*/;
+
+// As specified here: http://www.ecma-international.org/ecma-262/6.0/#sec-line-terminators
+const lineTerminatorSeqExp =
+  /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;
+
+/**
+ * @param {Object} options - Options object that configures printing.
+ */
+export function fromString(string: string | Lines, options?: Options): Lines {
+  if (string instanceof Lines) return string;
+
+  string += "";
+
+  const tabWidth = options && options.tabWidth;
+  const tabless = string.indexOf("\t") < 0;
+  const cacheable = !options && tabless && string.length <= maxCacheKeyLen;
+
+  assert.ok(
+    tabWidth || tabless,
+    "No tab width specified but encountered tabs in string\n" + string,
+  );
+
+  if (cacheable && hasOwn.call(fromStringCache, string))
+    return fromStringCache[string];
+
+  const lines = new Lines(
+    string.split(lineTerminatorSeqExp).map(function (line) {
+      // TODO: handle null exec result
+      const spaces = leadingSpaceExp.exec(line)![0];
+      return {
+        line: line,
+        indent: countSpaces(spaces, tabWidth),
+        // Boolean indicating whether this line can be reindented.
+        locked: false,
+        sliceStart: spaces.length,
+        sliceEnd: line.length,
+      };
+    }),
+    normalizeOptions(options).sourceFileName,
+  );
+
+  if (cacheable) fromStringCache[string] = lines;
+
+  return lines;
+}
+
+function isOnlyWhitespace(string: string) {
+  return !/\S/.test(string);
+}
+
+function sliceInfo(info: any, startCol: number, endCol?: number) {
+  let sliceStart = info.sliceStart;
+  let sliceEnd = info.sliceEnd;
+  let indent = Math.max(info.indent, 0);
+  let lineLength = indent + sliceEnd - sliceStart;
+
+  if (typeof endCol === "undefined") {
+    endCol = lineLength;
+  }
+
+  startCol = Math.max(startCol, 0);
+  endCol = Math.min(endCol, lineLength);
+  endCol = Math.max(endCol, startCol);
+
+  if (endCol < indent) {
+    indent = endCol;
+    sliceEnd = sliceStart;
+  } else {
+    sliceEnd -= lineLength - endCol;
+  }
+
+  lineLength = endCol;
+  lineLength -= startCol;
+
+  if (startCol < indent) {
+    indent -= startCol;
+  } else {
+    startCol -= indent;
+    indent = 0;
+    sliceStart += startCol;
+  }
+
+  assert.ok(indent >= 0);
+  assert.ok(sliceStart <= sliceEnd);
+  assert.strictEqual(lineLength, indent + sliceEnd - sliceStart);
+
+  if (
+    info.indent === indent &&
+    info.sliceStart === sliceStart &&
+    info.sliceEnd === sliceEnd
+  ) {
+    return info;
+  }
+
+  return {
+    line: info.line,
+    indent: indent,
+    // A destructive slice always unlocks indentation.
+    locked: false,
+    sliceStart: sliceStart,
+    sliceEnd: sliceEnd,
+  };
+}
+
+export function concat(elements: any) {
+  return emptyLines.join(elements);
+}
+
+// The emptyLines object needs to be created all the way down here so that
+// Lines.prototype will be fully populated.
+const emptyLines = fromString("");
diff --git a/node_modules/recast/lib/mapping.d.ts b/node_modules/recast/lib/mapping.d.ts
index e77733e..03ad709 100644
--- a/node_modules/recast/lib/mapping.d.ts
+++ b/node_modules/recast/lib/mapping.d.ts
@@ -1,5 +1,5 @@
 import { namedTypes } from "ast-types";
-import { Lines } from "./lines";
+import { Lines } from "./lines.js";
 type Pos = namedTypes.Position;
 type Loc = namedTypes.SourceLocation;
 export default class Mapping {
diff --git a/node_modules/recast/lib/mapping.js b/node_modules/recast/lib/mapping.js
index 4c99987..8cff8d8 100644
--- a/node_modules/recast/lib/mapping.js
+++ b/node_modules/recast/lib/mapping.js
@@ -2,7 +2,7 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 var tslib_1 = require("tslib");
 var assert_1 = tslib_1.__importDefault(require("assert"));
-var util_1 = require("./util");
+var util_js_1 = require("./util.js");
 var Mapping = /** @class */ (function () {
     function Mapping(sourceLines, sourceLoc, targetLoc) {
         if (targetLoc === void 0) { targetLoc = sourceLoc; }
@@ -27,8 +27,8 @@ var Mapping = /** @class */ (function () {
             }
             return skipChars(sourceLines, sourceFromPos, lines, targetFromPos, targetToPos);
         }
-        if ((0, util_1.comparePos)(start, targetLoc.start) <= 0) {
-            if ((0, util_1.comparePos)(targetLoc.end, end) <= 0) {
+        if ((0, util_js_1.comparePos)(start, targetLoc.start) <= 0) {
+            if ((0, util_js_1.comparePos)(targetLoc.end, end) <= 0) {
                 targetLoc = {
                     start: subtractPos(targetLoc.start, start.line, start.column),
                     end: subtractPos(targetLoc.end, start.line, start.column),
@@ -36,7 +36,7 @@ var Mapping = /** @class */ (function () {
                 // The sourceLoc can stay the same because the contents of the
                 // targetLoc have not changed.
             }
-            else if ((0, util_1.comparePos)(end, targetLoc.start) <= 0) {
+            else if ((0, util_js_1.comparePos)(end, targetLoc.start) <= 0) {
                 return null;
             }
             else {
@@ -51,10 +51,10 @@ var Mapping = /** @class */ (function () {
             }
         }
         else {
-            if ((0, util_1.comparePos)(targetLoc.end, start) <= 0) {
+            if ((0, util_js_1.comparePos)(targetLoc.end, start) <= 0) {
                 return null;
             }
-            if ((0, util_1.comparePos)(targetLoc.end, end) <= 0) {
+            if ((0, util_js_1.comparePos)(targetLoc.end, end) <= 0) {
                 sourceLoc = {
                     start: skip("start"),
                     end: sourceLoc.end,
@@ -139,7 +139,7 @@ function subtractPos(fromPos, line, column) {
     };
 }
 function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {
-    var targetComparison = (0, util_1.comparePos)(targetFromPos, targetToPos);
+    var targetComparison = (0, util_js_1.comparePos)(targetFromPos, targetToPos);
     if (targetComparison === 0) {
         // Trivial case: no characters to skip.
         return sourceFromPos;
@@ -163,7 +163,7 @@ function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targe
         else {
             assert_1.default.strictEqual(lineDiff, 0);
         }
-        while ((0, util_1.comparePos)(targetCursor, targetToPos) < 0 &&
+        while ((0, util_js_1.comparePos)(targetCursor, targetToPos) < 0 &&
             targetLines.nextPos(targetCursor, true)) {
             assert_1.default.ok(sourceLines.nextPos(sourceCursor, true));
             assert_1.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
@@ -187,7 +187,7 @@ function skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targe
         else {
             assert_1.default.strictEqual(lineDiff, 0);
         }
-        while ((0, util_1.comparePos)(targetToPos, targetCursor) < 0 &&
+        while ((0, util_js_1.comparePos)(targetToPos, targetCursor) < 0 &&
             targetLines.prevPos(targetCursor, true)) {
             assert_1.default.ok(sourceLines.prevPos(sourceCursor, true));
             assert_1.default.strictEqual(sourceLines.charAt(sourceCursor), targetLines.charAt(targetCursor));
diff --git a/node_modules/recast/lib/mapping.ts b/node_modules/recast/lib/mapping.ts
new file mode 100644
index 0000000..39480ee
--- /dev/null
+++ b/node_modules/recast/lib/mapping.ts
@@ -0,0 +1,243 @@
+import assert from "assert";
+import { comparePos } from "./util.js";
+import { namedTypes } from "ast-types";
+import { Lines } from "./lines.js";
+
+type Pos = namedTypes.Position;
+type Loc = namedTypes.SourceLocation;
+
+export default class Mapping {
+  constructor(
+    public sourceLines: Lines,
+    public sourceLoc: Loc,
+    public targetLoc: Loc = sourceLoc,
+  ) {}
+
+  slice(lines: Lines, start: Pos, end: Pos = lines.lastPos()) {
+    const sourceLines = this.sourceLines;
+    let sourceLoc = this.sourceLoc;
+    let targetLoc = this.targetLoc;
+
+    function skip(name: "start" | "end") {
+      const sourceFromPos = sourceLoc[name];
+      const targetFromPos = targetLoc[name];
+      let targetToPos = start;
+
+      if (name === "end") {
+        targetToPos = end;
+      } else {
+        assert.strictEqual(name, "start");
+      }
+
+      return skipChars(
+        sourceLines,
+        sourceFromPos,
+        lines,
+        targetFromPos,
+        targetToPos,
+      );
+    }
+
+    if (comparePos(start, targetLoc.start) <= 0) {
+      if (comparePos(targetLoc.end, end) <= 0) {
+        targetLoc = {
+          start: subtractPos(targetLoc.start, start.line, start.column),
+          end: subtractPos(targetLoc.end, start.line, start.column),
+        };
+
+        // The sourceLoc can stay the same because the contents of the
+        // targetLoc have not changed.
+      } else if (comparePos(end, targetLoc.start) <= 0) {
+        return null;
+      } else {
+        sourceLoc = {
+          start: sourceLoc.start,
+          end: skip("end"),
+        };
+
+        targetLoc = {
+          start: subtractPos(targetLoc.start, start.line, start.column),
+          end: subtractPos(end, start.line, start.column),
+        };
+      }
+    } else {
+      if (comparePos(targetLoc.end, start) <= 0) {
+        return null;
+      }
+
+      if (comparePos(targetLoc.end, end) <= 0) {
+        sourceLoc = {
+          start: skip("start"),
+          end: sourceLoc.end,
+        };
+
+        targetLoc = {
+          // Same as subtractPos(start, start.line, start.column):
+          start: { line: 1, column: 0 },
+          end: subtractPos(targetLoc.end, start.line, start.column),
+        };
+      } else {
+        sourceLoc = {
+          start: skip("start"),
+          end: skip("end"),
+        };
+
+        targetLoc = {
+          // Same as subtractPos(start, start.line, start.column):
+          start: { line: 1, column: 0 },
+          end: subtractPos(end, start.line, start.column),
+        };
+      }
+    }
+
+    return new Mapping(this.sourceLines, sourceLoc, targetLoc);
+  }
+
+  add(line: number, column: number) {
+    return new Mapping(this.sourceLines, this.sourceLoc, {
+      start: addPos(this.targetLoc.start, line, column),
+      end: addPos(this.targetLoc.end, line, column),
+    });
+  }
+
+  subtract(line: number, column: number) {
+    return new Mapping(this.sourceLines, this.sourceLoc, {
+      start: subtractPos(this.targetLoc.start, line, column),
+      end: subtractPos(this.targetLoc.end, line, column),
+    });
+  }
+
+  indent(
+    by: number,
+    skipFirstLine: boolean = false,
+    noNegativeColumns: boolean = false,
+  ) {
+    if (by === 0) {
+      return this;
+    }
+
+    let targetLoc = this.targetLoc;
+    const startLine = targetLoc.start.line;
+    const endLine = targetLoc.end.line;
+
+    if (skipFirstLine && startLine === 1 && endLine === 1) {
+      return this;
+    }
+
+    targetLoc = {
+      start: targetLoc.start,
+      end: targetLoc.end,
+    };
+
+    if (!skipFirstLine || startLine > 1) {
+      const startColumn = targetLoc.start.column + by;
+      targetLoc.start = {
+        line: startLine,
+        column: noNegativeColumns ? Math.max(0, startColumn) : startColumn,
+      };
+    }
+
+    if (!skipFirstLine || endLine > 1) {
+      const endColumn = targetLoc.end.column + by;
+      targetLoc.end = {
+        line: endLine,
+        column: noNegativeColumns ? Math.max(0, endColumn) : endColumn,
+      };
+    }
+
+    return new Mapping(this.sourceLines, this.sourceLoc, targetLoc);
+  }
+}
+
+function addPos(toPos: any, line: number, column: number) {
+  return {
+    line: toPos.line + line - 1,
+    column: toPos.line === 1 ? toPos.column + column : toPos.column,
+  };
+}
+
+function subtractPos(fromPos: any, line: number, column: number) {
+  return {
+    line: fromPos.line - line + 1,
+    column: fromPos.line === line ? fromPos.column - column : fromPos.column,
+  };
+}
+
+function skipChars(
+  sourceLines: Lines,
+  sourceFromPos: Pos,
+  targetLines: Lines,
+  targetFromPos: Pos,
+  targetToPos: Pos,
+) {
+  const targetComparison = comparePos(targetFromPos, targetToPos);
+  if (targetComparison === 0) {
+    // Trivial case: no characters to skip.
+    return sourceFromPos;
+  }
+
+  let sourceCursor, targetCursor;
+  if (targetComparison < 0) {
+    // Skipping forward.
+    sourceCursor =
+      sourceLines.skipSpaces(sourceFromPos) || sourceLines.lastPos();
+    targetCursor =
+      targetLines.skipSpaces(targetFromPos) || targetLines.lastPos();
+
+    const lineDiff = targetToPos.line - targetCursor.line;
+    sourceCursor.line += lineDiff;
+    targetCursor.line += lineDiff;
+
+    if (lineDiff > 0) {
+      // If jumping to later lines, reset columns to the beginnings
+      // of those lines.
+      sourceCursor.column = 0;
+      targetCursor.column = 0;
+    } else {
+      assert.strictEqual(lineDiff, 0);
+    }
+
+    while (
+      comparePos(targetCursor, targetToPos) < 0 &&
+      targetLines.nextPos(targetCursor, true)
+    ) {
+      assert.ok(sourceLines.nextPos(sourceCursor, true));
+      assert.strictEqual(
+        sourceLines.charAt(sourceCursor),
+        targetLines.charAt(targetCursor),
+      );
+    }
+  } else {
+    // Skipping backward.
+    sourceCursor =
+      sourceLines.skipSpaces(sourceFromPos, true) || sourceLines.firstPos();
+    targetCursor =
+      targetLines.skipSpaces(targetFromPos, true) || targetLines.firstPos();
+
+    const lineDiff = targetToPos.line - targetCursor.line;
+    sourceCursor.line += lineDiff;
+    targetCursor.line += lineDiff;
+
+    if (lineDiff < 0) {
+      // If jumping to earlier lines, reset columns to the ends of
+      // those lines.
+      sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);
+      targetCursor.column = targetLines.getLineLength(targetCursor.line);
+    } else {
+      assert.strictEqual(lineDiff, 0);
+    }
+
+    while (
+      comparePos(targetToPos, targetCursor) < 0 &&
+      targetLines.prevPos(targetCursor, true)
+    ) {
+      assert.ok(sourceLines.prevPos(sourceCursor, true));
+      assert.strictEqual(
+        sourceLines.charAt(sourceCursor),
+        targetLines.charAt(targetCursor),
+      );
+    }
+  }
+
+  return sourceCursor;
+}
diff --git a/node_modules/recast/lib/options.js b/node_modules/recast/lib/options.js
index 3ba2b45..4acd60f 100644
--- a/node_modules/recast/lib/options.js
+++ b/node_modules/recast/lib/options.js
@@ -1,13 +1,15 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.normalize = void 0;
-var util_1 = require("./util");
+var tslib_1 = require("tslib");
+var util_js_1 = require("./util.js");
+var esprima = tslib_1.__importStar(require("../parsers/esprima.js"));
 var defaults = {
-    parser: require("../parsers/esprima"),
+    parser: esprima,
     tabWidth: 4,
     useTabs: false,
     reuseWhitespace: true,
-    lineTerminator: (0, util_1.getLineTerminator)(),
+    lineTerminator: (0, util_js_1.getLineTerminator)(),
     wrapColumn: 74,
     sourceFileName: null,
     sourceMapName: null,
diff --git a/node_modules/recast/lib/options.ts b/node_modules/recast/lib/options.ts
new file mode 100644
index 0000000..3a2c24f
--- /dev/null
+++ b/node_modules/recast/lib/options.ts
@@ -0,0 +1,225 @@
+import { getLineTerminator } from "./util.js";
+
+/**
+ * All Recast API functions take second parameter with configuration options,
+ * documented in options.js
+ */
+export interface Options extends DeprecatedOptions {
+  /**
+   * If you want to use a different branch of esprima, or any other module
+   * that supports a .parse function, pass that module object to
+   * recast.parse as options.parser (legacy synonym: options.esprima).
+   * @default require("recast/parsers/esprima")
+   */
+  parser?: any;
+
+  /**
+   * Number of spaces the pretty-printer should use per tab for
+   * indentation. If you do not pass this option explicitly, it will be
+   * (quite reliably!) inferred from the original code.
+   * @default 4
+   */
+  tabWidth?: number;
+
+  /**
+   * If you really want the pretty-printer to use tabs instead of spaces,
+   * make this option true.
+   * @default false
+   */
+  useTabs?: boolean;
+
+  /**
+   * The reprinting code leaves leading whitespace untouched unless it has
+   * to reindent a line, or you pass false for this option.
+   * @default true
+   */
+  reuseWhitespace?: boolean;
+
+  /**
+   * Override this option to use a different line terminator, e.g. \r\n.
+   * @default require("os").EOL || "\n"
+   */
+  lineTerminator?: string;
+
+  /**
+   * Some of the pretty-printer code (such as that for printing function
+   * parameter lists) makes a valiant attempt to prevent really long
+   * lines. You can adjust the limit by changing this option; however,
+   * there is no guarantee that line length will fit inside this limit.
+   * @default 74
+   */
+  wrapColumn?: number;
+
+  /**
+   * Pass a string as options.sourceFileName to recast.parse to tell the
+   * reprinter to keep track of reused code so that it can construct a
+   * source map automatically.
+   * @default null
+   */
+  sourceFileName?: string | null;
+
+  /**
+   * Pass a string as options.sourceMapName to recast.print, and (provided
+   * you passed options.sourceFileName earlier) the PrintResult of
+   * recast.print will have a .map property for the generated source map.
+   * @default null
+   */
+  sourceMapName?: string | null;
+
+  /**
+   * If provided, this option will be passed along to the source map
+   * generator as a root directory for relative source file paths.
+   * @default null
+   */
+  sourceRoot?: string | null;
+
+  /**
+   * If you provide a source map that was generated from a previous call
+   * to recast.print as options.inputSourceMap, the old source map will be
+   * composed with the new source map.
+   * @default null
+   */
+  inputSourceMap?: string | null;
+
+  /**
+   * If you want esprima to generate .range information (recast only uses
+   * .loc internally), pass true for this option.
+   * @default false
+   */
+  range?: boolean;
+
+  /**
+   * If you want esprima not to throw exceptions when it encounters
+   * non-fatal errors, keep this option true.
+   * @default true
+   */
+  tolerant?: boolean;
+
+  /**
+   * If you want to override the quotes used in string literals, specify
+   * either "single", "double", or "auto" here ("auto" will select the one
+   * which results in the shorter literal) Otherwise, use double quotes.
+   * @default null
+   */
+  quote?: "single" | "double" | "auto" | null;
+
+  /**
+   * Controls the printing of trailing commas in object literals, array
+   * expressions and function parameters.
+   *
+   * This option could either be:
+   * * Boolean - enable/disable in all contexts (objects, arrays and function params).
+   * * Object - enable/disable per context.
+   *
+   * Example:
+   * trailingComma: {
+   *   objects: true,
+   *   arrays: true,
+   *   parameters: false,
+   * }
+   *
+   * @default false
+   */
+  trailingComma?: boolean;
+
+  /**
+   * Controls the printing of spaces inside array brackets.
+   * See: http://eslint.org/docs/rules/array-bracket-spacing
+   * @default false
+   */
+  arrayBracketSpacing?: boolean;
+
+  /**
+   * Controls the printing of spaces inside object literals,
+   * destructuring assignments, and import/export specifiers.
+   * See: http://eslint.org/docs/rules/object-curly-spacing
+   * @default true
+   */
+  objectCurlySpacing?: boolean;
+
+  /**
+   * If you want parenthesis to wrap single-argument arrow function
+   * parameter lists, pass true for this option.
+   * @default false
+   */
+  arrowParensAlways?: boolean;
+
+  /**
+   * There are 2 supported syntaxes (`,` and `;`) in Flow Object Types;
+   * The use of commas is in line with the more popular style and matches
+   * how objects are defined in JS, making it a bit more natural to write.
+   * @default true
+   */
+  flowObjectCommas?: boolean;
+
+  /**
+   * Whether to return an array of .tokens on the root AST node.
+   * @default true
+   */
+  tokens?: boolean;
+}
+
+interface DeprecatedOptions {
+  /** @deprecated */
+  esprima?: any;
+}
+
+import * as esprima from "../parsers/esprima.js";
+
+const defaults: Options = {
+  parser: esprima,
+  tabWidth: 4,
+  useTabs: false,
+  reuseWhitespace: true,
+  lineTerminator: getLineTerminator(),
+  wrapColumn: 74, // Aspirational for now.
+  sourceFileName: null,
+  sourceMapName: null,
+  sourceRoot: null,
+  inputSourceMap: null,
+  range: false,
+  tolerant: true,
+  quote: null,
+  trailingComma: false,
+  arrayBracketSpacing: false,
+  objectCurlySpacing: true,
+  arrowParensAlways: false,
+  flowObjectCommas: true,
+  tokens: true,
+};
+const hasOwn = defaults.hasOwnProperty;
+
+export type NormalizedOptions = Required<
+  Omit<Options, keyof DeprecatedOptions>
+>;
+
+// Copy options and fill in default values.
+export function normalize(opts?: Options): NormalizedOptions {
+  const options = opts || defaults;
+
+  function get(key: keyof Options) {
+    return hasOwn.call(options, key) ? options[key] : defaults[key];
+  }
+
+  return {
+    tabWidth: +get("tabWidth"),
+    useTabs: !!get("useTabs"),
+    reuseWhitespace: !!get("reuseWhitespace"),
+    lineTerminator: get("lineTerminator"),
+    wrapColumn: Math.max(get("wrapColumn"), 0),
+    sourceFileName: get("sourceFileName"),
+    sourceMapName: get("sourceMapName"),
+    sourceRoot: get("sourceRoot"),
+    inputSourceMap: get("inputSourceMap"),
+    parser: get("esprima") || get("parser"),
+    range: get("range"),
+    tolerant: get("tolerant"),
+    quote: get("quote"),
+    trailingComma: get("trailingComma"),
+    arrayBracketSpacing: get("arrayBracketSpacing"),
+    objectCurlySpacing: get("objectCurlySpacing"),
+    arrowParensAlways: get("arrowParensAlways"),
+    flowObjectCommas: get("flowObjectCommas"),
+    tokens: !!get("tokens"),
+  };
+}
diff --git a/node_modules/recast/lib/parser.d.ts b/node_modules/recast/lib/parser.d.ts
index 6f1d6df..3a5795d 100644
--- a/node_modules/recast/lib/parser.d.ts
+++ b/node_modules/recast/lib/parser.d.ts
@@ -1,2 +1,2 @@
-import { Options } from "./options";
+import { Options } from "./options.js";
 export declare function parse(source: string, options?: Partial<Options>): any;
diff --git a/node_modules/recast/lib/parser.js b/node_modules/recast/lib/parser.js
index 7c08313..7ff8cb0 100644
--- a/node_modules/recast/lib/parser.js
+++ b/node_modules/recast/lib/parser.js
@@ -7,13 +7,14 @@ var types = tslib_1.__importStar(require("ast-types"));
 var b = types.builders;
 var isObject = types.builtInTypes.object;
 var isArray = types.builtInTypes.array;
-var options_1 = require("./options");
-var lines_1 = require("./lines");
-var comments_1 = require("./comments");
-var util = tslib_1.__importStar(require("./util"));
+var options_js_1 = require("./options.js");
+var lines_js_1 = require("./lines.js");
+var comments_js_1 = require("./comments.js");
+var util = tslib_1.__importStar(require("./util.js"));
+var esprima = tslib_1.__importStar(require("esprima"));
 function parse(source, options) {
-    options = (0, options_1.normalize)(options);
-    var lines = (0, lines_1.fromString)(source, options);
+    options = (0, options_js_1.normalize)(options);
+    var lines = (0, lines_js_1.fromString)(source, options);
     var sourceWithoutTabs = lines.toString({
         tabWidth: options.tabWidth,
         reuseWhitespace: false,
@@ -37,7 +38,7 @@ function parse(source, options) {
     // to avoid this fallback.
     var tokens = Array.isArray(ast.tokens)
         ? ast.tokens
-        : require("esprima").tokenize(sourceWithoutTabs, {
+        : esprima.tokenize(sourceWithoutTabs, {
             loc: true,
         });
     // We will reattach the tokens array to the file object below.
@@ -104,7 +105,7 @@ function parse(source, options) {
     program.loc.end = trueProgramLoc.end;
     // Passing file.program here instead of just file means that initial
     // comments will be attached to program.body[0] instead of program.
-    (0, comments_1.attach)(comments, program.body.length ? file.program : file, lines);
+    (0, comments_js_1.attach)(comments, program.body.length ? file.program : file, lines);
     // Return a copy of the original AST so that any changes made may be
     // compared to the original.
     return new TreeCopier(lines, tokens).copy(file);
diff --git a/node_modules/recast/lib/parser.ts b/node_modules/recast/lib/parser.ts
new file mode 100644
index 0000000..5b68f64
--- /dev/null
+++ b/node_modules/recast/lib/parser.ts
@@ -0,0 +1,296 @@
+import assert from "assert";
+import * as types from "ast-types";
+const b = types.builders;
+const isObject = types.builtInTypes.object;
+const isArray = types.builtInTypes.array;
+import { normalize as normalizeOptions } from "./options.js";
+import { fromString } from "./lines.js";
+import { attach as attachComments } from "./comments.js";
+import * as util from "./util.js";
+import { Options } from "./options.js";
+import * as esprima from "esprima";
+
+export function parse(source: string, options?: Partial<Options>) {
+  options = normalizeOptions(options);
+
+  const lines = fromString(source, options);
+
+  const sourceWithoutTabs = lines.toString({
+    tabWidth: options.tabWidth,
+    reuseWhitespace: false,
+    useTabs: false,
+  });
+
+  let comments: any[] = [];
+  const ast = options.parser.parse(sourceWithoutTabs, {
+    jsx: true,
+    loc: true,
+    locations: true,
+    range: options.range,
+    comment: true,
+    onComment: comments,
+    tolerant: util.getOption(options, "tolerant", true),
+    ecmaVersion: 6,
+    sourceType: util.getOption(options, "sourceType", "module"),
+  });
+
+  // Use ast.tokens if possible, and otherwise fall back to the Esprima
+  // tokenizer. All the preconfigured ../parsers/* expose ast.tokens
+  // automatically, but custom parsers might need additional configuration
+  // to avoid this fallback.
+  const tokens: any[] = Array.isArray(ast.tokens)
+    ? ast.tokens
+    : esprima.tokenize(sourceWithoutTabs, {
+        loc: true,
+      });
+
+  // We will reattach the tokens array to the file object below.
+  delete ast.tokens;
+
+  // Make sure every token has a token.value string.
+  tokens.forEach(function (token) {
+    if (typeof token.value !== "string") {
+      token.value = lines.sliceString(token.loc.start, token.loc.end);
+    }
+  });
+
+  if (Array.isArray(ast.comments)) {
+    comments = ast.comments;
+    delete ast.comments;
+  }
+
+  if (ast.loc) {
+    // If the source was empty, some parsers give loc.{start,end}.line
+    // values of 0, instead of the minimum of 1.
+    util.fixFaultyLocations(ast, lines);
+  } else {
+    ast.loc = {
+      start: lines.firstPos(),
+      end: lines.lastPos(),
+    };
+  }
+
+  ast.loc.lines = lines;
+  ast.loc.indent = 0;
+
+  let file;
+  let program;
+  if (ast.type === "Program") {
+    program = ast;
+    // In order to ensure we reprint leading and trailing program
+    // comments, wrap the original Program node with a File node. Only
+    // ESTree parsers (Acorn and Esprima) return a Program as the root AST
+    // node. Most other (Babylon-like) parsers return a File.
+    file = b.file(ast, options.sourceFileName || null);
+    file.loc = {
+      start: lines.firstPos(),
+      end: lines.lastPos(),
+      lines: lines,
+      indent: 0,
+    } as any;
+  } else if (ast.type === "File") {
+    file = ast;
+    program = file.program;
+  }
+
+  // Expose file.tokens unless the caller passed false for options.tokens.
+  if (options.tokens) {
+    file.tokens = tokens;
+  }
+
+  // Expand the Program's .loc to include all comments (not just those
+  // attached to the Program node, as its children may have comments as
+  // well), since sometimes program.loc.{start,end} will coincide with the
+  // .loc.{start,end} of the first and last *statements*, mistakenly
+  // excluding comments that fall outside that region.
+  const trueProgramLoc: any = util.getTrueLoc(
+    {
+      type: program.type,
+      loc: program.loc,
+      body: [],
+      comments,
+    },
+    lines,
+  );
+  program.loc.start = trueProgramLoc.start;
+  program.loc.end = trueProgramLoc.end;
+
+  // Passing file.program here instead of just file means that initial
+  // comments will be attached to program.body[0] instead of program.
+  attachComments(comments, program.body.length ? file.program : file, lines);
+
+  // Return a copy of the original AST so that any changes made may be
+  // compared to the original.
+  return new TreeCopier(lines, tokens).copy(file);
+}
+
+interface TreeCopierType {
+  lines: any;
+  tokens: any[];
+  startTokenIndex: number;
+  endTokenIndex: number;
+  indent: number;
+  seen: Map<any, any>;
+  copy(node: any): any;
+  findTokenRange(loc: any): any;
+}
+
+interface TreeCopierConstructor {
+  new (lines: any, tokens: any): TreeCopierType;
+}
+
+const TreeCopier = function TreeCopier(
+  this: TreeCopierType,
+  lines: any,
+  tokens: any,
+) {
+  assert.ok(this instanceof TreeCopier);
+  this.lines = lines;
+  this.tokens = tokens;
+  this.startTokenIndex = 0;
+  this.endTokenIndex = tokens.length;
+  this.indent = 0;
+  this.seen = new Map();
+} as any as TreeCopierConstructor;
+
+const TCp: TreeCopierType = TreeCopier.prototype;
+
+TCp.copy = function (node) {
+  if (this.seen.has(node)) {
+    return this.seen.get(node);
+  }
+
+  if (isArray.check(node)) {
+    const copy: any = new Array(node.length);
+    this.seen.set(node, copy);
+    node.forEach(function (this: any, item: any, i: any) {
+      copy[i] = this.copy(item);
+    }, this);
+    return copy;
+  }
+
+  if (!isObject.check(node)) {
+    return node;
+  }
+
+  util.fixFaultyLocations(node, this.lines);
+
+  const copy: any = Object.create(Object.getPrototypeOf(node), {
+    original: {
+      // Provide a link from the copy to the original.
+      value: node,
+      configurable: false,
+      enumerable: false,
+      writable: true,
+    },
+  });
+
+  this.seen.set(node, copy);
+
+  const loc = node.loc;
+  const oldIndent = this.indent;
+  let newIndent = oldIndent;
+
+  const oldStartTokenIndex = this.startTokenIndex;
+  const oldEndTokenIndex = this.endTokenIndex;
+
+  if (loc) {
+    // When node is a comment, we set node.loc.indent to
+    // node.loc.start.column so that, when/if we print the comment by
+    // itself, we can strip that much whitespace from the left margin of
+    // the comment. This only really matters for multiline Block comments,
+    // but it doesn't hurt for Line comments.
+    if (
+      node.type === "Block" ||
+      node.type === "Line" ||
+      node.type === "CommentBlock" ||
+      node.type === "CommentLine" ||
+      this.lines.isPrecededOnlyByWhitespace(loc.start)
+    ) {
+      newIndent = this.indent = loc.start.column;
+    }
+
+    // Every node.loc has a reference to the original source lines as well
+    // as a complete list of source tokens.
+    loc.lines = this.lines;
+    loc.tokens = this.tokens;
+    loc.indent = newIndent;
+
+    // Set loc.start.token and loc.end.token such that
+    // loc.tokens.slice(loc.start.token, loc.end.token) returns a list of
+    // all the tokens that make up this node.
+    this.findTokenRange(loc);
+  }
+
+  const keys = Object.keys(node);
+  const keyCount = keys.length;
+  for (let i = 0; i < keyCount; ++i) {
+    const key = keys[i];
+    if (key === "loc") {
+      copy[key] = node[key];
+    } else if (key === "tokens" && node.type === "File") {
+      // Preserve file.tokens (uncopied) in case client code cares about
+      // it, even though Recast ignores it when reprinting.
+      copy[key] = node[key];
+    } else {
+      copy[key] = this.copy(node[key]);
+    }
+  }
+
+  this.indent = oldIndent;
+  this.startTokenIndex = oldStartTokenIndex;
+  this.endTokenIndex = oldEndTokenIndex;
+
+  return copy;
+};
+
+// If we didn't have any idea where in loc.tokens to look for tokens
+// contained by this loc, a binary search would be appropriate, but
+// because we maintain this.startTokenIndex and this.endTokenIndex as we
+// traverse the AST, we only need to make small (linear) adjustments to
+// those indexes with each recursive iteration.
+TCp.findTokenRange = function (loc) {
+  // In the unlikely event that loc.tokens[this.startTokenIndex] starts
+  // *after* loc.start, we need to rewind this.startTokenIndex first.
+  while (this.startTokenIndex > 0) {
+    const token = loc.tokens[this.startTokenIndex];
+    if (util.comparePos(loc.start, token.loc.start) < 0) {
+      --this.startTokenIndex;
+    } else break;
+  }
+
+  // In the unlikely event that loc.tokens[this.endTokenIndex - 1] ends
+  // *before* loc.end, we need to fast-forward this.endTokenIndex first.
+  while (this.endTokenIndex < loc.tokens.length) {
+    const token = loc.tokens[this.endTokenIndex];
+    if (util.comparePos(token.loc.end, loc.end) < 0) {
+      ++this.endTokenIndex;
+    } else break;
+  }
+
+  // Increment this.startTokenIndex until we've found the first token
+  // contained by this node.
+  while (this.startTokenIndex < this.endTokenIndex) {
+    const token = loc.tokens[this.startTokenIndex];
+    if (util.comparePos(token.loc.start, loc.start) < 0) {
+      ++this.startTokenIndex;
+    } else break;
+  }
+
+  // Index into loc.tokens of the first token within this node.
+  loc.start.token = this.startTokenIndex;
+
+  // Decrement this.endTokenIndex until we've found the first token after
+  // this node (not contained by the node).
+  while (this.endTokenIndex > this.startTokenIndex) {
+    const token = loc.tokens[this.endTokenIndex - 1];
+    if (util.comparePos(loc.end, token.loc.end) < 0) {
+      --this.endTokenIndex;
+    } else break;
+  }
+
+  // Index into loc.tokens of the first token *after* this node.
+  // If loc.start.token === loc.end.token, the node contains no tokens,
+  // and the index is that of the next token following this node.
+  loc.end.token = this.endTokenIndex;
+};
diff --git a/node_modules/recast/lib/patcher.js b/node_modules/recast/lib/patcher.js
index d6827cd..5a4c397 100644
--- a/node_modules/recast/lib/patcher.js
+++ b/node_modules/recast/lib/patcher.js
@@ -3,14 +3,14 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.getReprinter = exports.Patcher = void 0;
 var tslib_1 = require("tslib");
 var assert_1 = tslib_1.__importDefault(require("assert"));
-var linesModule = tslib_1.__importStar(require("./lines"));
+var linesModule = tslib_1.__importStar(require("./lines.js"));
 var types = tslib_1.__importStar(require("ast-types"));
 var Printable = types.namedTypes.Printable;
 var Expression = types.namedTypes.Expression;
 var ReturnStatement = types.namedTypes.ReturnStatement;
 var SourceLocation = types.namedTypes.SourceLocation;
-var util_1 = require("./util");
-var fast_path_1 = tslib_1.__importDefault(require("./fast-path"));
+var util_js_1 = require("./util.js");
+var fast_path_js_1 = tslib_1.__importDefault(require("./fast-path.js"));
 var isObject = types.builtInTypes.object;
 var isArray = types.builtInTypes.array;
 var isString = types.builtInTypes.string;
@@ -36,13 +36,13 @@ var Patcher = function Patcher(lines) {
         };
         var sliceFrom = loc.start, toConcat = [];
         function pushSlice(from, to) {
-            assert_1.default.ok((0, util_1.comparePos)(from, to) <= 0);
+            assert_1.default.ok((0, util_js_1.comparePos)(from, to) <= 0);
             toConcat.push(lines.slice(from, to));
         }
         replacements
-            .sort(function (a, b) { return (0, util_1.comparePos)(a.start, b.start); })
+            .sort(function (a, b) { return (0, util_js_1.comparePos)(a.start, b.start); })
             .forEach(function (rep) {
-            if ((0, util_1.comparePos)(sliceFrom, rep.start) > 0) {
+            if ((0, util_js_1.comparePos)(sliceFrom, rep.start) > 0) {
                 // Ignore nested replacement ranges.
             }
             else {
@@ -63,8 +63,8 @@ Pp.tryToReprintComments = function (newNode, oldNode, print) {
         // We were (vacuously) able to reprint all the comments!
         return true;
     }
-    var newPath = fast_path_1.default.from(newNode);
-    var oldPath = fast_path_1.default.from(oldNode);
+    var newPath = fast_path_js_1.default.from(newNode);
+    var oldPath = fast_path_js_1.default.from(oldNode);
     newPath.stack.push("comments", getSurroundingComments(newNode));
     oldPath.stack.push("comments", getSurroundingComments(oldNode));
     var reprints = [];
@@ -122,7 +122,7 @@ Pp.deleteComments = function (node) {
     });
 };
 function getReprinter(path) {
-    assert_1.default.ok(path instanceof fast_path_1.default);
+    assert_1.default.ok(path instanceof fast_path_js_1.default);
     // Make sure that this path refers specifically to a Node, rather than
     // some non-Node subproperty of a Node.
     var node = path.getValue();
@@ -187,7 +187,7 @@ exports.getReprinter = getReprinter;
 // are both identifier characters, they must be separated by a space,
 // otherwise they will most likely get fused together into a single token.
 function needsLeadingSpace(oldLines, oldLoc, newLines) {
-    var posBeforeOldLoc = (0, util_1.copyPos)(oldLoc.start);
+    var posBeforeOldLoc = (0, util_js_1.copyPos)(oldLoc.start);
     // The character just before the location occupied by oldNode.
     var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);
     // First character of the reprinted node.
@@ -220,7 +220,7 @@ function findReprints(newPath, reprints) {
     if (newNode.type !== oldNode.type) {
         return false;
     }
-    var oldPath = new fast_path_1.default(oldNode);
+    var oldPath = new fast_path_js_1.default(oldNode);
     var canReprint = findChildReprints(newPath, oldPath, reprints);
     if (!canReprint) {
         // Make absolutely sure the calling code does not attempt to reprint
@@ -351,7 +351,7 @@ function findChildReprints(newPath, oldPath, reprints) {
     if (newPath.needsParens() && !oldPath.hasParens()) {
         return false;
     }
-    var keys = (0, util_1.getUnionOfKeys)(oldNode, newNode);
+    var keys = (0, util_js_1.getUnionOfKeys)(oldNode, newNode);
     if (oldNode.type === "File" || newNode.type === "File") {
         // Don't bother traversing file.tokens, an often very large array
         // returned by Babylon, and useless for our purposes.
diff --git a/node_modules/recast/lib/patcher.ts b/node_modules/recast/lib/patcher.ts
new file mode 100644
index 0000000..6791872
--- /dev/null
+++ b/node_modules/recast/lib/patcher.ts
@@ -0,0 +1,507 @@
+import assert from "assert";
+import * as linesModule from "./lines.js";
+import * as types from "ast-types";
+const Printable = types.namedTypes.Printable;
+const Expression = types.namedTypes.Expression;
+const ReturnStatement = types.namedTypes.ReturnStatement;
+const SourceLocation = types.namedTypes.SourceLocation;
+import { comparePos, copyPos, getUnionOfKeys } from "./util.js";
+import FastPath from "./fast-path.js";
+const isObject = types.builtInTypes.object;
+const isArray = types.builtInTypes.array;
+const isString = types.builtInTypes.string;
+const riskyAdjoiningCharExp = /[0-9a-z_$]/i;
+
+interface PatcherType {
+  replace(loc: any, lines: any): any;
+  get(loc?: any): any;
+  tryToReprintComments(newNode: any, oldNode: any, print: any): any;
+  deleteComments(node: any): any;
+}
+
+interface PatcherConstructor {
+  new (lines: any): PatcherType;
+}
+
+const Patcher = function Patcher(this: PatcherType, lines: any) {
+  assert.ok(this instanceof Patcher);
+  assert.ok(lines instanceof linesModule.Lines);
+
+  const self = this,
+    replacements: any[] = [];
+
+  self.replace = function (loc, lines) {
+    if (isString.check(lines)) lines = linesModule.fromString(lines);
+
+    replacements.push({
+      lines: lines,
+      start: loc.start,
+      end: loc.end,
+    });
+  };
+
+  self.get = function (loc) {
+    // If no location is provided, return the complete Lines object.
+    loc = loc || {
+      start: { line: 1, column: 0 },
+      end: { line: lines.length, column: lines.getLineLength(lines.length) },
+    };
+
+    let sliceFrom = loc.start,
+      toConcat: any[] = [];
+
+    function pushSlice(from: any, to: any) {
+      assert.ok(comparePos(from, to) <= 0);
+      toConcat.push(lines.slice(from, to));
+    }
+
+    replacements
+      .sort((a, b) => comparePos(a.start, b.start))
+      .forEach(function (rep) {
+        if (comparePos(sliceFrom, rep.start) > 0) {
+          // Ignore nested replacement ranges.
+        } else {
+          pushSlice(sliceFrom, rep.start);
+          toConcat.push(rep.lines);
+          sliceFrom = rep.end;
+        }
+      });
+
+    pushSlice(sliceFrom, loc.end);
+
+    return linesModule.concat(toConcat);
+  };
+} as any as PatcherConstructor;
+export { Patcher };
+
+const Pp: PatcherType = Patcher.prototype;
+
+Pp.tryToReprintComments = function (newNode, oldNode, print) {
+  const patcher = this;
+
+  if (!newNode.comments && !oldNode.comments) {
+    // We were (vacuously) able to reprint all the comments!
+    return true;
+  }
+
+  const newPath = FastPath.from(newNode);
+  const oldPath = FastPath.from(oldNode);
+
+  newPath.stack.push("comments", getSurroundingComments(newNode));
+  oldPath.stack.push("comments", getSurroundingComments(oldNode));
+
+  const reprints: any[] = [];
+  const ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);
+
+  // No need to pop anything from newPath.stack or oldPath.stack, since
+  // newPath and oldPath are fresh local variables.
+
+  if (ableToReprintComments && reprints.length > 0) {
+    reprints.forEach(function (reprint) {
+      const oldComment = reprint.oldPath.getValue();
+      assert.ok(oldComment.leading || oldComment.trailing);
+      patcher.replace(
+        oldComment.loc,
+        // Comments can't have .comments, so it doesn't matter whether we
+        // print with comments or without.
+        print(reprint.newPath).indentTail(oldComment.loc.indent),
+      );
+    });
+  }
+
+  return ableToReprintComments;
+};
+
+// Get all comments that are either leading or trailing, ignoring any
+// comments that occur inside node.loc. Returns an empty array for nodes
+// with no leading or trailing comments.
+function getSurroundingComments(node: any) {
+  const result: any[] = [];
+  if (node.comments && node.comments.length > 0) {
+    node.comments.forEach(function (comment: any) {
+      if (comment.leading || comment.trailing) {
+        result.push(comment);
+      }
+    });
+  }
+  return result;
+}
+
+Pp.deleteComments = function (node) {
+  if (!node.comments) {
+    return;
+  }
+
+  const patcher = this;
+
+  node.comments.forEach(function (comment: any) {
+    if (comment.leading) {
+      // Delete leading comments along with any trailing whitespace they
+      // might have.
+      patcher.replace(
+        {
+          start: comment.loc.start,
+          end: node.loc.lines.skipSpaces(comment.loc.end, false, false),
+        },
+        "",
+      );
+    } else if (comment.trailing) {
+      // Delete trailing comments along with any leading whitespace they
+      // might have.
+      patcher.replace(
+        {
+          start: node.loc.lines.skipSpaces(comment.loc.start, true, false),
+          end: comment.loc.end,
+        },
+        "",
+      );
+    }
+  });
+};
+
+export function getReprinter(path: any) {
+  assert.ok(path instanceof FastPath);
+
+  // Make sure that this path refers specifically to a Node, rather than
+  // some non-Node subproperty of a Node.
+  const node = path.getValue();
+  if (!Printable.check(node)) return;
+
+  const orig = (node as any).original;
+  const origLoc = orig && orig.loc;
+  const lines = origLoc && origLoc.lines;
+  const reprints: any[] = [];
+
+  if (!lines || !findReprints(path, reprints)) return;
+
+  return function (print: any) {
+    const patcher = new Patcher(lines);
+
+    reprints.forEach(function (reprint) {
+      const newNode = reprint.newPath.getValue();
+      const oldNode = reprint.oldPath.getValue();
+
+      SourceLocation.assert(oldNode.loc, true);
+
+      const needToPrintNewPathWithComments = !patcher.tryToReprintComments(
+        newNode,
+        oldNode,
+        print,
+      );
+
+      if (needToPrintNewPathWithComments) {
+        // Since we were not able to preserve all leading/trailing
+        // comments, we delete oldNode's comments, print newPath with
+        // comments, and then patch the resulting lines where oldNode used
+        // to be.
+        patcher.deleteComments(oldNode);
+      }
+
+      let newLines = print(reprint.newPath, {
+        includeComments: needToPrintNewPathWithComments,
+        // If the oldNode we're replacing already had parentheses, we may
+        // not need to print the new node with any extra parentheses,
+        // because the existing parentheses will suffice. However, if the
+        // newNode has a different type than the oldNode, let the printer
+        // decide if reprint.newPath needs parentheses, as usual.
+        avoidRootParens:
+          oldNode.type === newNode.type && reprint.oldPath.hasParens(),
+      }).indentTail(oldNode.loc.indent);
+
+      const nls = needsLeadingSpace(lines, oldNode.loc, newLines);
+      const nts = needsTrailingSpace(lines, oldNode.loc, newLines);
+
+      // If we try to replace the argument of a ReturnStatement like
+      // return"asdf" with e.g. a literal null expression, we run the risk
+      // of ending up with returnnull, so we need to add an extra leading
+      // space in situations where that might happen. Likewise for
+      // "asdf"in obj. See #170.
+      if (nls || nts) {
+        const newParts = [];
+        nls && newParts.push(" ");
+        newParts.push(newLines);
+        nts && newParts.push(" ");
+        newLines = linesModule.concat(newParts);
+      }
+
+      patcher.replace(oldNode.loc, newLines);
+    });
+
+    // Recall that origLoc is the .loc of an ancestor node that is
+    // guaranteed to contain all the reprinted nodes and comments.
+    const patchedLines = patcher.get(origLoc).indentTail(-orig.loc.indent);
+
+    if (path.needsParens()) {
+      return linesModule.concat(["(", patchedLines, ")"]);
+    }
+
+    return patchedLines;
+  };
+}
+
+// If the last character before oldLoc and the first character of newLines
+// are both identifier characters, they must be separated by a space,
+// otherwise they will most likely get fused together into a single token.
+function needsLeadingSpace(oldLines: any, oldLoc: any, newLines: any) {
+  const posBeforeOldLoc = copyPos(oldLoc.start);
+
+  // The character just before the location occupied by oldNode.
+  const charBeforeOldLoc =
+    oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);
+
+  // First character of the reprinted node.
+  const newFirstChar = newLines.charAt(newLines.firstPos());
+
+  return (
+    charBeforeOldLoc &&
+    riskyAdjoiningCharExp.test(charBeforeOldLoc) &&
+    newFirstChar &&
+    riskyAdjoiningCharExp.test(newFirstChar)
+  );
+}
+
+// If the last character of newLines and the first character after oldLoc
+// are both identifier characters, they must be separated by a space,
+// otherwise they will most likely get fused together into a single token.
+function needsTrailingSpace(oldLines: any, oldLoc: any, newLines: any) {
+  // The character just after the location occupied by oldNode.
+  const charAfterOldLoc = oldLines.charAt(oldLoc.end);
+
+  const newLastPos = newLines.lastPos();
+
+  // Last character of the reprinted node.
+  const newLastChar =
+    newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);
+
+  return (
+    newLastChar &&
+    riskyAdjoiningCharExp.test(newLastChar) &&
+    charAfterOldLoc &&
+    riskyAdjoiningCharExp.test(charAfterOldLoc)
+  );
+}
+
+function findReprints(newPath: any, reprints: any) {
+  const newNode = newPath.getValue();
+  Printable.assert(newNode);
+
+  const oldNode = newNode.original;
+  Printable.assert(oldNode);
+
+  assert.deepEqual(reprints, []);
+
+  if (newNode.type !== oldNode.type) {
+    return false;
+  }
+
+  const oldPath = new FastPath(oldNode);
+  const canReprint = findChildReprints(newPath, oldPath, reprints);
+
+  if (!canReprint) {
+    // Make absolutely sure the calling code does not attempt to reprint
+    // any nodes.
+    reprints.length = 0;
+  }
+
+  return canReprint;
+}
+
+function findAnyReprints(newPath: any, oldPath: any, reprints: any) {
+  const newNode = newPath.getValue();
+  const oldNode = oldPath.getValue();
+
+  if (newNode === oldNode) return true;
+
+  if (isArray.check(newNode))
+    return findArrayReprints(newPath, oldPath, reprints);
+
+  if (isObject.check(newNode))
+    return findObjectReprints(newPath, oldPath, reprints);
+
+  return false;
+}
+
+function findArrayReprints(newPath: any, oldPath: any, reprints: any) {
+  const newNode = newPath.getValue();
+  const oldNode = oldPath.getValue();
+
+  if (
+    newNode === oldNode ||
+    newPath.valueIsDuplicate() ||
+    oldPath.valueIsDuplicate()
+  ) {
+    return true;
+  }
+
+  isArray.assert(newNode);
+  const len = newNode.length;
+
+  if (!(isArray.check(oldNode) && oldNode.length === len)) return false;
+
+  for (let i = 0; i < len; ++i) {
+    newPath.stack.push(i, newNode[i]);
+    oldPath.stack.push(i, oldNode[i]);
+    const canReprint = findAnyReprints(newPath, oldPath, reprints);
+    newPath.stack.length -= 2;
+    oldPath.stack.length -= 2;
+    if (!canReprint) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function findObjectReprints(newPath: any, oldPath: any, reprints: any) {
+  const newNode = newPath.getValue();
+  isObject.assert(newNode);
+
+  if (newNode.original === null) {
+    // If newNode.original node was set to null, reprint the node.
+    return false;
+  }
+
+  const oldNode = oldPath.getValue();
+  if (!isObject.check(oldNode)) return false;
+
+  if (
+    newNode === oldNode ||
+    newPath.valueIsDuplicate() ||
+    oldPath.valueIsDuplicate()
+  ) {
+    return true;
+  }
+
+  if (Printable.check(newNode)) {
+    if (!Printable.check(oldNode)) {
+      return false;
+    }
+
+    const newParentNode = newPath.getParentNode();
+    const oldParentNode = oldPath.getParentNode();
+    if (
+      oldParentNode !== null &&
+      oldParentNode.type === "FunctionTypeAnnotation" &&
+      newParentNode !== null &&
+      newParentNode.type === "FunctionTypeAnnotation"
+    ) {
+      const oldNeedsParens =
+        oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;
+      const newNeedParens =
+        newParentNode.params.length !== 1 || !!newParentNode.params[0].name;
+      if (!oldNeedsParens && newNeedParens) {
+        return false;
+      }
+    }
+
+    // Here we need to decide whether the reprinted code for newNode is
+    // appropriate for patching into the location of oldNode.
+
+    if ((newNode as any).type === (oldNode as any).type) {
+      const childReprints: any[] = [];
+
+      if (findChildReprints(newPath, oldPath, childReprints)) {
+        reprints.push.apply(reprints, childReprints);
+      } else if (oldNode.loc) {
+        // If we have no .loc information for oldNode, then we won't be
+        // able to reprint it.
+        reprints.push({
+          oldPath: oldPath.copy(),
+          newPath: newPath.copy(),
+        });
+      } else {
+        return false;
+      }
+
+      return true;
+    }
+
+    if (
+      Expression.check(newNode) &&
+      Expression.check(oldNode) &&
+      // If we have no .loc information for oldNode, then we won't be
+      // able to reprint it.
+      oldNode.loc
+    ) {
+      // If both nodes are subtypes of Expression, then we should be able
+      // to fill the location occupied by the old node with code printed
+      // for the new node with no ill consequences.
+      reprints.push({
+        oldPath: oldPath.copy(),
+        newPath: newPath.copy(),
+      });
+
+      return true;
+    }
+
+    // The nodes have different types, and at least one of the types is
+    // not a subtype of the Expression type, so we cannot safely assume
+    // the nodes are syntactically interchangeable.
+    return false;
+  }
+
+  return findChildReprints(newPath, oldPath, reprints);
+}
+
+function findChildReprints(newPath: any, oldPath: any, reprints: any) {
+  const newNode = newPath.getValue();
+  const oldNode = oldPath.getValue();
+
+  isObject.assert(newNode);
+  isObject.assert(oldNode);
+
+  if (newNode.original === null) {
+    // If newNode.original node was set to null, reprint the node.
+    return false;
+  }
+
+  // If this node needs parentheses and will not be wrapped with
+  // parentheses when reprinted, then return false to skip reprinting and
+  // let it be printed generically.
+  if (newPath.needsParens() && !oldPath.hasParens()) {
+    return false;
+  }
+
+  const keys = getUnionOfKeys(oldNode, newNode);
+
+  if (oldNode.type === "File" || newNode.type === "File") {
+    // Don't bother traversing file.tokens, an often very large array
+    // returned by Babylon, and useless for our purposes.
+    delete keys.tokens;
+  }
+
+  // Don't bother traversing .loc objects looking for reprintable nodes.
+  delete keys.loc;
+
+  const originalReprintCount = reprints.length;
+
+  for (let k in keys) {
+    if (k.charAt(0) === "_") {
+      // Ignore "private" AST properties added by e.g. Babel plugins and
+      // parsers like Babylon.
+      continue;
+    }
+
+    newPath.stack.push(k, types.getFieldValue(newNode, k));
+    oldPath.stack.push(k, types.getFieldValue(oldNode, k));
+    const canReprint = findAnyReprints(newPath, oldPath, reprints);
+    newPath.stack.length -= 2;
+    oldPath.stack.length -= 2;
+
+    if (!canReprint) {
+      return false;
+    }
+  }
+
+  // Return statements might end up running into ASI issues due to
+  // comments inserted deep within the tree, so reprint them if anything
+  // changed within them.
+  if (
+    ReturnStatement.check(newPath.getNode()) &&
+    reprints.length > originalReprintCount
+  ) {
+    return false;
+  }
+
+  return true;
+}
diff --git a/node_modules/recast/lib/printer.js b/node_modules/recast/lib/printer.js
index e5026f5..2a8707c 100644
--- a/node_modules/recast/lib/printer.js
+++ b/node_modules/recast/lib/printer.js
@@ -4,12 +4,12 @@ exports.Printer = void 0;
 var tslib_1 = require("tslib");
 var assert_1 = tslib_1.__importDefault(require("assert"));
 var types = tslib_1.__importStar(require("ast-types"));
-var comments_1 = require("./comments");
-var fast_path_1 = tslib_1.__importDefault(require("./fast-path"));
-var lines_1 = require("./lines");
-var options_1 = require("./options");
-var patcher_1 = require("./patcher");
-var util = tslib_1.__importStar(require("./util"));
+var comments_js_1 = require("./comments.js");
+var fast_path_js_1 = tslib_1.__importDefault(require("./fast-path.js"));
+var lines_js_1 = require("./lines.js");
+var options_js_1 = require("./options.js");
+var patcher_js_1 = require("./patcher.js");
+var util = tslib_1.__importStar(require("./util.js"));
 var namedTypes = types.namedTypes;
 var isString = types.builtInTypes.string;
 var isObject = types.builtInTypes.object;
@@ -37,7 +37,7 @@ var emptyPrintResult = new PrintResult("");
 var Printer = function Printer(config) {
     assert_1.default.ok(this instanceof Printer);
     var explicitTabWidth = config && config.tabWidth;
-    config = (0, options_1.normalize)(config);
+    config = (0, options_js_1.normalize)(config);
     // It's common for client code to pass the same options into both
     // recast.parse and recast.print, but the Printer doesn't need (and
     // can be confused by) config.sourceFileName, so we null it out.
@@ -49,10 +49,10 @@ var Printer = function Printer(config) {
         return function (path) { return print(path, options); };
     }
     function print(path, options) {
-        assert_1.default.ok(path instanceof fast_path_1.default);
+        assert_1.default.ok(path instanceof fast_path_js_1.default);
         options = options || {};
         if (options.includeComments) {
-            return (0, comments_1.printComments)(path, makePrintFunctionWith(options, {
+            return (0, comments_js_1.printComments)(path, makePrintFunctionWith(options, {
                 includeComments: false,
             }));
         }
@@ -63,7 +63,7 @@ var Printer = function Printer(config) {
                 config.tabWidth = loc.lines.guessTabWidth();
             }
         }
-        var reprinter = (0, patcher_1.getReprinter)(path);
+        var reprinter = (0, patcher_js_1.getReprinter)(path);
         var lines = reprinter
             ? // Since the print function that we pass to the reprinter will
                 // be used to print "new" nodes, it's tempting to think we
@@ -85,7 +85,7 @@ var Printer = function Printer(config) {
         if (!ast) {
             return emptyPrintResult;
         }
-        var lines = print(fast_path_1.default.from(ast), {
+        var lines = print(fast_path_js_1.default.from(ast), {
             includeComments: true,
             avoidRootParens: false,
         });
@@ -97,14 +97,14 @@ var Printer = function Printer(config) {
         }
         // Print the entire AST generically.
         function printGenerically(path) {
-            return (0, comments_1.printComments)(path, function (path) {
+            return (0, comments_js_1.printComments)(path, function (path) {
                 return genericPrint(path, config, {
                     includeComments: true,
                     avoidRootParens: false,
                 }, printGenerically);
             });
         }
-        var path = fast_path_1.default.from(ast);
+        var path = fast_path_js_1.default.from(ast);
         var oldReuseWhitespace = config.reuseWhitespace;
         // Do not reuse whitespace (or anything else, for that matter)
         // when printing generically.
@@ -117,7 +117,7 @@ var Printer = function Printer(config) {
 };
 exports.Printer = Printer;
 function genericPrint(path, config, options, printPath) {
-    assert_1.default.ok(path instanceof fast_path_1.default);
+    assert_1.default.ok(path instanceof fast_path_js_1.default);
     var node = path.getValue();
     var parts = [];
     var linesWithoutParens = genericPrintNoParens(path, config, printPath);
@@ -143,7 +143,7 @@ function genericPrint(path, config, options, printPath) {
     if (shouldAddParens) {
         parts.push(")");
     }
-    return (0, lines_1.concat)(parts);
+    return (0, lines_js_1.concat)(parts);
 }
 // Note that the `options` parameter of this function is what other
 // functions in this file call the `config` object (that is, the
@@ -152,10 +152,10 @@ function genericPrint(path, config, options, printPath) {
 function genericPrintNoParens(path, options, print) {
     var n = path.getValue();
     if (!n) {
-        return (0, lines_1.fromString)("");
+        return (0, lines_js_1.fromString)("");
     }
     if (typeof n === "string") {
-        return (0, lines_1.fromString)(n, options);
+        return (0, lines_js_1.fromString)(n, options);
     }
     namedTypes.Printable.assert(n);
     var parts = [];
@@ -173,24 +173,24 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(path.call(print, "interpreter"));
             }
             parts.push(path.call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, "body"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "Noop": // Babel extension.
         case "EmptyStatement":
-            return (0, lines_1.fromString)("");
+            return (0, lines_js_1.fromString)("");
         case "ExpressionStatement":
-            return (0, lines_1.concat)([path.call(print, "expression"), ";"]);
+            return (0, lines_js_1.concat)([path.call(print, "expression"), ";"]);
         case "ParenthesizedExpression": // Babel extension.
-            return (0, lines_1.concat)(["(", path.call(print, "expression"), ")"]);
+            return (0, lines_js_1.concat)(["(", path.call(print, "expression"), ")"]);
         case "BinaryExpression":
         case "LogicalExpression":
         case "AssignmentExpression":
-            return (0, lines_1.fromString)(" ").join([
+            return (0, lines_js_1.fromString)(" ").join([
                 path.call(print, "left"),
                 n.operator,
                 path.call(print, "right"),
             ]);
         case "AssignmentPattern":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "left"),
                 " = ",
                 path.call(print, "right"),
@@ -208,12 +208,12 @@ function genericPrintNoParens(path, options, print) {
             else {
                 parts.push(optional ? "?." : ".", property);
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "ChainExpression":
             return path.call(print, "expression");
         case "MetaProperty":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "meta"),
                 ".",
                 path.call(print, "property"),
@@ -223,12 +223,12 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(path.call(print, "object"));
             }
             parts.push("::", path.call(print, "callee"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "Path":
-            return (0, lines_1.fromString)(".").join(n.body);
+            return (0, lines_js_1.fromString)(".").join(n.body);
         case "Identifier":
-            return (0, lines_1.concat)([
-                (0, lines_1.fromString)(n.name, options),
+            return (0, lines_js_1.concat)([
+                (0, lines_js_1.fromString)(n.name, options),
                 n.optional ? "?" : "",
                 path.call(print, "typeAnnotation"),
             ]);
@@ -239,7 +239,7 @@ function genericPrintNoParens(path, options, print) {
         case "SpreadPropertyPattern":
         case "ObjectTypeSpreadProperty":
         case "RestElement":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "...",
                 path.call(print, "argument"),
                 path.call(print, "typeAnnotation"),
@@ -268,7 +268,7 @@ function genericPrintNoParens(path, options, print) {
             if (n.body) {
                 parts.push(" ", path.call(print, "body"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ArrowFunctionExpression":
             if (n.async) {
                 parts.push("async ");
@@ -288,7 +288,7 @@ function genericPrintNoParens(path, options, print) {
                 parts.push("(", printFunctionParams(path, options, print), ")", path.call(print, "returnType"));
             }
             parts.push(" => ", path.call(print, "body"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "MethodDefinition":
             return printMethod(path, options, print);
         case "YieldExpression":
@@ -297,16 +297,16 @@ function genericPrintNoParens(path, options, print) {
                 parts.push("*");
             if (n.argument)
                 parts.push(" ", path.call(print, "argument"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "AwaitExpression":
             parts.push("await");
             if (n.all)
                 parts.push("*");
             if (n.argument)
                 parts.push(" ", path.call(print, "argument"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ModuleExpression":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "module {\n",
                 path.call(print, "body").indent(options.tabWidth),
                 "\n}",
@@ -320,7 +320,7 @@ function genericPrintNoParens(path, options, print) {
             else {
                 parts.push(path.call(print, "body"));
             }
-            return (0, lines_1.fromString)(" ").join(parts);
+            return (0, lines_js_1.fromString)(" ").join(parts);
         case "ImportSpecifier":
             if (n.importKind && n.importKind !== "value") {
                 parts.push(n.importKind + " ");
@@ -337,7 +337,7 @@ function genericPrintNoParens(path, options, print) {
                     parts.push(" as ", path.call(print, "name"));
                 }
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ExportSpecifier":
             if (n.local) {
                 parts.push(path.call(print, "local"));
@@ -351,9 +351,9 @@ function genericPrintNoParens(path, options, print) {
                     parts.push(" as ", path.call(print, "name"));
                 }
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ExportBatchSpecifier":
-            return (0, lines_1.fromString)("*");
+            return (0, lines_js_1.fromString)("*");
         case "ImportNamespaceSpecifier":
             parts.push("* as ");
             if (n.local) {
@@ -362,14 +362,14 @@ function genericPrintNoParens(path, options, print) {
             else if (n.id) {
                 parts.push(path.call(print, "id"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ImportDefaultSpecifier":
             if (n.local) {
                 return path.call(print, "local");
             }
             return path.call(print, "id");
         case "TSExportAssignment":
-            return (0, lines_1.concat)(["export = ", path.call(print, "expression")]);
+            return (0, lines_js_1.concat)(["export = ", path.call(print, "expression")]);
         case "ExportDeclaration":
         case "ExportDefaultDeclaration":
         case "ExportNamedDeclaration":
@@ -380,22 +380,22 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(" as ", path.call(print, "exported"));
             }
             parts.push(" from ", path.call(print, "source"), ";");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TSNamespaceExportDeclaration":
             parts.push("export as namespace ", path.call(print, "id"));
-            return maybeAddSemicolon((0, lines_1.concat)(parts));
+            return maybeAddSemicolon((0, lines_js_1.concat)(parts));
         case "ExportNamespaceSpecifier":
-            return (0, lines_1.concat)(["* as ", path.call(print, "exported")]);
+            return (0, lines_js_1.concat)(["* as ", path.call(print, "exported")]);
         case "ExportDefaultSpecifier":
             return path.call(print, "exported");
         case "Import":
-            return (0, lines_1.fromString)("import", options);
+            return (0, lines_js_1.fromString)("import", options);
         // Recast and ast-types currently support dynamic import(...) using
         // either this dedicated ImportExpression type or a CallExpression
         // whose callee has type Import.
         // https://github.com/benjamn/ast-types/pull/365#issuecomment-605214486
         case "ImportExpression":
-            return (0, lines_1.concat)(["import(", path.call(print, "source"), ")"]);
+            return (0, lines_js_1.concat)(["import(", path.call(print, "source"), ")"]);
         case "ImportDeclaration": {
             parts.push("import ");
             if (n.importKind && n.importKind !== "value") {
@@ -421,10 +421,10 @@ function genericPrintNoParens(path, options, print) {
                     parts.push(lines);
                 });
                 if (bracedSpecifiers_1.length > 0) {
-                    var lines = (0, lines_1.fromString)(", ").join(bracedSpecifiers_1);
+                    var lines = (0, lines_js_1.fromString)(", ").join(bracedSpecifiers_1);
                     if (lines.getLineLength(1) > options.wrapColumn) {
-                        lines = (0, lines_1.concat)([
-                            (0, lines_1.fromString)(",\n").join(bracedSpecifiers_1).indent(options.tabWidth),
+                        lines = (0, lines_js_1.concat)([
+                            (0, lines_js_1.fromString)(",\n").join(bracedSpecifiers_1).indent(options.tabWidth),
                             ",",
                         ]);
                     }
@@ -444,10 +444,10 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(" from ");
             }
             parts.push(path.call(print, "source"), maybePrintImportAssertions(path, options, print), ";");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "ImportAttribute":
-            return (0, lines_1.concat)([path.call(print, "key"), ": ", path.call(print, "value")]);
+            return (0, lines_js_1.concat)([path.call(print, "key"), ": ", path.call(print, "value")]);
         case "StaticBlock":
             parts.push("static ");
         // Intentionally fall through to BlockStatement below.
@@ -456,7 +456,7 @@ function genericPrintNoParens(path, options, print) {
             if (naked_1.isEmpty()) {
                 if (!n.directives || n.directives.length === 0) {
                     parts.push("{}");
-                    return (0, lines_1.concat)(parts);
+                    return (0, lines_js_1.concat)(parts);
                 }
             }
             parts.push("{\n");
@@ -468,7 +468,7 @@ function genericPrintNoParens(path, options, print) {
             }
             parts.push(naked_1.indent(options.tabWidth));
             parts.push("\n}");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "ReturnStatement": {
             parts.push("return");
@@ -485,7 +485,7 @@ function genericPrintNoParens(path, options, print) {
                 }
             }
             parts.push(";");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "CallExpression":
         case "OptionalCallExpression":
@@ -503,7 +503,7 @@ function genericPrintNoParens(path, options, print) {
                 parts.push("?.");
             }
             parts.push(printArgumentsList(path, options, print));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "RecordExpression":
             parts.push("#");
         // Intentionally fall through to printing the object literal...
@@ -565,7 +565,7 @@ function genericPrintNoParens(path, options, print) {
                 }, field);
             });
             if (n.inexact) {
-                var line = (0, lines_1.fromString)("...", options);
+                var line = (0, lines_js_1.fromString)("...", options);
                 if (oneLine_1) {
                     if (len_1 > 0) {
                         parts.push(separator_1, " ");
@@ -585,10 +585,10 @@ function genericPrintNoParens(path, options, print) {
             if (n.typeAnnotation) {
                 parts.push(path.call(print, "typeAnnotation"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "PropertyPattern":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "key"),
                 ": ",
                 path.call(print, "pattern"),
@@ -612,7 +612,7 @@ function genericPrintNoParens(path, options, print) {
             if (!n.shorthand || n.key.name !== n.value.name) {
                 parts.push(": ", path.call(print, "value"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "ClassMethod": // Babel 6
         case "ObjectMethod": // Babel 6
@@ -620,9 +620,9 @@ function genericPrintNoParens(path, options, print) {
         case "TSDeclareMethod":
             return printMethod(path, options, print);
         case "PrivateName":
-            return (0, lines_1.concat)(["#", path.call(print, "id")]);
+            return (0, lines_js_1.concat)(["#", path.call(print, "id")]);
         case "Decorator":
-            return (0, lines_1.concat)(["@", path.call(print, "expression")]);
+            return (0, lines_js_1.concat)(["@", path.call(print, "expression")]);
         case "TupleExpression":
             parts.push("#");
         // Intentionally fall through to printing the tuple elements...
@@ -631,7 +631,7 @@ function genericPrintNoParens(path, options, print) {
             var elems = n.elements;
             var len_2 = elems.length;
             var printed_1 = path.map(print, "elements");
-            var joined = (0, lines_1.fromString)(", ").join(printed_1);
+            var joined = (0, lines_js_1.fromString)(", ").join(printed_1);
             var oneLine_2 = joined.getLineLength(1) <= options.wrapColumn;
             if (oneLine_2) {
                 if (options.arrayBracketSpacing) {
@@ -681,56 +681,56 @@ function genericPrintNoParens(path, options, print) {
             if (n.typeAnnotation) {
                 parts.push(path.call(print, "typeAnnotation"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "SequenceExpression":
-            return (0, lines_1.fromString)(", ").join(path.map(print, "expressions"));
+            return (0, lines_js_1.fromString)(", ").join(path.map(print, "expressions"));
         case "ThisExpression":
-            return (0, lines_1.fromString)("this");
+            return (0, lines_js_1.fromString)("this");
         case "Super":
-            return (0, lines_1.fromString)("super");
+            return (0, lines_js_1.fromString)("super");
         case "NullLiteral": // Babel 6 Literal split
-            return (0, lines_1.fromString)("null");
+            return (0, lines_js_1.fromString)("null");
         case "RegExpLiteral": // Babel 6 Literal split
-            return (0, lines_1.fromString)(getPossibleRaw(n) || "/".concat(n.pattern, "/").concat(n.flags || ""), options);
+            return (0, lines_js_1.fromString)(getPossibleRaw(n) || "/".concat(n.pattern, "/").concat(n.flags || ""), options);
         case "BigIntLiteral": // Babel 7 Literal split
-            return (0, lines_1.fromString)(getPossibleRaw(n) || n.value + "n", options);
+            return (0, lines_js_1.fromString)(getPossibleRaw(n) || n.value + "n", options);
         case "NumericLiteral": // Babel 6 Literal Split
-            return (0, lines_1.fromString)(getPossibleRaw(n) || n.value, options);
+            return (0, lines_js_1.fromString)(getPossibleRaw(n) || n.value, options);
         case "DecimalLiteral":
-            return (0, lines_1.fromString)(getPossibleRaw(n) || n.value + "m", options);
+            return (0, lines_js_1.fromString)(getPossibleRaw(n) || n.value + "m", options);
         case "StringLiteral":
-            return (0, lines_1.fromString)(nodeStr(n.value, options));
+            return (0, lines_js_1.fromString)(nodeStr(n.value, options));
         case "BooleanLiteral": // Babel 6 Literal split
         case "Literal":
-            return (0, lines_1.fromString)(getPossibleRaw(n) ||
+            return (0, lines_js_1.fromString)(getPossibleRaw(n) ||
                 (typeof n.value === "string" ? nodeStr(n.value, options) : n.value), options);
         case "Directive": // Babel 6
             return path.call(print, "value");
         case "DirectiveLiteral": // Babel 6
-            return (0, lines_1.fromString)(getPossibleRaw(n) || nodeStr(n.value, options), options);
+            return (0, lines_js_1.fromString)(getPossibleRaw(n) || nodeStr(n.value, options), options);
         case "InterpreterDirective":
-            return (0, lines_1.fromString)("#!".concat(n.value, "\n"), options);
+            return (0, lines_js_1.fromString)("#!".concat(n.value, "\n"), options);
         case "ModuleSpecifier":
             if (n.local) {
                 throw new Error("The ESTree ModuleSpecifier type should be abstract");
             }
             // The Esprima ModuleSpecifier type is just a string-valued
             // Literal identifying the imported-from module.
-            return (0, lines_1.fromString)(nodeStr(n.value, options), options);
+            return (0, lines_js_1.fromString)(nodeStr(n.value, options), options);
         case "UnaryExpression":
             parts.push(n.operator);
             if (/[a-z]$/.test(n.operator))
                 parts.push(" ");
             parts.push(path.call(print, "argument"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "UpdateExpression":
             parts.push(path.call(print, "argument"), n.operator);
             if (n.prefix)
                 parts.reverse();
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ConditionalExpression":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "test"),
                 " ? ",
                 path.call(print, "consequent"),
@@ -749,7 +749,7 @@ function genericPrintNoParens(path, options, print) {
             if (args) {
                 parts.push(printArgumentsList(path, options, print));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "VariableDeclaration": {
             if (n.declare) {
@@ -763,10 +763,10 @@ function genericPrintNoParens(path, options, print) {
                 return lines;
             }, "declarations");
             if (maxLen_1 === 1) {
-                parts.push((0, lines_1.fromString)(", ").join(printed));
+                parts.push((0, lines_js_1.fromString)(", ").join(printed));
             }
             else if (printed.length > 1) {
-                parts.push((0, lines_1.fromString)(",\n")
+                parts.push((0, lines_js_1.fromString)(",\n")
                     .join(printed)
                     .indentTail(n.kind.length + 1));
             }
@@ -784,17 +784,17 @@ function genericPrintNoParens(path, options, print) {
                     namedTypes.ForAwaitStatement.check(parentNode))) {
                 parts.push(";");
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "VariableDeclarator":
             return n.init
-                ? (0, lines_1.fromString)(" = ").join([
+                ? (0, lines_js_1.fromString)(" = ").join([
                     path.call(print, "id"),
                     path.call(print, "init"),
                 ])
                 : path.call(print, "id");
         case "WithStatement":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "with (",
                 path.call(print, "object"),
                 ") ",
@@ -805,17 +805,17 @@ function genericPrintNoParens(path, options, print) {
             parts.push("if (", path.call(print, "test"), ")", con);
             if (n.alternate)
                 parts.push(endsWithBrace(con) ? " else" : "\nelse", adjustClause(path.call(print, "alternate"), options));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "ForStatement": {
             // TODO Get the for (;;) case right.
             var init = path.call(print, "init");
             var sep = init.length > 1 ? ";\n" : "; ";
             var forParen = "for (";
-            var indented = (0, lines_1.fromString)(sep)
+            var indented = (0, lines_js_1.fromString)(sep)
                 .join([init, path.call(print, "test"), path.call(print, "update")])
                 .indentTail(forParen.length);
-            var head = (0, lines_1.concat)([forParen, indented, ")"]);
+            var head = (0, lines_js_1.concat)([forParen, indented, ")"]);
             var clause = adjustClause(path.call(print, "body"), options);
             parts.push(head);
             if (head.length > 1) {
@@ -823,10 +823,10 @@ function genericPrintNoParens(path, options, print) {
                 clause = clause.trimLeft();
             }
             parts.push(clause);
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "WhileStatement":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "while (",
                 path.call(print, "test"),
                 ")",
@@ -834,7 +834,7 @@ function genericPrintNoParens(path, options, print) {
             ]);
         case "ForInStatement":
             // Note: esprima can't actually parse "for each (".
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 n.each ? "for each (" : "for (",
                 path.call(print, "left"),
                 " in ",
@@ -849,9 +849,9 @@ function genericPrintNoParens(path, options, print) {
                 parts.push("await ");
             }
             parts.push("(", path.call(print, "left"), " of ", path.call(print, "right"), ")", adjustClause(path.call(print, "body"), options));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "DoWhileStatement": {
-            var doBody = (0, lines_1.concat)([
+            var doBody = (0, lines_js_1.concat)([
                 "do",
                 adjustClause(path.call(print, "body"), options),
             ]);
@@ -861,26 +861,26 @@ function genericPrintNoParens(path, options, print) {
             else
                 parts.push("\nwhile");
             parts.push(" (", path.call(print, "test"), ");");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "DoExpression": {
             var statements = path.call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, "body");
-            return (0, lines_1.concat)(["do {\n", statements.indent(options.tabWidth), "\n}"]);
+            return (0, lines_js_1.concat)(["do {\n", statements.indent(options.tabWidth), "\n}"]);
         }
         case "BreakStatement":
             parts.push("break");
             if (n.label)
                 parts.push(" ", path.call(print, "label"));
             parts.push(";");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ContinueStatement":
             parts.push("continue");
             if (n.label)
                 parts.push(" ", path.call(print, "label"));
             parts.push(";");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "LabeledStatement":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "label"),
                 ":\n",
                 path.call(print, "body"),
@@ -898,7 +898,7 @@ function genericPrintNoParens(path, options, print) {
             if (n.finalizer) {
                 parts.push(" finally ", path.call(print, "finalizer"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "CatchClause":
             parts.push("catch ");
             if (n.param) {
@@ -912,15 +912,15 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(") ");
             }
             parts.push(path.call(print, "body"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ThrowStatement":
-            return (0, lines_1.concat)(["throw ", path.call(print, "argument"), ";"]);
+            return (0, lines_js_1.concat)(["throw ", path.call(print, "argument"), ";"]);
         case "SwitchStatement":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "switch (",
                 path.call(print, "discriminant"),
                 ") {\n",
-                (0, lines_1.fromString)("\n").join(path.map(print, "cases")),
+                (0, lines_js_1.fromString)("\n").join(path.map(print, "cases")),
                 "\n}",
             ]);
         // Note: ignoring n.lexical because it has no printing consequences.
@@ -936,33 +936,33 @@ function genericPrintNoParens(path, options, print) {
                 }, "consequent")
                     .indent(options.tabWidth));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "DebuggerStatement":
-            return (0, lines_1.fromString)("debugger;");
+            return (0, lines_js_1.fromString)("debugger;");
         // JSX extensions below.
         case "JSXAttribute":
             parts.push(path.call(print, "name"));
             if (n.value)
                 parts.push("=", path.call(print, "value"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "JSXIdentifier":
-            return (0, lines_1.fromString)(n.name, options);
+            return (0, lines_js_1.fromString)(n.name, options);
         case "JSXNamespacedName":
-            return (0, lines_1.fromString)(":").join([
+            return (0, lines_js_1.fromString)(":").join([
                 path.call(print, "namespace"),
                 path.call(print, "name"),
             ]);
         case "JSXMemberExpression":
-            return (0, lines_1.fromString)(".").join([
+            return (0, lines_js_1.fromString)(".").join([
                 path.call(print, "object"),
                 path.call(print, "property"),
             ]);
         case "JSXSpreadAttribute":
-            return (0, lines_1.concat)(["{...", path.call(print, "argument"), "}"]);
+            return (0, lines_js_1.concat)(["{...", path.call(print, "argument"), "}"]);
         case "JSXSpreadChild":
-            return (0, lines_1.concat)(["{...", path.call(print, "expression"), "}"]);
+            return (0, lines_js_1.concat)(["{...", path.call(print, "expression"), "}"]);
         case "JSXExpressionContainer":
-            return (0, lines_1.concat)(["{", path.call(print, "expression"), "}"]);
+            return (0, lines_js_1.concat)(["{", path.call(print, "expression"), "}"]);
         case "JSXElement":
         case "JSXFragment": {
             var openingPropName = "opening" + (n.type === "JSXElement" ? "Element" : "Fragment");
@@ -975,7 +975,7 @@ function genericPrintNoParens(path, options, print) {
                     n.type);
                 return openingLines;
             }
-            var childLines = (0, lines_1.concat)(path.map(function (childPath) {
+            var childLines = (0, lines_js_1.concat)(path.map(function (childPath) {
                 var child = childPath.getValue();
                 if (namedTypes.Literal.check(child) &&
                     typeof child.value === "string") {
@@ -989,7 +989,7 @@ function genericPrintNoParens(path, options, print) {
                 return print(childPath);
             }, "children")).indentTail(options.tabWidth);
             var closingLines = path.call(print, closingPropName);
-            return (0, lines_1.concat)([openingLines, childLines, closingLines]);
+            return (0, lines_js_1.concat)([openingLines, childLines, closingLines]);
         }
         case "JSXOpeningElement": {
             parts.push("<", path.call(print, "name"));
@@ -997,7 +997,7 @@ function genericPrintNoParens(path, options, print) {
             path.each(function (attrPath) {
                 attrParts_1.push(" ", print(attrPath));
             }, "attributes");
-            var attrLines = (0, lines_1.concat)(attrParts_1);
+            var attrLines = (0, lines_js_1.concat)(attrParts_1);
             var needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn;
             if (needLineWrap) {
                 attrParts_1.forEach(function (part, i) {
@@ -1006,32 +1006,32 @@ function genericPrintNoParens(path, options, print) {
                         attrParts_1[i] = "\n";
                     }
                 });
-                attrLines = (0, lines_1.concat)(attrParts_1).indentTail(options.tabWidth);
+                attrLines = (0, lines_js_1.concat)(attrParts_1).indentTail(options.tabWidth);
             }
             parts.push(attrLines, n.selfClosing ? " />" : ">");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "JSXClosingElement":
-            return (0, lines_1.concat)(["</", path.call(print, "name"), ">"]);
+            return (0, lines_js_1.concat)(["</", path.call(print, "name"), ">"]);
         case "JSXOpeningFragment":
-            return (0, lines_1.fromString)("<>");
+            return (0, lines_js_1.fromString)("<>");
         case "JSXClosingFragment":
-            return (0, lines_1.fromString)("</>");
+            return (0, lines_js_1.fromString)("</>");
         case "JSXText":
-            return (0, lines_1.fromString)(n.value, options);
+            return (0, lines_js_1.fromString)(n.value, options);
         case "JSXEmptyExpression":
-            return (0, lines_1.fromString)("");
+            return (0, lines_js_1.fromString)("");
         case "TypeAnnotatedIdentifier":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "annotation"),
                 " ",
                 path.call(print, "identifier"),
             ]);
         case "ClassBody":
             if (n.body.length === 0) {
-                return (0, lines_1.fromString)("{}");
+                return (0, lines_js_1.fromString)("{}");
             }
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "{\n",
                 path
                     .call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, "body")
@@ -1042,7 +1042,7 @@ function genericPrintNoParens(path, options, print) {
             parts.push("static ", path.call(print, "definition"));
             if (!namedTypes.MethodDefinition.check(n.definition))
                 parts.push(";");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ClassProperty": {
             if (n.declare) {
                 parts.push("declare ");
@@ -1062,10 +1062,10 @@ function genericPrintNoParens(path, options, print) {
             }
             var key = path.call(print, "key");
             if (n.computed) {
-                key = (0, lines_1.concat)(["[", key, "]"]);
+                key = (0, lines_js_1.concat)(["[", key, "]"]);
             }
             if (n.variance) {
-                key = (0, lines_1.concat)([printVariance(path, print), key]);
+                key = (0, lines_js_1.concat)([printVariance(path, print), key]);
             }
             parts.push(key);
             if (n.optional) {
@@ -1081,7 +1081,7 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(" = ", path.call(print, "value"));
             }
             parts.push(";");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "ClassPrivateProperty":
             if (n.static) {
@@ -1095,7 +1095,7 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(" = ", path.call(print, "value"));
             }
             parts.push(";");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ClassAccessorProperty": {
             parts.push.apply(parts, tslib_1.__spreadArray(tslib_1.__spreadArray([], printClassMemberModifiers(n), false), ["accessor "], false));
             if (n.computed) {
@@ -1117,7 +1117,7 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(" = ", path.call(print, "value"));
             }
             parts.push(";");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "ClassDeclaration":
         case "ClassExpression":
@@ -1141,20 +1141,20 @@ function genericPrintNoParens(path, options, print) {
             }
             if (n.extends && n.extends.length > 0) {
                 // DeclareClass only
-                parts.push(" extends ", (0, lines_1.fromString)(", ").join(path.map(print, "extends")));
+                parts.push(" extends ", (0, lines_js_1.fromString)(", ").join(path.map(print, "extends")));
             }
             if (n["implements"] && n["implements"].length > 0) {
-                parts.push(" implements ", (0, lines_1.fromString)(", ").join(path.map(print, "implements")));
+                parts.push(" implements ", (0, lines_js_1.fromString)(", ").join(path.map(print, "implements")));
             }
             parts.push(" ", path.call(print, "body"));
             if (n.type === "DeclareClass") {
                 return printFlowDeclaration(path, parts);
             }
             else {
-                return (0, lines_1.concat)(parts);
+                return (0, lines_js_1.concat)(parts);
             }
         case "TemplateElement":
-            return (0, lines_1.fromString)(n.value.raw, options).lockIndentTail();
+            return (0, lines_js_1.fromString)(n.value.raw, options).lockIndentTail();
         case "TemplateLiteral": {
             var expressions_1 = path.map(print, "expressions");
             parts.push("`");
@@ -1166,10 +1166,10 @@ function genericPrintNoParens(path, options, print) {
                 }
             }, "quasis");
             parts.push("`");
-            return (0, lines_1.concat)(parts).lockIndentTail();
+            return (0, lines_js_1.concat)(parts).lockIndentTail();
         }
         case "TaggedTemplateExpression":
-            return (0, lines_1.concat)([path.call(print, "tag"), path.call(print, "quasi")]);
+            return (0, lines_js_1.concat)([path.call(print, "tag"), path.call(print, "quasi")]);
         // These types are unprintable because they serve as abstract
         // supertypes for other (printable) types.
         case "Node":
@@ -1196,10 +1196,10 @@ function genericPrintNoParens(path, options, print) {
             throw new Error("unprintable type: " + JSON.stringify(n.type));
         case "CommentBlock": // Babel block comment.
         case "Block": // Esprima block comment.
-            return (0, lines_1.concat)(["/*", (0, lines_1.fromString)(n.value, options), "*/"]);
+            return (0, lines_js_1.concat)(["/*", (0, lines_js_1.fromString)(n.value, options), "*/"]);
         case "CommentLine": // Babel line comment.
         case "Line": // Esprima line comment.
-            return (0, lines_1.concat)(["//", (0, lines_1.fromString)(n.value, options)]);
+            return (0, lines_js_1.concat)(["//", (0, lines_js_1.fromString)(n.value, options)]);
         // Type Annotations for Facebook Flow, typically stripped out or
         // transformed away before printing.
         case "TypeAnnotation":
@@ -1208,23 +1208,23 @@ function genericPrintNoParens(path, options, print) {
                     parts.push(": ");
                 }
                 parts.push(path.call(print, "typeAnnotation"));
-                return (0, lines_1.concat)(parts);
+                return (0, lines_js_1.concat)(parts);
             }
-            return (0, lines_1.fromString)("");
+            return (0, lines_js_1.fromString)("");
         case "ExistentialTypeParam":
         case "ExistsTypeAnnotation":
-            return (0, lines_1.fromString)("*", options);
+            return (0, lines_js_1.fromString)("*", options);
         case "EmptyTypeAnnotation":
-            return (0, lines_1.fromString)("empty", options);
+            return (0, lines_js_1.fromString)("empty", options);
         case "AnyTypeAnnotation":
-            return (0, lines_1.fromString)("any", options);
+            return (0, lines_js_1.fromString)("any", options);
         case "MixedTypeAnnotation":
-            return (0, lines_1.fromString)("mixed", options);
+            return (0, lines_js_1.fromString)("mixed", options);
         case "ArrayTypeAnnotation":
-            return (0, lines_1.concat)([path.call(print, "elementType"), "[]"]);
+            return (0, lines_js_1.concat)([path.call(print, "elementType"), "[]"]);
         case "TupleTypeAnnotation": {
             var printed_2 = path.map(print, "types");
-            var joined = (0, lines_1.fromString)(", ").join(printed_2);
+            var joined = (0, lines_js_1.fromString)(", ").join(printed_2);
             var oneLine_3 = joined.getLineLength(1) <= options.wrapColumn;
             if (oneLine_3) {
                 if (options.arrayBracketSpacing) {
@@ -1271,20 +1271,20 @@ function genericPrintNoParens(path, options, print) {
             else {
                 parts.push("]");
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "BooleanTypeAnnotation":
-            return (0, lines_1.fromString)("boolean", options);
+            return (0, lines_js_1.fromString)("boolean", options);
         case "BooleanLiteralTypeAnnotation":
             assert_1.default.strictEqual(typeof n.value, "boolean");
-            return (0, lines_1.fromString)("" + n.value, options);
+            return (0, lines_js_1.fromString)("" + n.value, options);
         case "InterfaceTypeAnnotation":
             parts.push("interface");
             if (n.extends && n.extends.length > 0) {
-                parts.push(" extends ", (0, lines_1.fromString)(", ").join(path.map(print, "extends")));
+                parts.push(" extends ", (0, lines_js_1.fromString)(", ").join(path.map(print, "extends")));
             }
             parts.push(" ", path.call(print, "body"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "DeclareFunction":
             return printFlowDeclaration(path, [
                 "function ",
@@ -1307,9 +1307,9 @@ function genericPrintNoParens(path, options, print) {
             return printFlowDeclaration(path, ["var ", path.call(print, "id"), ";"]);
         case "DeclareExportDeclaration":
         case "DeclareExportAllDeclaration":
-            return (0, lines_1.concat)(["declare ", printExportDeclaration(path, options, print)]);
+            return (0, lines_js_1.concat)(["declare ", printExportDeclaration(path, options, print)]);
         case "EnumDeclaration":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "enum ",
                 path.call(print, "id"),
                 path.call(print, "body"),
@@ -1323,26 +1323,26 @@ function genericPrintNoParens(path, options, print) {
                 // EnumBooleanBody => boolean, etc.
                 n.type.slice(4, -4).toLowerCase());
             }
-            parts.push(" {\n", (0, lines_1.fromString)("\n")
+            parts.push(" {\n", (0, lines_js_1.fromString)("\n")
                 .join(path.map(print, "members"))
                 .indent(options.tabWidth), "\n}");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "EnumDefaultedMember":
-            return (0, lines_1.concat)([path.call(print, "id"), ","]);
+            return (0, lines_js_1.concat)([path.call(print, "id"), ","]);
         case "EnumBooleanMember":
         case "EnumNumberMember":
         case "EnumStringMember":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "id"),
                 " = ",
                 path.call(print, "init"),
                 ",",
             ]);
         case "InferredPredicate":
-            return (0, lines_1.fromString)("%checks", options);
+            return (0, lines_js_1.fromString)("%checks", options);
         case "DeclaredPredicate":
-            return (0, lines_1.concat)(["%checks(", path.call(print, "value"), ")"]);
+            return (0, lines_js_1.concat)(["%checks(", path.call(print, "value"), ")"]);
         case "FunctionTypeAnnotation": {
             // FunctionTypeAnnotation is ambiguous:
             // declare function(a: B): void; OR
@@ -1365,7 +1365,7 @@ function genericPrintNoParens(path, options, print) {
             if (n.returnType) {
                 parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path.call(print, "returnType"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "FunctionTypeParam": {
             var name = path.call(print, "name");
@@ -1377,10 +1377,10 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(": ");
             }
             parts.push(path.call(print, "typeAnnotation"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "GenericTypeAnnotation":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "id"),
                 path.call(print, "typeParameters"),
             ]);
@@ -1394,28 +1394,28 @@ function genericPrintNoParens(path, options, print) {
             }
             parts.push("interface ", path.call(print, "id"), path.call(print, "typeParameters"), " ");
             if (n["extends"] && n["extends"].length > 0) {
-                parts.push("extends ", (0, lines_1.fromString)(", ").join(path.map(print, "extends")), " ");
+                parts.push("extends ", (0, lines_js_1.fromString)(", ").join(path.map(print, "extends")), " ");
             }
             if (n.body) {
                 parts.push(path.call(print, "body"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ClassImplements":
         case "InterfaceExtends":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "id"),
                 path.call(print, "typeParameters"),
             ]);
         case "IntersectionTypeAnnotation":
-            return (0, lines_1.fromString)(" & ").join(path.map(print, "types"));
+            return (0, lines_js_1.fromString)(" & ").join(path.map(print, "types"));
         case "NullableTypeAnnotation":
-            return (0, lines_1.concat)(["?", path.call(print, "typeAnnotation")]);
+            return (0, lines_js_1.concat)(["?", path.call(print, "typeAnnotation")]);
         case "NullLiteralTypeAnnotation":
-            return (0, lines_1.fromString)("null", options);
+            return (0, lines_js_1.fromString)("null", options);
         case "ThisTypeAnnotation":
-            return (0, lines_1.fromString)("this", options);
+            return (0, lines_js_1.fromString)("this", options);
         case "NumberTypeAnnotation":
-            return (0, lines_1.fromString)("number", options);
+            return (0, lines_js_1.fromString)("number", options);
         case "ObjectTypeCallProperty":
             return path.call(print, "value");
         case "ObjectTypeIndexer":
@@ -1427,9 +1427,9 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(path.call(print, "id"), ": ");
             }
             parts.push(path.call(print, "key"), "]: ", path.call(print, "value"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "ObjectTypeProperty":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 printVariance(path, print),
                 path.call(print, "key"),
                 n.optional ? "?" : "",
@@ -1437,7 +1437,7 @@ function genericPrintNoParens(path, options, print) {
                 path.call(print, "value"),
             ]);
         case "ObjectTypeInternalSlot":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 n.static ? "static " : "",
                 "[[",
                 path.call(print, "id"),
@@ -1447,26 +1447,26 @@ function genericPrintNoParens(path, options, print) {
                 path.call(print, "value"),
             ]);
         case "QualifiedTypeIdentifier":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "qualification"),
                 ".",
                 path.call(print, "id"),
             ]);
         case "StringLiteralTypeAnnotation":
-            return (0, lines_1.fromString)(nodeStr(n.value, options), options);
+            return (0, lines_js_1.fromString)(nodeStr(n.value, options), options);
         case "NumberLiteralTypeAnnotation":
         case "NumericLiteralTypeAnnotation":
             assert_1.default.strictEqual(typeof n.value, "number");
-            return (0, lines_1.fromString)(JSON.stringify(n.value), options);
+            return (0, lines_js_1.fromString)(JSON.stringify(n.value), options);
         case "BigIntLiteralTypeAnnotation":
-            return (0, lines_1.fromString)(n.raw, options);
+            return (0, lines_js_1.fromString)(n.raw, options);
         case "StringTypeAnnotation":
-            return (0, lines_1.fromString)("string", options);
+            return (0, lines_js_1.fromString)("string", options);
         case "DeclareTypeAlias":
             parts.push("declare ");
         // Fall through to TypeAlias...
         case "TypeAlias":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "type ",
                 path.call(print, "id"),
                 path.call(print, "typeParameters"),
@@ -1486,9 +1486,9 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(" = ", path.call(print, "impltype"));
             }
             parts.push(";");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TypeCastExpression":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "(",
                 path.call(print, "expression"),
                 path.call(print, "typeAnnotation"),
@@ -1496,19 +1496,19 @@ function genericPrintNoParens(path, options, print) {
             ]);
         case "TypeParameterDeclaration":
         case "TypeParameterInstantiation":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "<",
-                (0, lines_1.fromString)(", ").join(path.map(print, "params")),
+                (0, lines_js_1.fromString)(", ").join(path.map(print, "params")),
                 ">",
             ]);
         case "Variance":
             if (n.kind === "plus") {
-                return (0, lines_1.fromString)("+");
+                return (0, lines_js_1.fromString)("+");
             }
             if (n.kind === "minus") {
-                return (0, lines_1.fromString)("-");
+                return (0, lines_js_1.fromString)("-");
             }
-            return (0, lines_1.fromString)("");
+            return (0, lines_js_1.fromString)("");
         case "TypeParameter":
             if (n.variance) {
                 parts.push(printVariance(path, print));
@@ -1520,15 +1520,15 @@ function genericPrintNoParens(path, options, print) {
             if (n["default"]) {
                 parts.push("=", path.call(print, "default"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TypeofTypeAnnotation":
-            return (0, lines_1.concat)([
-                (0, lines_1.fromString)("typeof ", options),
+            return (0, lines_js_1.concat)([
+                (0, lines_js_1.fromString)("typeof ", options),
                 path.call(print, "argument"),
             ]);
         case "IndexedAccessType":
         case "OptionalIndexedAccessType":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "objectType"),
                 n.optional ? "?." : "",
                 "[",
@@ -1536,64 +1536,64 @@ function genericPrintNoParens(path, options, print) {
                 "]",
             ]);
         case "UnionTypeAnnotation":
-            return (0, lines_1.fromString)(" | ").join(path.map(print, "types"));
+            return (0, lines_js_1.fromString)(" | ").join(path.map(print, "types"));
         case "VoidTypeAnnotation":
-            return (0, lines_1.fromString)("void", options);
+            return (0, lines_js_1.fromString)("void", options);
         case "NullTypeAnnotation":
-            return (0, lines_1.fromString)("null", options);
+            return (0, lines_js_1.fromString)("null", options);
         case "SymbolTypeAnnotation":
-            return (0, lines_1.fromString)("symbol", options);
+            return (0, lines_js_1.fromString)("symbol", options);
         case "BigIntTypeAnnotation":
-            return (0, lines_1.fromString)("bigint", options);
+            return (0, lines_js_1.fromString)("bigint", options);
         // Type Annotations for TypeScript (when using Babylon as parser)
         case "TSType":
             throw new Error("unprintable type: " + JSON.stringify(n.type));
         case "TSNumberKeyword":
-            return (0, lines_1.fromString)("number", options);
+            return (0, lines_js_1.fromString)("number", options);
         case "TSBigIntKeyword":
-            return (0, lines_1.fromString)("bigint", options);
+            return (0, lines_js_1.fromString)("bigint", options);
         case "TSObjectKeyword":
-            return (0, lines_1.fromString)("object", options);
+            return (0, lines_js_1.fromString)("object", options);
         case "TSBooleanKeyword":
-            return (0, lines_1.fromString)("boolean", options);
+            return (0, lines_js_1.fromString)("boolean", options);
         case "TSStringKeyword":
-            return (0, lines_1.fromString)("string", options);
+            return (0, lines_js_1.fromString)("string", options);
         case "TSSymbolKeyword":
-            return (0, lines_1.fromString)("symbol", options);
+            return (0, lines_js_1.fromString)("symbol", options);
         case "TSAnyKeyword":
-            return (0, lines_1.fromString)("any", options);
+            return (0, lines_js_1.fromString)("any", options);
         case "TSVoidKeyword":
-            return (0, lines_1.fromString)("void", options);
+            return (0, lines_js_1.fromString)("void", options);
         case "TSIntrinsicKeyword":
-            return (0, lines_1.fromString)("intrinsic", options);
+            return (0, lines_js_1.fromString)("intrinsic", options);
         case "TSThisType":
-            return (0, lines_1.fromString)("this", options);
+            return (0, lines_js_1.fromString)("this", options);
         case "TSNullKeyword":
-            return (0, lines_1.fromString)("null", options);
+            return (0, lines_js_1.fromString)("null", options);
         case "TSUndefinedKeyword":
-            return (0, lines_1.fromString)("undefined", options);
+            return (0, lines_js_1.fromString)("undefined", options);
         case "TSUnknownKeyword":
-            return (0, lines_1.fromString)("unknown", options);
+            return (0, lines_js_1.fromString)("unknown", options);
         case "TSNeverKeyword":
-            return (0, lines_1.fromString)("never", options);
+            return (0, lines_js_1.fromString)("never", options);
         case "TSArrayType":
-            return (0, lines_1.concat)([path.call(print, "elementType"), "[]"]);
+            return (0, lines_js_1.concat)([path.call(print, "elementType"), "[]"]);
         case "TSLiteralType":
             return path.call(print, "literal");
         case "TSUnionType":
-            return (0, lines_1.fromString)(" | ").join(path.map(print, "types"));
+            return (0, lines_js_1.fromString)(" | ").join(path.map(print, "types"));
         case "TSIntersectionType":
-            return (0, lines_1.fromString)(" & ").join(path.map(print, "types"));
+            return (0, lines_js_1.fromString)(" & ").join(path.map(print, "types"));
         case "TSConditionalType":
             parts.push(path.call(print, "checkType"), " extends ", path.call(print, "extendsType"), " ? ", path.call(print, "trueType"), " : ", path.call(print, "falseType"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TSInferType":
             parts.push("infer ", path.call(print, "typeParameter"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TSParenthesizedType":
-            return (0, lines_1.concat)(["(", path.call(print, "typeAnnotation"), ")"]);
+            return (0, lines_js_1.concat)(["(", path.call(print, "typeAnnotation"), ")"]);
         case "TSFunctionType":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "typeParameters"),
                 "(",
                 printFunctionParams(path, options, print),
@@ -1601,7 +1601,7 @@ function genericPrintNoParens(path, options, print) {
                 path.call(print, "typeAnnotation", "typeAnnotation"),
             ]);
         case "TSConstructorType":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "new ",
                 path.call(print, "typeParameters"),
                 "(",
@@ -1614,12 +1614,12 @@ function genericPrintNoParens(path, options, print) {
             if (n.typeAnnotation) {
                 parts.push(": ", path.call(print, "typeAnnotation"), ";");
             }
-            return (0, lines_1.concat)(["{\n", (0, lines_1.concat)(parts).indent(options.tabWidth), "\n}"]);
+            return (0, lines_js_1.concat)(["{\n", (0, lines_js_1.concat)(parts).indent(options.tabWidth), "\n}"]);
         }
         case "TSTupleType":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "[",
-                (0, lines_1.fromString)(", ").join(path.map(print, "elementTypes")),
+                (0, lines_js_1.fromString)(", ").join(path.map(print, "elementTypes")),
                 "]",
             ]);
         case "TSNamedTupleMember":
@@ -1628,45 +1628,45 @@ function genericPrintNoParens(path, options, print) {
                 parts.push("?");
             }
             parts.push(": ", path.call(print, "elementType"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TSRestType":
-            return (0, lines_1.concat)(["...", path.call(print, "typeAnnotation")]);
+            return (0, lines_js_1.concat)(["...", path.call(print, "typeAnnotation")]);
         case "TSOptionalType":
-            return (0, lines_1.concat)([path.call(print, "typeAnnotation"), "?"]);
+            return (0, lines_js_1.concat)([path.call(print, "typeAnnotation"), "?"]);
         case "TSIndexedAccessType":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "objectType"),
                 "[",
                 path.call(print, "indexType"),
                 "]",
             ]);
         case "TSTypeOperator":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "operator"),
                 " ",
                 path.call(print, "typeAnnotation"),
             ]);
         case "TSTypeLiteral": {
-            var members = (0, lines_1.fromString)("\n").join(path.map(print, "members").map(function (member) {
+            var members = (0, lines_js_1.fromString)("\n").join(path.map(print, "members").map(function (member) {
                 if (lastNonSpaceCharacter(member) !== ";") {
                     return member.concat(";");
                 }
                 return member;
             }));
             if (members.isEmpty()) {
-                return (0, lines_1.fromString)("{}", options);
+                return (0, lines_js_1.fromString)("{}", options);
             }
             parts.push("{\n", members.indent(options.tabWidth), "\n}");
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "TSEnumMember":
             parts.push(path.call(print, "id"));
             if (n.initializer) {
                 parts.push(" = ", path.call(print, "initializer"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TSTypeQuery":
-            return (0, lines_1.concat)(["typeof ", path.call(print, "exprName")]);
+            return (0, lines_js_1.concat)(["typeof ", path.call(print, "exprName")]);
         case "TSParameterProperty":
             if (n.accessibility) {
                 parts.push(n.accessibility, " ");
@@ -1681,32 +1681,32 @@ function genericPrintNoParens(path, options, print) {
                 parts.push("readonly ");
             }
             parts.push(path.call(print, "parameter"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TSTypeReference":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "typeName"),
                 path.call(print, "typeParameters"),
             ]);
         case "TSQualifiedName":
-            return (0, lines_1.concat)([path.call(print, "left"), ".", path.call(print, "right")]);
+            return (0, lines_js_1.concat)([path.call(print, "left"), ".", path.call(print, "right")]);
         case "TSAsExpression":
         case "TSSatisfiesExpression":
             {
                 var expression = path.call(print, "expression");
                 parts.push(expression, n.type === "TSSatisfiesExpression" ? " satisfies " : " as ", path.call(print, "typeAnnotation"));
-                return (0, lines_1.concat)(parts);
+                return (0, lines_js_1.concat)(parts);
             }
         case "TSTypeCastExpression":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "expression"),
                 path.call(print, "typeAnnotation"),
             ]);
         case "TSNonNullExpression":
-            return (0, lines_1.concat)([path.call(print, "expression"), "!"]);
+            return (0, lines_js_1.concat)([path.call(print, "expression"), "!"]);
         case "TSTypeAnnotation":
-            return (0, lines_1.concat)([": ", path.call(print, "typeAnnotation")]);
+            return (0, lines_js_1.concat)([": ", path.call(print, "typeAnnotation")]);
         case "TSIndexSignature":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 n.readonly ? "readonly " : "",
                 "[",
                 path.map(print, "parameters"),
@@ -1722,7 +1722,7 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(path.call(print, "key"));
             }
             parts.push(n.optional ? "?" : "", path.call(print, "typeAnnotation"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TSMethodSignature":
             if (n.computed) {
                 parts.push("[", path.call(print, "key"), "]");
@@ -1734,7 +1734,7 @@ function genericPrintNoParens(path, options, print) {
                 parts.push("?");
             }
             parts.push(path.call(print, "typeParameters"), "(", printFunctionParams(path, options, print), ")", path.call(print, "typeAnnotation"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TSTypePredicate":
             if (n.asserts) {
                 parts.push("asserts ");
@@ -1743,9 +1743,9 @@ function genericPrintNoParens(path, options, print) {
             if (n.typeAnnotation) {
                 parts.push(" is ", path.call(print, "typeAnnotation", "typeAnnotation"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TSCallSignatureDeclaration":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "typeParameters"),
                 "(",
                 printFunctionParams(path, options, print),
@@ -1760,9 +1760,9 @@ function genericPrintNoParens(path, options, print) {
                 parts.push("new ");
             }
             parts.push("(", printFunctionParams(path, options, print), ")", path.call(print, "typeAnnotation"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TSTypeAliasDeclaration":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 n.declare ? "declare " : "",
                 "type ",
                 path.call(print, "id"),
@@ -1782,46 +1782,46 @@ function genericPrintNoParens(path, options, print) {
             if (n["default"]) {
                 parts.push(" = ", path.call(print, "default"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "TSTypeAssertion": {
             parts.push("<", path.call(print, "typeAnnotation"), "> ", path.call(print, "expression"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "TSTypeParameterDeclaration":
         case "TSTypeParameterInstantiation":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 "<",
-                (0, lines_1.fromString)(", ").join(path.map(print, "params")),
+                (0, lines_js_1.fromString)(", ").join(path.map(print, "params")),
                 ">",
             ]);
         case "TSEnumDeclaration": {
             parts.push(n.declare ? "declare " : "", n.const ? "const " : "", "enum ", path.call(print, "id"));
-            var memberLines = (0, lines_1.fromString)(",\n").join(path.map(print, "members"));
+            var memberLines = (0, lines_js_1.fromString)(",\n").join(path.map(print, "members"));
             if (memberLines.isEmpty()) {
                 parts.push(" {}");
             }
             else {
                 parts.push(" {\n", memberLines.indent(options.tabWidth), "\n}");
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "TSExpressionWithTypeArguments":
-            return (0, lines_1.concat)([
+            return (0, lines_js_1.concat)([
                 path.call(print, "expression"),
                 path.call(print, "typeParameters"),
             ]);
         case "TSInterfaceBody": {
-            var lines = (0, lines_1.fromString)("\n").join(path.map(print, "body").map(function (element) {
+            var lines = (0, lines_js_1.fromString)("\n").join(path.map(print, "body").map(function (element) {
                 if (lastNonSpaceCharacter(element) !== ";") {
                     return element.concat(";");
                 }
                 return element;
             }));
             if (lines.isEmpty()) {
-                return (0, lines_1.fromString)("{}", options);
+                return (0, lines_js_1.fromString)("{}", options);
             }
-            return (0, lines_1.concat)(["{\n", lines.indent(options.tabWidth), "\n}"]);
+            return (0, lines_js_1.concat)(["{\n", lines.indent(options.tabWidth), "\n}"]);
         }
         case "TSImportType":
             parts.push("import(", path.call(print, "argument"), ")");
@@ -1831,15 +1831,15 @@ function genericPrintNoParens(path, options, print) {
             if (n.typeParameters) {
                 parts.push(path.call(print, "typeParameters"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         case "TSImportEqualsDeclaration":
             if (n.isExport) {
                 parts.push("export ");
             }
             parts.push("import ", path.call(print, "id"), " = ", path.call(print, "moduleReference"));
-            return maybeAddSemicolon((0, lines_1.concat)(parts));
+            return maybeAddSemicolon((0, lines_js_1.concat)(parts));
         case "TSExternalModuleReference":
-            return (0, lines_1.concat)(["require(", path.call(print, "expression"), ")"]);
+            return (0, lines_js_1.concat)(["require(", path.call(print, "expression"), ")"]);
         case "TSModuleDeclaration": {
             var parent = path.getParentNode();
             if (parent.type === "TSModuleDeclaration") {
@@ -1878,7 +1878,7 @@ function genericPrintNoParens(path, options, print) {
                 parts.push(" ");
                 parts.push(path.call(print, "body"));
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "TSModuleBlock": {
             var naked = path.call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, "body");
@@ -1888,18 +1888,18 @@ function genericPrintNoParens(path, options, print) {
             else {
                 parts.push("{\n", naked.indent(options.tabWidth), "\n}");
             }
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         case "TSInstantiationExpression": {
             parts.push(path.call(print, "expression"), path.call(print, "typeParameters"));
-            return (0, lines_1.concat)(parts);
+            return (0, lines_js_1.concat)(parts);
         }
         // https://github.com/babel/babel/pull/10148
         case "V8IntrinsicIdentifier":
-            return (0, lines_1.concat)(["%", path.call(print, "name")]);
+            return (0, lines_js_1.concat)(["%", path.call(print, "name")]);
         // https://github.com/babel/babel/pull/13191
         case "TopicReference":
-            return (0, lines_1.fromString)("#");
+            return (0, lines_js_1.fromString)("#");
         // Unhandled types below. If encountered, nodes of these types should
         // be either left alone or desugared into AST types that are fully
         // supported by the pretty-printer.
@@ -1957,7 +1957,7 @@ function printDecorators(path, printPath) {
             parts.push(printPath(decoratorPath), "\n");
         }, "declaration", "decorators");
     }
-    return (0, lines_1.concat)(parts);
+    return (0, lines_js_1.concat)(parts);
 }
 function printStatementSequence(path, options, print) {
     var filtered = [];
@@ -2053,20 +2053,20 @@ function printStatementSequence(path, options, print) {
             parts.push(trailingSpace);
         }
     });
-    return (0, lines_1.concat)(parts);
+    return (0, lines_js_1.concat)(parts);
 }
 function maxSpace(s1, s2) {
     if (!s1 && !s2) {
-        return (0, lines_1.fromString)("");
+        return (0, lines_js_1.fromString)("");
     }
     if (!s1) {
-        return (0, lines_1.fromString)(s2);
+        return (0, lines_js_1.fromString)(s2);
     }
     if (!s2) {
-        return (0, lines_1.fromString)(s1);
+        return (0, lines_js_1.fromString)(s1);
     }
-    var spaceLines1 = (0, lines_1.fromString)(s1);
-    var spaceLines2 = (0, lines_1.fromString)(s2);
+    var spaceLines1 = (0, lines_js_1.fromString)(s1);
+    var spaceLines2 = (0, lines_js_1.fromString)(s2);
     if (spaceLines2.length > spaceLines1.length) {
         return spaceLines2;
     }
@@ -2115,7 +2115,7 @@ function printMethod(path, options, print) {
     }
     var key = path.call(print, "key");
     if (node.computed) {
-        key = (0, lines_1.concat)(["[", key, "]"]);
+        key = (0, lines_js_1.concat)(["[", key, "]"]);
     }
     parts.push(key);
     if (node.optional) {
@@ -2139,21 +2139,21 @@ function printMethod(path, options, print) {
             parts.push(";");
         }
     }
-    return (0, lines_1.concat)(parts);
+    return (0, lines_js_1.concat)(parts);
 }
 function printArgumentsList(path, options, print) {
     var printed = path.map(print, "arguments");
     var trailingComma = util.isTrailingCommaEnabled(options, "parameters");
-    var joined = (0, lines_1.fromString)(", ").join(printed);
+    var joined = (0, lines_js_1.fromString)(", ").join(printed);
     if (joined.getLineLength(1) > options.wrapColumn) {
-        joined = (0, lines_1.fromString)(",\n").join(printed);
-        return (0, lines_1.concat)([
+        joined = (0, lines_js_1.fromString)(",\n").join(printed);
+        return (0, lines_js_1.concat)([
             "(\n",
             joined.indent(options.tabWidth),
             trailingComma ? ",\n)" : "\n)",
         ]);
     }
-    return (0, lines_1.concat)(["(", joined, ")"]);
+    return (0, lines_js_1.concat)(["(", joined, ")"]);
 }
 function printFunctionParams(path, options, print) {
     var fun = path.getValue();
@@ -2172,25 +2172,25 @@ function printFunctionParams(path, options, print) {
             var i = defExprPath.getName();
             var p = printed[i];
             if (p && defExprPath.getValue()) {
-                printed[i] = (0, lines_1.concat)([p, " = ", print(defExprPath)]);
+                printed[i] = (0, lines_js_1.concat)([p, " = ", print(defExprPath)]);
             }
         }, "defaults");
     }
     if (fun.rest) {
-        printed.push((0, lines_1.concat)(["...", path.call(print, "rest")]));
+        printed.push((0, lines_js_1.concat)(["...", path.call(print, "rest")]));
     }
-    var joined = (0, lines_1.fromString)(", ").join(printed);
+    var joined = (0, lines_js_1.fromString)(", ").join(printed);
     if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {
-        joined = (0, lines_1.fromString)(",\n").join(printed);
+        joined = (0, lines_js_1.fromString)(",\n").join(printed);
         if (util.isTrailingCommaEnabled(options, "parameters") &&
             !fun.rest &&
             params[params.length - 1].type !== "RestElement") {
-            joined = (0, lines_1.concat)([joined, ",\n"]);
+            joined = (0, lines_js_1.concat)([joined, ",\n"]);
         }
         else {
-            joined = (0, lines_1.concat)([joined, "\n"]);
+            joined = (0, lines_js_1.concat)([joined, "\n"]);
         }
-        return (0, lines_1.concat)(["\n", joined.indent(options.tabWidth)]);
+        return (0, lines_js_1.concat)(["\n", joined.indent(options.tabWidth)]);
     }
     return joined;
 }
@@ -2199,16 +2199,16 @@ function maybePrintImportAssertions(path, options, print) {
     if (n.assertions && n.assertions.length > 0) {
         var parts = [" assert {"];
         var printed = path.map(print, "assertions");
-        var flat = (0, lines_1.fromString)(", ").join(printed);
+        var flat = (0, lines_js_1.fromString)(", ").join(printed);
         if (flat.length > 1 || flat.getLineLength(1) > options.wrapColumn) {
-            parts.push("\n", (0, lines_1.fromString)(",\n").join(printed).indent(options.tabWidth), "\n}");
+            parts.push("\n", (0, lines_js_1.fromString)(",\n").join(printed).indent(options.tabWidth), "\n}");
         }
         else {
             parts.push(" ", flat, " }");
         }
-        return (0, lines_1.concat)(parts);
+        return (0, lines_js_1.concat)(parts);
     }
-    return (0, lines_1.fromString)("");
+    return (0, lines_js_1.fromString)("");
 }
 function printExportDeclaration(path, options, print) {
     var decl = path.getValue();
@@ -2253,35 +2253,35 @@ function printExportDeclaration(path, options, print) {
                 parts.push(lines);
             });
             if (bracedSpecifiers_2.length > 0) {
-                var lines_2 = (0, lines_1.fromString)(", ").join(bracedSpecifiers_2);
-                if (lines_2.getLineLength(1) > options.wrapColumn) {
-                    lines_2 = (0, lines_1.concat)([
-                        (0, lines_1.fromString)(",\n").join(bracedSpecifiers_2).indent(options.tabWidth),
+                var lines_1 = (0, lines_js_1.fromString)(", ").join(bracedSpecifiers_2);
+                if (lines_1.getLineLength(1) > options.wrapColumn) {
+                    lines_1 = (0, lines_js_1.concat)([
+                        (0, lines_js_1.fromString)(",\n").join(bracedSpecifiers_2).indent(options.tabWidth),
                         ",",
                     ]);
                 }
                 if (unbracedSpecifiers_2.length > 0) {
                     parts.push(", ");
                 }
-                if (lines_2.length > 1) {
-                    parts.push("{\n", lines_2, "\n}");
+                if (lines_1.length > 1) {
+                    parts.push("{\n", lines_1, "\n}");
                 }
                 else if (options.objectCurlySpacing) {
-                    parts.push("{ ", lines_2, " }");
+                    parts.push("{ ", lines_1, " }");
                 }
                 else {
-                    parts.push("{", lines_2, "}");
+                    parts.push("{", lines_1, "}");
                 }
             }
         }
         else {
-            parts.push(shouldPrintSpaces ? "{ " : "{", (0, lines_1.fromString)(", ").join(path.map(print, "specifiers")), shouldPrintSpaces ? " }" : "}");
+            parts.push(shouldPrintSpaces ? "{ " : "{", (0, lines_js_1.fromString)(", ").join(path.map(print, "specifiers")), shouldPrintSpaces ? " }" : "}");
         }
         if (decl.source) {
             parts.push(" from ", path.call(print, "source"), maybePrintImportAssertions(path, options, print));
         }
     }
-    var lines = (0, lines_1.concat)(parts);
+    var lines = (0, lines_js_1.concat)(parts);
     if (lastNonSpaceCharacter(lines) !== ";" &&
         !(decl.declaration &&
             (decl.declaration.type === "FunctionDeclaration" ||
@@ -2289,7 +2289,7 @@ function printExportDeclaration(path, options, print) {
                 decl.declaration.type === "TSModuleDeclaration" ||
                 decl.declaration.type === "TSInterfaceDeclaration" ||
                 decl.declaration.type === "TSEnumDeclaration"))) {
-        lines = (0, lines_1.concat)([lines, ";"]);
+        lines = (0, lines_js_1.concat)([lines, ";"]);
     }
     return lines;
 }
@@ -2304,27 +2304,27 @@ function printFlowDeclaration(path, parts) {
         // it needs to be printed with this non-exported declaration node.
         parts.unshift("declare ");
     }
-    return (0, lines_1.concat)(parts);
+    return (0, lines_js_1.concat)(parts);
 }
 function printVariance(path, print) {
     return path.call(function (variancePath) {
         var value = variancePath.getValue();
         if (value) {
             if (value === "plus") {
-                return (0, lines_1.fromString)("+");
+                return (0, lines_js_1.fromString)("+");
             }
             if (value === "minus") {
-                return (0, lines_1.fromString)("-");
+                return (0, lines_js_1.fromString)("-");
             }
             return print(variancePath);
         }
-        return (0, lines_1.fromString)("");
+        return (0, lines_js_1.fromString)("");
     }, "variance");
 }
 function adjustClause(clause, options) {
     if (clause.length > 1)
-        return (0, lines_1.concat)([" ", clause]);
-    return (0, lines_1.concat)(["\n", maybeAddSemicolon(clause).indent(options.tabWidth)]);
+        return (0, lines_js_1.concat)([" ", clause]);
+    return (0, lines_js_1.concat)(["\n", maybeAddSemicolon(clause).indent(options.tabWidth)]);
 }
 function lastNonSpaceCharacter(lines) {
     var pos = lines.lastPos();
@@ -2376,6 +2376,6 @@ function nodeStr(str, options) {
 function maybeAddSemicolon(lines) {
     var eoc = lastNonSpaceCharacter(lines);
     if (!eoc || "\n};".indexOf(eoc) < 0)
-        return (0, lines_1.concat)([lines, ";"]);
+        return (0, lines_js_1.concat)([lines, ";"]);
     return lines;
 }
diff --git a/node_modules/recast/lib/printer.ts b/node_modules/recast/lib/printer.ts
new file mode 100644
index 0000000..5c12225
--- /dev/null
+++ b/node_modules/recast/lib/printer.ts
@@ -0,0 +1,3193 @@
+import assert from "assert";
+import * as types from "ast-types";
+import { printComments } from "./comments.js";
+import FastPath from "./fast-path.js";
+import { concat, fromString, Lines } from "./lines.js";
+import { normalize as normalizeOptions } from "./options.js";
+import { getReprinter } from "./patcher.js";
+import * as util from "./util.js";
+const namedTypes = types.namedTypes;
+const isString = types.builtInTypes.string;
+const isObject = types.builtInTypes.object;
+
+export interface PrintResultType {
+  code: string;
+  map?: any;
+  toString(): string;
+}
+
+interface PrintResultConstructor {
+  new (code: any, sourceMap?: any): PrintResultType;
+}
+
+const PrintResult = function PrintResult(
+  this: PrintResultType,
+  code: any,
+  sourceMap?: any,
+) {
+  assert.ok(this instanceof PrintResult);
+
+  isString.assert(code);
+  this.code = code;
+
+  if (sourceMap) {
+    isObject.assert(sourceMap);
+    this.map = sourceMap;
+  }
+} as any as PrintResultConstructor;
+
+const PRp: PrintResultType = PrintResult.prototype;
+let warnedAboutToString = false;
+
+PRp.toString = function () {
+  if (!warnedAboutToString) {
+    console.warn(
+      "Deprecation warning: recast.print now returns an object with " +
+        "a .code property. You appear to be treating the object as a " +
+        "string, which might still work but is strongly discouraged.",
+    );
+
+    warnedAboutToString = true;
+  }
+
+  return this.code;
+};
+
+const emptyPrintResult = new PrintResult("");
+
+interface PrinterType {
+  print(ast: any): PrintResultType;
+  printGenerically(ast: any): PrintResultType;
+}
+
+interface PrinterConstructor {
+  new (config?: any): PrinterType;
+}
+
+const Printer = function Printer(this: PrinterType, config?: any) {
+  assert.ok(this instanceof Printer);
+
+  const explicitTabWidth = config && config.tabWidth;
+  config = normalizeOptions(config);
+
+  // It's common for client code to pass the same options into both
+  // recast.parse and recast.print, but the Printer doesn't need (and
+  // can be confused by) config.sourceFileName, so we null it out.
+  config.sourceFileName = null;
+
+  // Non-destructively modifies options with overrides, and returns a
+  // new print function that uses the modified options.
+  function makePrintFunctionWith(options: any, overrides: any) {
+    options = Object.assign({}, options, overrides);
+    return (path: any) => print(path, options);
+  }
+
+  function print(path: any, options: any) {
+    assert.ok(path instanceof FastPath);
+    options = options || {};
+
+    if (options.includeComments) {
+      return printComments(
+        path,
+        makePrintFunctionWith(options, {
+          includeComments: false,
+        }),
+      );
+    }
+
+    const oldTabWidth = config.tabWidth;
+
+    if (!explicitTabWidth) {
+      const loc = path.getNode().loc;
+      if (loc && loc.lines && loc.lines.guessTabWidth) {
+        config.tabWidth = loc.lines.guessTabWidth();
+      }
+    }
+
+    const reprinter = getReprinter(path);
+    const lines = reprinter
+      ? // Since the print function that we pass to the reprinter will
+        // be used to print "new" nodes, it's tempting to think we
+        // should pass printRootGenerically instead of print, to avoid
+        // calling maybeReprint again, but that would be a mistake
+        // because the new nodes might not be entirely new, but merely
+        // moved from elsewhere in the AST. The print function is the
+        // right choice because it gives us the opportunity to reprint
+        // such nodes using their original source.
+        reprinter(print)
+      : genericPrint(
+          path,
+          config,
+          options,
+          makePrintFunctionWith(options, {
+            includeComments: true,
+            avoidRootParens: false,
+          }),
+        );
+
+    config.tabWidth = oldTabWidth;
+
+    return lines;
+  }
+
+  this.print = function (ast) {
+    if (!ast) {
+      return emptyPrintResult;
+    }
+
+    const lines = print(FastPath.from(ast), {
+      includeComments: true,
+      avoidRootParens: false,
+    });
+
+    return new PrintResult(
+      lines.toString(config),
+      util.composeSourceMaps(
+        config.inputSourceMap,
+        lines.getSourceMap(config.sourceMapName, config.sourceRoot),
+      ),
+    );
+  };
+
+  this.printGenerically = function (ast) {
+    if (!ast) {
+      return emptyPrintResult;
+    }
+
+    // Print the entire AST generically.
+    function printGenerically(path: any) {
+      return printComments(path, (path: any) =>
+        genericPrint(
+          path,
+          config,
+          {
+            includeComments: true,
+            avoidRootParens: false,
+          },
+          printGenerically,
+        ),
+      );
+    }
+
+    const path = FastPath.from(ast);
+    const oldReuseWhitespace = config.reuseWhitespace;
+
+    // Do not reuse whitespace (or anything else, for that matter)
+    // when printing generically.
+    config.reuseWhitespace = false;
+
+    // TODO Allow printing of comments?
+    const pr = new PrintResult(printGenerically(path).toString(config));
+    config.reuseWhitespace = oldReuseWhitespace;
+    return pr;
+  };
+} as any as PrinterConstructor;
+
+export { Printer };
+
+function genericPrint(path: any, config: any, options: any, printPath: any) {
+  assert.ok(path instanceof FastPath);
+
+  const node = path.getValue();
+  const parts = [];
+  const linesWithoutParens = genericPrintNoParens(path, config, printPath);
+
+  if (!node || linesWithoutParens.isEmpty()) {
+    return linesWithoutParens;
+  }
+
+  let shouldAddParens = false;
+  const decoratorsLines = printDecorators(path, printPath);
+
+  if (decoratorsLines.isEmpty()) {
+    // Nodes with decorators can't have parentheses, so we can avoid
+    // computing path.needsParens() except in this case.
+    if (!options.avoidRootParens) {
+      shouldAddParens = path.needsParens();
+    }
+  } else {
+    parts.push(decoratorsLines);
+  }
+
+  if (shouldAddParens) {
+    parts.unshift("(");
+  }
+
+  parts.push(linesWithoutParens);
+
+  if (shouldAddParens) {
+    parts.push(")");
+  }
+
+  return concat(parts);
+}
+
+// Note that the `options` parameter of this function is what other
+// functions in this file call the `config` object (that is, the
+// configuration object originally passed into the Printer constructor).
+// Its properties are documented in lib/options.js.
+function genericPrintNoParens(path: any, options: any, print: any) {
+  const n = path.getValue();
+
+  if (!n) {
+    return fromString("");
+  }
+
+  if (typeof n === "string") {
+    return fromString(n, options);
+  }
+
+  namedTypes.Printable.assert(n);
+
+  const parts: (string | Lines)[] = [];
+
+  switch (n.type) {
+    case "File":
+      return path.call(print, "program");
+
+    case "Program":
+      // Babel 6
+      if (n.directives) {
+        path.each(function (childPath: any) {
+          parts.push(print(childPath), ";\n");
+        }, "directives");
+      }
+
+      if (n.interpreter) {
+        parts.push(path.call(print, "interpreter"));
+      }
+
+      parts.push(
+        path.call(
+          (bodyPath: any) => printStatementSequence(bodyPath, options, print),
+          "body",
+        ),
+      );
+
+      return concat(parts);
+
+    case "Noop": // Babel extension.
+    case "EmptyStatement":
+      return fromString("");
+
+    case "ExpressionStatement":
+      return concat([path.call(print, "expression"), ";"]);
+
+    case "ParenthesizedExpression": // Babel extension.
+      return concat(["(", path.call(print, "expression"), ")"]);
+
+    case "BinaryExpression":
+    case "LogicalExpression":
+    case "AssignmentExpression":
+      return fromString(" ").join([
+        path.call(print, "left"),
+        n.operator,
+        path.call(print, "right"),
+      ]);
+
+    case "AssignmentPattern":
+      return concat([
+        path.call(print, "left"),
+        " = ",
+        path.call(print, "right"),
+      ]);
+
+    case "MemberExpression":
+    case "OptionalMemberExpression": {
+      parts.push(path.call(print, "object"));
+
+      const property = path.call(print, "property");
+
+      // Like n.optional, except with defaults applied, so optional
+      // defaults to true for OptionalMemberExpression nodes.
+      const optional = types.getFieldValue(n, "optional");
+
+      if (n.computed) {
+        parts.push(optional ? "?.[" : "[", property, "]");
+      } else {
+        parts.push(optional ? "?." : ".", property);
+      }
+
+      return concat(parts);
+    }
+
+    case "ChainExpression":
+      return path.call(print, "expression");
+
+    case "MetaProperty":
+      return concat([
+        path.call(print, "meta"),
+        ".",
+        path.call(print, "property"),
+      ]);
+
+    case "BindExpression":
+      if (n.object) {
+        parts.push(path.call(print, "object"));
+      }
+
+      parts.push("::", path.call(print, "callee"));
+
+      return concat(parts);
+
+    case "Path":
+      return fromString(".").join(n.body);
+
+    case "Identifier":
+      return concat([
+        fromString(n.name, options),
+        n.optional ? "?" : "",
+        path.call(print, "typeAnnotation"),
+      ]);
+
+    case "SpreadElement":
+    case "SpreadElementPattern":
+    case "RestProperty": // Babel 6 for ObjectPattern
+    case "SpreadProperty":
+    case "SpreadPropertyPattern":
+    case "ObjectTypeSpreadProperty":
+    case "RestElement":
+      return concat([
+        "...",
+        path.call(print, "argument"),
+        path.call(print, "typeAnnotation"),
+      ]);
+
+    case "FunctionDeclaration":
+    case "FunctionExpression":
+    case "TSDeclareFunction":
+      if (n.declare) {
+        parts.push("declare ");
+      }
+
+      if (n.async) {
+        parts.push("async ");
+      }
+
+      parts.push("function");
+
+      if (n.generator) parts.push("*");
+
+      if (n.id) {
+        parts.push(
+          " ",
+          path.call(print, "id"),
+          path.call(print, "typeParameters"),
+        );
+      } else {
+        if (n.typeParameters) {
+          parts.push(path.call(print, "typeParameters"));
+        }
+      }
+
+      parts.push(
+        "(",
+        printFunctionParams(path, options, print),
+        ")",
+        path.call(print, "returnType"),
+      );
+
+      if (n.body) {
+        parts.push(" ", path.call(print, "body"));
+      }
+
+      return concat(parts);
+
+    case "ArrowFunctionExpression":
+      if (n.async) {
+        parts.push("async ");
+      }
+
+      if (n.typeParameters) {
+        parts.push(path.call(print, "typeParameters"));
+      }
+
+      if (
+        !options.arrowParensAlways &&
+        n.params.length === 1 &&
+        !n.rest &&
+        n.params[0].type === "Identifier" &&
+        !n.params[0].typeAnnotation &&
+        !n.returnType
+      ) {
+        parts.push(path.call(print, "params", 0));
+      } else {
+        parts.push(
+          "(",
+          printFunctionParams(path, options, print),
+          ")",
+          path.call(print, "returnType"),
+        );
+      }
+
+      parts.push(" => ", path.call(print, "body"));
+
+      return concat(parts);
+
+    case "MethodDefinition":
+      return printMethod(path, options, print);
+
+    case "YieldExpression":
+      parts.push("yield");
+
+      if (n.delegate) parts.push("*");
+
+      if (n.argument) parts.push(" ", path.call(print, "argument"));
+
+      return concat(parts);
+
+    case "AwaitExpression":
+      parts.push("await");
+
+      if (n.all) parts.push("*");
+
+      if (n.argument) parts.push(" ", path.call(print, "argument"));
+
+      return concat(parts);
+
+    case "ModuleExpression":
+      return concat([
+        "module {\n",
+        path.call(print, "body").indent(options.tabWidth),
+        "\n}",
+      ]);
+
+    case "ModuleDeclaration":
+      parts.push("module", path.call(print, "id"));
+
+      if (n.source) {
+        assert.ok(!n.body);
+        parts.push("from", path.call(print, "source"));
+      } else {
+        parts.push(path.call(print, "body"));
+      }
+
+      return fromString(" ").join(parts);
+
+    case "ImportSpecifier":
+      if (n.importKind && n.importKind !== "value") {
+        parts.push(n.importKind + " ");
+      }
+      if (n.imported) {
+        parts.push(path.call(print, "imported"));
+        if (n.local && n.local.name !== n.imported.name) {
+          parts.push(" as ", path.call(print, "local"));
+        }
+      } else if (n.id) {
+        parts.push(path.call(print, "id"));
+        if (n.name) {
+          parts.push(" as ", path.call(print, "name"));
+        }
+      }
+
+      return concat(parts);
+
+    case "ExportSpecifier":
+      if (n.local) {
+        parts.push(path.call(print, "local"));
+        if (n.exported && n.exported.name !== n.local.name) {
+          parts.push(" as ", path.call(print, "exported"));
+        }
+      } else if (n.id) {
+        parts.push(path.call(print, "id"));
+        if (n.name) {
+          parts.push(" as ", path.call(print, "name"));
+        }
+      }
+
+      return concat(parts);
+
+    case "ExportBatchSpecifier":
+      return fromString("*");
+
+    case "ImportNamespaceSpecifier":
+      parts.push("* as ");
+      if (n.local) {
+        parts.push(path.call(print, "local"));
+      } else if (n.id) {
+        parts.push(path.call(print, "id"));
+      }
+      return concat(parts);
+
+    case "ImportDefaultSpecifier":
+      if (n.local) {
+        return path.call(print, "local");
+      }
+      return path.call(print, "id");
+
+    case "TSExportAssignment":
+      return concat(["export = ", path.call(print, "expression")]);
+
+    case "ExportDeclaration":
+    case "ExportDefaultDeclaration":
+    case "ExportNamedDeclaration":
+      return printExportDeclaration(path, options, print);
+
+    case "ExportAllDeclaration":
+      parts.push("export *");
+
+      if (n.exported) {
+        parts.push(" as ", path.call(print, "exported"));
+      }
+
+      parts.push(" from ", path.call(print, "source"), ";");
+
+      return concat(parts);
+
+    case "TSNamespaceExportDeclaration":
+      parts.push("export as namespace ", path.call(print, "id"));
+      return maybeAddSemicolon(concat(parts));
+
+    case "ExportNamespaceSpecifier":
+      return concat(["* as ", path.call(print, "exported")]);
+
+    case "ExportDefaultSpecifier":
+      return path.call(print, "exported");
+
+    case "Import":
+      return fromString("import", options);
+
+    // Recast and ast-types currently support dynamic import(...) using
+    // either this dedicated ImportExpression type or a CallExpression
+    // whose callee has type Import.
+    // https://github.com/benjamn/ast-types/pull/365#issuecomment-605214486
+    case "ImportExpression":
+      return concat(["import(", path.call(print, "source"), ")"]);
+
+    case "ImportDeclaration": {
+      parts.push("import ");
+
+      if (n.importKind && n.importKind !== "value") {
+        parts.push(n.importKind + " ");
+      }
+
+      if (n.specifiers && n.specifiers.length > 0) {
+        const unbracedSpecifiers: any[] = [];
+        const bracedSpecifiers: any[] = [];
+
+        path.each(function (specifierPath: any) {
+          const spec = specifierPath.getValue();
+          if (spec.type === "ImportSpecifier") {
+            bracedSpecifiers.push(print(specifierPath));
+          } else if (
+            spec.type === "ImportDefaultSpecifier" ||
+            spec.type === "ImportNamespaceSpecifier"
+          ) {
+            unbracedSpecifiers.push(print(specifierPath));
+          }
+        }, "specifiers");
+
+        unbracedSpecifiers.forEach((lines, i) => {
+          if (i > 0) {
+            parts.push(", ");
+          }
+          parts.push(lines);
+        });
+
+        if (bracedSpecifiers.length > 0) {
+          let lines = fromString(", ").join(bracedSpecifiers);
+          if (lines.getLineLength(1) > options.wrapColumn) {
+            lines = concat([
+              fromString(",\n").join(bracedSpecifiers).indent(options.tabWidth),
+              ",",
+            ]);
+          }
+
+          if (unbracedSpecifiers.length > 0) {
+            parts.push(", ");
+          }
+
+          if (lines.length > 1) {
+            parts.push("{\n", lines, "\n}");
+          } else if (options.objectCurlySpacing) {
+            parts.push("{ ", lines, " }");
+          } else {
+            parts.push("{", lines, "}");
+          }
+        }
+
+        parts.push(" from ");
+      }
+
+      parts.push(
+        path.call(print, "source"),
+        maybePrintImportAssertions(path, options, print),
+        ";",
+      );
+
+      return concat(parts);
+    }
+
+    case "ImportAttribute":
+      return concat([path.call(print, "key"), ": ", path.call(print, "value")]);
+
+    case "StaticBlock":
+      parts.push("static ");
+    // Intentionally fall through to BlockStatement below.
+
+    case "BlockStatement": {
+      const naked = path.call(
+        (bodyPath: any) => printStatementSequence(bodyPath, options, print),
+        "body",
+      );
+
+      if (naked.isEmpty()) {
+        if (!n.directives || n.directives.length === 0) {
+          parts.push("{}");
+          return concat(parts);
+        }
+      }
+
+      parts.push("{\n");
+      // Babel 6
+      if (n.directives) {
+        path.each(function (childPath: any) {
+          parts.push(
+            maybeAddSemicolon(print(childPath).indent(options.tabWidth)),
+            n.directives.length > 1 || !naked.isEmpty() ? "\n" : "",
+          );
+        }, "directives");
+      }
+      parts.push(naked.indent(options.tabWidth));
+      parts.push("\n}");
+
+      return concat(parts);
+    }
+
+    case "ReturnStatement": {
+      parts.push("return");
+
+      if (n.argument) {
+        const argLines = path.call(print, "argument");
+        if (
+          argLines.startsWithComment() ||
+          (argLines.length > 1 &&
+            namedTypes.JSXElement &&
+            namedTypes.JSXElement.check(n.argument))
+        ) {
+          parts.push(" (\n", argLines.indent(options.tabWidth), "\n)");
+        } else {
+          parts.push(" ", argLines);
+        }
+      }
+
+      parts.push(";");
+
+      return concat(parts);
+    }
+
+    case "CallExpression":
+    case "OptionalCallExpression":
+      parts.push(path.call(print, "callee"));
+
+      if (n.typeParameters) {
+        parts.push(path.call(print, "typeParameters"));
+      }
+
+      if (n.typeArguments) {
+        parts.push(path.call(print, "typeArguments"));
+      }
+
+      // Like n.optional, but defaults to true for OptionalCallExpression
+      // nodes that are missing an n.optional property (unusual),
+      // according to the OptionalCallExpression definition in ast-types.
+      if (types.getFieldValue(n, "optional")) {
+        parts.push("?.");
+      }
+
+      parts.push(printArgumentsList(path, options, print));
+
+      return concat(parts);
+
+    case "RecordExpression":
+      parts.push("#");
+    // Intentionally fall through to printing the object literal...
+    case "ObjectExpression":
+    case "ObjectPattern":
+    case "ObjectTypeAnnotation": {
+      const isTypeAnnotation = n.type === "ObjectTypeAnnotation";
+      const separator = options.flowObjectCommas
+        ? ","
+        : isTypeAnnotation
+        ? ";"
+        : ",";
+      const fields = [];
+      let allowBreak = false;
+
+      if (isTypeAnnotation) {
+        fields.push("indexers", "callProperties");
+        if (n.internalSlots != null) {
+          fields.push("internalSlots");
+        }
+      }
+
+      fields.push("properties");
+
+      let len = 0;
+      fields.forEach(function (field) {
+        len += n[field].length;
+      });
+
+      const oneLine = (isTypeAnnotation && len === 1) || len === 0;
+      const leftBrace = n.exact ? "{|" : "{";
+      const rightBrace = n.exact ? "|}" : "}";
+      parts.push(oneLine ? leftBrace : leftBrace + "\n");
+      const leftBraceIndex = parts.length - 1;
+
+      let i = 0;
+      fields.forEach(function (field) {
+        path.each(function (childPath: any) {
+          let lines = print(childPath);
+
+          if (!oneLine) {
+            lines = lines.indent(options.tabWidth);
+          }
+
+          const multiLine = !isTypeAnnotation && lines.length > 1;
+          if (multiLine && allowBreak) {
+            // Similar to the logic for BlockStatement.
+            parts.push("\n");
+          }
+
+          parts.push(lines);
+
+          if (i < len - 1) {
+            // Add an extra line break if the previous object property
+            // had a multi-line value.
+            parts.push(separator + (multiLine ? "\n\n" : "\n"));
+            allowBreak = !multiLine;
+          } else if (len !== 1 && isTypeAnnotation) {
+            parts.push(separator);
+          } else if (
+            !oneLine &&
+            util.isTrailingCommaEnabled(options, "objects") &&
+            childPath.getValue().type !== "RestElement"
+          ) {
+            parts.push(separator);
+          }
+          i++;
+        }, field);
+      });
+
+      if (n.inexact) {
+        const line = fromString("...", options);
+        if (oneLine) {
+          if (len > 0) {
+            parts.push(separator, " ");
+          }
+          parts.push(line);
+        } else {
+          // No trailing separator after ... to maintain parity with prettier.
+          parts.push("\n", line.indent(options.tabWidth));
+        }
+      }
+
+      parts.push(oneLine ? rightBrace : "\n" + rightBrace);
+
+      if (i !== 0 && oneLine && options.objectCurlySpacing) {
+        parts[leftBraceIndex] = leftBrace + " ";
+        parts[parts.length - 1] = " " + rightBrace;
+      }
+
+      if (n.typeAnnotation) {
+        parts.push(path.call(print, "typeAnnotation"));
+      }
+
+      return concat(parts);
+    }
+
+    case "PropertyPattern":
+      return concat([
+        path.call(print, "key"),
+        ": ",
+        path.call(print, "pattern"),
+      ]);
+
+    case "ObjectProperty": // Babel 6
+    case "Property": {
+      // Non-standard AST node type.
+      if (n.method || n.kind === "get" || n.kind === "set") {
+        return printMethod(path, options, print);
+      }
+
+      if (n.shorthand && n.value.type === "AssignmentPattern") {
+        return path.call(print, "value");
+      }
+
+      const key = path.call(print, "key");
+      if (n.computed) {
+        parts.push("[", key, "]");
+      } else {
+        parts.push(key);
+      }
+
+      if (!n.shorthand || n.key.name !== n.value.name) {
+        parts.push(": ", path.call(print, "value"));
+      }
+
+      return concat(parts);
+    }
+
+    case "ClassMethod": // Babel 6
+    case "ObjectMethod": // Babel 6
+    case "ClassPrivateMethod":
+    case "TSDeclareMethod":
+      return printMethod(path, options, print);
+
+    case "PrivateName":
+      return concat(["#", path.call(print, "id")]);
+
+    case "Decorator":
+      return concat(["@", path.call(print, "expression")]);
+
+    case "TupleExpression":
+      parts.push("#");
+    // Intentionally fall through to printing the tuple elements...
+    case "ArrayExpression":
+    case "ArrayPattern": {
+      const elems: any[] = n.elements;
+      const len = elems.length;
+      const printed = path.map(print, "elements");
+      const joined = fromString(", ").join(printed);
+      const oneLine = joined.getLineLength(1) <= options.wrapColumn;
+
+      if (oneLine) {
+        if (options.arrayBracketSpacing) {
+          parts.push("[ ");
+        } else {
+          parts.push("[");
+        }
+      } else {
+        parts.push("[\n");
+      }
+
+      path.each(function (elemPath: any) {
+        const i = elemPath.getName();
+        const elem = elemPath.getValue();
+        if (!elem) {
+          // If the array expression ends with a hole, that hole
+          // will be ignored by the interpreter, but if it ends with
+          // two (or more) holes, we need to write out two (or more)
+          // commas so that the resulting code is interpreted with
+          // both (all) of the holes.
+          parts.push(",");
+        } else {
+          let lines = printed[i];
+          if (oneLine) {
+            if (i > 0) parts.push(" ");
+          } else {
+            lines = lines.indent(options.tabWidth);
+          }
+          parts.push(lines);
+          if (
+            i < len - 1 ||
+            (!oneLine && util.isTrailingCommaEnabled(options, "arrays"))
+          )
+            parts.push(",");
+          if (!oneLine) parts.push("\n");
+        }
+      }, "elements");
+
+      if (oneLine && options.arrayBracketSpacing) {
+        parts.push(" ]");
+      } else {
+        parts.push("]");
+      }
+
+      if (n.typeAnnotation) {
+        parts.push(path.call(print, "typeAnnotation"));
+      }
+
+      return concat(parts);
+    }
+
+    case "SequenceExpression":
+      return fromString(", ").join(path.map(print, "expressions"));
+
+    case "ThisExpression":
+      return fromString("this");
+
+    case "Super":
+      return fromString("super");
+
+    case "NullLiteral": // Babel 6 Literal split
+      return fromString("null");
+
+    case "RegExpLiteral": // Babel 6 Literal split
+      return fromString(
+        getPossibleRaw(n) || `/${n.pattern}/${n.flags || ""}`,
+        options,
+      );
+
+    case "BigIntLiteral": // Babel 7 Literal split
+      return fromString(getPossibleRaw(n) || n.value + "n", options);
+
+    case "NumericLiteral": // Babel 6 Literal Split
+      return fromString(getPossibleRaw(n) || n.value, options);
+
+    case "DecimalLiteral":
+      return fromString(getPossibleRaw(n) || n.value + "m", options);
+
+    case "StringLiteral":
+        return fromString(nodeStr(n.value, options));
+
+    case "BooleanLiteral": // Babel 6 Literal split
+    case "Literal":
+      return fromString(
+        getPossibleRaw(n) ||
+          (typeof n.value === "string" ? nodeStr(n.value, options) : n.value),
+        options,
+      );
+
+    case "Directive": // Babel 6
+      return path.call(print, "value");
+
+    case "DirectiveLiteral": // Babel 6
+      return fromString(
+        getPossibleRaw(n) || nodeStr(n.value, options),
+        options,
+      );
+
+    case "InterpreterDirective":
+      return fromString(`#!${n.value}\n`, options);
+
+    case "ModuleSpecifier":
+      if (n.local) {
+        throw new Error("The ESTree ModuleSpecifier type should be abstract");
+      }
+
+      // The Esprima ModuleSpecifier type is just a string-valued
+      // Literal identifying the imported-from module.
+      return fromString(nodeStr(n.value, options), options);
+
+    case "UnaryExpression":
+      parts.push(n.operator);
+      if (/[a-z]$/.test(n.operator)) parts.push(" ");
+      parts.push(path.call(print, "argument"));
+      return concat(parts);
+
+    case "UpdateExpression":
+      parts.push(path.call(print, "argument"), n.operator);
+
+      if (n.prefix) parts.reverse();
+
+      return concat(parts);
+
+    case "ConditionalExpression":
+      return concat([
+        path.call(print, "test"),
+        " ? ",
+        path.call(print, "consequent"),
+        " : ",
+        path.call(print, "alternate"),
+      ]);
+
+    case "NewExpression": {
+      parts.push("new ", path.call(print, "callee"));
+      if (n.typeParameters) {
+        parts.push(path.call(print, "typeParameters"));
+      }
+      if (n.typeArguments) {
+        parts.push(path.call(print, "typeArguments"));
+      }
+      const args = n.arguments;
+      if (args) {
+        parts.push(printArgumentsList(path, options, print));
+      }
+
+      return concat(parts);
+    }
+
+    case "VariableDeclaration": {
+      if (n.declare) {
+        parts.push("declare ");
+      }
+
+      parts.push(n.kind, " ");
+
+      let maxLen = 0;
+      const printed = path.map(function (childPath: any) {
+        const lines = print(childPath);
+        maxLen = Math.max(lines.length, maxLen);
+        return lines;
+      }, "declarations");
+
+      if (maxLen === 1) {
+        parts.push(fromString(", ").join(printed));
+      } else if (printed.length > 1) {
+        parts.push(
+          fromString(",\n")
+            .join(printed)
+            .indentTail(n.kind.length + 1),
+        );
+      } else {
+        parts.push(printed[0]);
+      }
+
+      // We generally want to terminate all variable declarations with a
+      // semicolon, except when they are children of for loops.
+      const parentNode = path.getParentNode();
+      if (
+        !namedTypes.ForStatement.check(parentNode) &&
+        !namedTypes.ForInStatement.check(parentNode) &&
+        !(
+          namedTypes.ForOfStatement &&
+          namedTypes.ForOfStatement.check(parentNode)
+        ) &&
+        !(
+          namedTypes.ForAwaitStatement &&
+          namedTypes.ForAwaitStatement.check(parentNode)
+        )
+      ) {
+        parts.push(";");
+      }
+
+      return concat(parts);
+    }
+
+    case "VariableDeclarator":
+      return n.init
+        ? fromString(" = ").join([
+            path.call(print, "id"),
+            path.call(print, "init"),
+          ])
+        : path.call(print, "id");
+
+    case "WithStatement":
+      return concat([
+        "with (",
+        path.call(print, "object"),
+        ") ",
+        path.call(print, "body"),
+      ]);
+
+    case "IfStatement": {
+      const con = adjustClause(path.call(print, "consequent"), options);
+      parts.push("if (", path.call(print, "test"), ")", con);
+
+      if (n.alternate)
+        parts.push(
+          endsWithBrace(con) ? " else" : "\nelse",
+          adjustClause(path.call(print, "alternate"), options),
+        );
+
+      return concat(parts);
+    }
+
+    case "ForStatement": {
+      // TODO Get the for (;;) case right.
+      const init = path.call(print, "init");
+      const sep = init.length > 1 ? ";\n" : "; ";
+      const forParen = "for (";
+      const indented = fromString(sep)
+        .join([init, path.call(print, "test"), path.call(print, "update")])
+        .indentTail(forParen.length);
+      const head = concat([forParen, indented, ")"]);
+      let clause = adjustClause(path.call(print, "body"), options);
+
+      parts.push(head);
+
+      if (head.length > 1) {
+        parts.push("\n");
+        clause = clause.trimLeft();
+      }
+
+      parts.push(clause);
+
+      return concat(parts);
+    }
+
+    case "WhileStatement":
+      return concat([
+        "while (",
+        path.call(print, "test"),
+        ")",
+        adjustClause(path.call(print, "body"), options),
+      ]);
+
+    case "ForInStatement":
+      // Note: esprima can't actually parse "for each (".
+      return concat([
+        n.each ? "for each (" : "for (",
+        path.call(print, "left"),
+        " in ",
+        path.call(print, "right"),
+        ")",
+        adjustClause(path.call(print, "body"), options),
+      ]);
+
+    case "ForOfStatement":
+    case "ForAwaitStatement":
+      parts.push("for ");
+
+      if (n.await || n.type === "ForAwaitStatement") {
+        parts.push("await ");
+      }
+
+      parts.push(
+        "(",
+        path.call(print, "left"),
+        " of ",
+        path.call(print, "right"),
+        ")",
+        adjustClause(path.call(print, "body"), options),
+      );
+
+      return concat(parts);
+
+    case "DoWhileStatement": {
+      const doBody = concat([
+        "do",
+        adjustClause(path.call(print, "body"), options),
+      ]);
+
+      parts.push(doBody);
+
+      if (endsWithBrace(doBody)) parts.push(" while");
+      else parts.push("\nwhile");
+
+      parts.push(" (", path.call(print, "test"), ");");
+
+      return concat(parts);
+    }
+
+    case "DoExpression": {
+      const statements = path.call(
+        (bodyPath: any) => printStatementSequence(bodyPath, options, print),
+        "body",
+      );
+
+      return concat(["do {\n", statements.indent(options.tabWidth), "\n}"]);
+    }
+
+    case "BreakStatement":
+      parts.push("break");
+      if (n.label) parts.push(" ", path.call(print, "label"));
+      parts.push(";");
+      return concat(parts);
+
+    case "ContinueStatement":
+      parts.push("continue");
+      if (n.label) parts.push(" ", path.call(print, "label"));
+      parts.push(";");
+      return concat(parts);
+
+    case "LabeledStatement":
+      return concat([
+        path.call(print, "label"),
+        ":\n",
+        path.call(print, "body"),
+      ]);
+
+    case "TryStatement":
+      parts.push("try ", path.call(print, "block"));
+
+      if (n.handler) {
+        parts.push(" ", path.call(print, "handler"));
+      } else if (n.handlers) {
+        path.each(function (handlerPath: any) {
+          parts.push(" ", print(handlerPath));
+        }, "handlers");
+      }
+
+      if (n.finalizer) {
+        parts.push(" finally ", path.call(print, "finalizer"));
+      }
+
+      return concat(parts);
+
+    case "CatchClause":
+      parts.push("catch ");
+
+      if (n.param) {
+        parts.push("(", path.call(print, "param"));
+      }
+
+      if (n.guard) {
+        // Note: esprima does not recognize conditional catch clauses.
+        parts.push(" if ", path.call(print, "guard"));
+      }
+
+      if (n.param) {
+        parts.push(") ");
+      }
+
+      parts.push(path.call(print, "body"));
+
+      return concat(parts);
+
+    case "ThrowStatement":
+      return concat(["throw ", path.call(print, "argument"), ";"]);
+
+    case "SwitchStatement":
+      return concat([
+        "switch (",
+        path.call(print, "discriminant"),
+        ") {\n",
+        fromString("\n").join(path.map(print, "cases")),
+        "\n}",
+      ]);
+
+    // Note: ignoring n.lexical because it has no printing consequences.
+
+    case "SwitchCase":
+      if (n.test) parts.push("case ", path.call(print, "test"), ":");
+      else parts.push("default:");
+
+      if (n.consequent.length > 0) {
+        parts.push(
+          "\n",
+          path
+            .call(
+              (consequentPath: any) =>
+                printStatementSequence(consequentPath, options, print),
+              "consequent",
+            )
+            .indent(options.tabWidth),
+        );
+      }
+
+      return concat(parts);
+
+    case "DebuggerStatement":
+      return fromString("debugger;");
+
+    // JSX extensions below.
+
+    case "JSXAttribute":
+      parts.push(path.call(print, "name"));
+      if (n.value) parts.push("=", path.call(print, "value"));
+      return concat(parts);
+
+    case "JSXIdentifier":
+      return fromString(n.name, options);
+
+    case "JSXNamespacedName":
+      return fromString(":").join([
+        path.call(print, "namespace"),
+        path.call(print, "name"),
+      ]);
+
+    case "JSXMemberExpression":
+      return fromString(".").join([
+        path.call(print, "object"),
+        path.call(print, "property"),
+      ]);
+
+    case "JSXSpreadAttribute":
+      return concat(["{...", path.call(print, "argument"), "}"]);
+
+    case "JSXSpreadChild":
+      return concat(["{...", path.call(print, "expression"), "}"]);
+
+    case "JSXExpressionContainer":
+      return concat(["{", path.call(print, "expression"), "}"]);
+
+    case "JSXElement":
+    case "JSXFragment": {
+      const openingPropName =
+        "opening" + (n.type === "JSXElement" ? "Element" : "Fragment");
+      const closingPropName =
+        "closing" + (n.type === "JSXElement" ? "Element" : "Fragment");
+      const openingLines = path.call(print, openingPropName);
+
+      if (n[openingPropName].selfClosing) {
+        assert.ok(
+          !n[closingPropName],
+          "unexpected " +
+            closingPropName +
+            " element in self-closing " +
+            n.type,
+        );
+        return openingLines;
+      }
+
+      const childLines = concat(
+        path.map(function (childPath: any) {
+          const child = childPath.getValue();
+
+          if (
+            namedTypes.Literal.check(child) &&
+            typeof child.value === "string"
+          ) {
+            if (/\S/.test(child.value)) {
+              return child.value.replace(/^\s+|\s+$/g, "");
+            } else if (/\n/.test(child.value)) {
+              return "\n";
+            }
+          }
+
+          return print(childPath);
+        }, "children"),
+      ).indentTail(options.tabWidth);
+
+      const closingLines = path.call(print, closingPropName);
+
+      return concat([openingLines, childLines, closingLines]);
+    }
+
+    case "JSXOpeningElement": {
+      parts.push("<", path.call(print, "name"));
+      const attrParts: any[] = [];
+
+      path.each(function (attrPath: any) {
+        attrParts.push(" ", print(attrPath));
+      }, "attributes");
+
+      let attrLines = concat(attrParts);
+
+      const needLineWrap =
+        attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn;
+
+      if (needLineWrap) {
+        attrParts.forEach(function (part, i) {
+          if (part === " ") {
+            assert.strictEqual(i % 2, 0);
+            attrParts[i] = "\n";
+          }
+        });
+
+        attrLines = concat(attrParts).indentTail(options.tabWidth);
+      }
+
+      parts.push(attrLines, n.selfClosing ? " />" : ">");
+
+      return concat(parts);
+    }
+
+    case "JSXClosingElement":
+      return concat(["</", path.call(print, "name"), ">"]);
+
+    case "JSXOpeningFragment":
+      return fromString("<>");
+
+    case "JSXClosingFragment":
+      return fromString("</>");
+
+    case "JSXText":
+      return fromString(n.value, options);
+
+    case "JSXEmptyExpression":
+      return fromString("");
+
+    case "TypeAnnotatedIdentifier":
+      return concat([
+        path.call(print, "annotation"),
+        " ",
+        path.call(print, "identifier"),
+      ]);
+
+    case "ClassBody":
+      if (n.body.length === 0) {
+        return fromString("{}");
+      }
+
+      return concat([
+        "{\n",
+        path
+          .call(
+            (bodyPath: any) => printStatementSequence(bodyPath, options, print),
+            "body",
+          )
+          .indent(options.tabWidth),
+        "\n}",
+      ]);
+
+    case "ClassPropertyDefinition":
+      parts.push("static ", path.call(print, "definition"));
+      if (!namedTypes.MethodDefinition.check(n.definition)) parts.push(";");
+      return concat(parts);
+
+    case "ClassProperty": {
+      if (n.declare) {
+        parts.push("declare ");
+      }
+
+      const access = n.accessibility || n.access;
+      if (typeof access === "string") {
+        parts.push(access, " ");
+      }
+
+      if (n.static) {
+        parts.push("static ");
+      }
+
+      if (n.abstract) {
+        parts.push("abstract ");
+      }
+
+      if (n.readonly) {
+        parts.push("readonly ");
+      }
+
+      let key = path.call(print, "key");
+
+      if (n.computed) {
+        key = concat(["[", key, "]"]);
+      }
+
+      if (n.variance) {
+        key = concat([printVariance(path, print), key]);
+      }
+
+      parts.push(key);
+
+      if (n.optional) {
+        parts.push("?");
+      }
+
+      if (n.definite) {
+        parts.push("!");
+      }
+
+      if (n.typeAnnotation) {
+        parts.push(path.call(print, "typeAnnotation"));
+      }
+
+      if (n.value) {
+        parts.push(" = ", path.call(print, "value"));
+      }
+
+      parts.push(";");
+      return concat(parts);
+    }
+
+    case "ClassPrivateProperty":
+      if (n.static) {
+        parts.push("static ");
+      }
+
+      parts.push(path.call(print, "key"));
+
+      if (n.typeAnnotation) {
+        parts.push(path.call(print, "typeAnnotation"));
+      }
+
+      if (n.value) {
+        parts.push(" = ", path.call(print, "value"));
+      }
+
+      parts.push(";");
+      return concat(parts);
+
+    case "ClassAccessorProperty": {
+      parts.push(
+        ...printClassMemberModifiers(n),
+        "accessor ",
+      );
+
+      if (n.computed) {
+        parts.push("[", path.call(print, "key"), "]");
+      } else {
+        parts.push(path.call(print, "key"));
+      }
+
+      if (n.optional) {
+        parts.push("?");
+      }
+
+      if (n.definite) {
+        parts.push("!");
+      }
+
+      if (n.typeAnnotation) {
+        parts.push(path.call(print, "typeAnnotation"));
+      }
+
+      if (n.value) {
+        parts.push(" = ", path.call(print, "value"));
+      }
+
+      parts.push(";");
+
+      return concat(parts);
+    }
+
+    case "ClassDeclaration":
+    case "ClassExpression":
+    case "DeclareClass":
+      if (n.declare) {
+        parts.push("declare ");
+      }
+
+      if (n.abstract) {
+        parts.push("abstract ");
+      }
+
+      parts.push("class");
+
+      if (n.id) {
+        parts.push(" ", path.call(print, "id"));
+      }
+
+      if (n.typeParameters) {
+        parts.push(path.call(print, "typeParameters"));
+      }
+
+      if (n.superClass) {
+        // ClassDeclaration and ClassExpression only
+        parts.push(
+          " extends ",
+          path.call(print, "superClass"),
+          path.call(print, "superTypeParameters"),
+        );
+      }
+
+      if (n.extends && n.extends.length > 0) {
+        // DeclareClass only
+        parts.push(
+          " extends ",
+          fromString(", ").join(path.map(print, "extends")),
+        );
+      }
+
+      if (n["implements"] && n["implements"].length > 0) {
+        parts.push(
+          " implements ",
+          fromString(", ").join(path.map(print, "implements")),
+        );
+      }
+
+      parts.push(" ", path.call(print, "body"));
+
+      if (n.type === "DeclareClass") {
+        return printFlowDeclaration(path, parts);
+      } else {
+        return concat(parts);
+      }
+
+    case "TemplateElement":
+      return fromString(n.value.raw, options).lockIndentTail();
+
+    case "TemplateLiteral": {
+      const expressions = path.map(print, "expressions");
+      parts.push("`");
+
+      path.each(function (childPath: any) {
+        const i = childPath.getName();
+        parts.push(print(childPath));
+        if (i < expressions.length) {
+          parts.push("${", expressions[i], "}");
+        }
+      }, "quasis");
+
+      parts.push("`");
+
+      return concat(parts).lockIndentTail();
+    }
+
+    case "TaggedTemplateExpression":
+      return concat([path.call(print, "tag"), path.call(print, "quasi")]);
+
+    // These types are unprintable because they serve as abstract
+    // supertypes for other (printable) types.
+    case "Node":
+    case "Printable":
+    case "SourceLocation":
+    case "Position":
+    case "Statement":
+    case "Function":
+    case "Pattern":
+    case "Expression":
+    case "Declaration":
+    case "Specifier":
+    case "NamedSpecifier":
+    case "Comment": // Supertype of Block and Line
+    case "Flow": // Supertype of all Flow AST node types
+    case "FlowType": // Supertype of all Flow types
+    case "FlowPredicate": // Supertype of InferredPredicate and DeclaredPredicate
+    case "MemberTypeAnnotation": // Flow
+    case "Type": // Flow
+    case "TSHasOptionalTypeParameterInstantiation":
+    case "TSHasOptionalTypeParameters":
+    case "TSHasOptionalTypeAnnotation":
+    case "ChainElement": // Supertype of MemberExpression and CallExpression
+      throw new Error("unprintable type: " + JSON.stringify(n.type));
+
+    case "CommentBlock": // Babel block comment.
+    case "Block": // Esprima block comment.
+      return concat(["/*", fromString(n.value, options), "*/"]);
+
+    case "CommentLine": // Babel line comment.
+    case "Line": // Esprima line comment.
+      return concat(["//", fromString(n.value, options)]);
+
+    // Type Annotations for Facebook Flow, typically stripped out or
+    // transformed away before printing.
+    case "TypeAnnotation":
+      if (n.typeAnnotation) {
+        if (n.typeAnnotation.type !== "FunctionTypeAnnotation") {
+          parts.push(": ");
+        }
+        parts.push(path.call(print, "typeAnnotation"));
+        return concat(parts);
+      }
+
+      return fromString("");
+
+    case "ExistentialTypeParam":
+    case "ExistsTypeAnnotation":
+      return fromString("*", options);
+
+    case "EmptyTypeAnnotation":
+      return fromString("empty", options);
+
+    case "AnyTypeAnnotation":
+      return fromString("any", options);
+
+    case "MixedTypeAnnotation":
+      return fromString("mixed", options);
+
+    case "ArrayTypeAnnotation":
+      return concat([path.call(print, "elementType"), "[]"]);
+
+    case "TupleTypeAnnotation": {
+      const printed = path.map(print, "types");
+      const joined = fromString(", ").join(printed);
+      const oneLine = joined.getLineLength(1) <= options.wrapColumn;
+      if (oneLine) {
+        if (options.arrayBracketSpacing) {
+          parts.push("[ ");
+        } else {
+          parts.push("[");
+        }
+      } else {
+        parts.push("[\n");
+      }
+
+      path.each(function (elemPath: any) {
+        const i = elemPath.getName();
+        const elem = elemPath.getValue();
+        if (!elem) {
+          // If the array expression ends with a hole, that hole
+          // will be ignored by the interpreter, but if it ends with
+          // two (or more) holes, we need to write out two (or more)
+          // commas so that the resulting code is interpreted with
+          // both (all) of the holes.
+          parts.push(",");
+        } else {
+          let lines = printed[i];
+          if (oneLine) {
+            if (i > 0) parts.push(" ");
+          } else {
+            lines = lines.indent(options.tabWidth);
+          }
+          parts.push(lines);
+          if (
+            i < n.types.length - 1 ||
+            (!oneLine && util.isTrailingCommaEnabled(options, "arrays"))
+          )
+            parts.push(",");
+          if (!oneLine) parts.push("\n");
+        }
+      }, "types");
+
+      if (oneLine && options.arrayBracketSpacing) {
+        parts.push(" ]");
+      } else {
+        parts.push("]");
+      }
+
+      return concat(parts);
+    }
+
+    case "BooleanTypeAnnotation":
+      return fromString("boolean", options);
+
+    case "BooleanLiteralTypeAnnotation":
+      assert.strictEqual(typeof n.value, "boolean");
+      return fromString("" + n.value, options);
+
+    case "InterfaceTypeAnnotation":
+      parts.push("interface");
+      if (n.extends && n.extends.length > 0) {
+        parts.push(
+          " extends ",
+          fromString(", ").join(path.map(print, "extends")),
+        );
+      }
+      parts.push(" ", path.call(print, "body"));
+      return concat(parts);
+
+    case "DeclareFunction":
+      return printFlowDeclaration(path, [
+        "function ",
+        path.call(print, "id"),
+        ";",
+      ]);
+
+    case "DeclareModule":
+      return printFlowDeclaration(path, [
+        "module ",
+        path.call(print, "id"),
+        " ",
+        path.call(print, "body"),
+      ]);
+
+    case "DeclareModuleExports":
+      return printFlowDeclaration(path, [
+        "module.exports",
+        path.call(print, "typeAnnotation"),
+      ]);
+
+    case "DeclareVariable":
+      return printFlowDeclaration(path, ["var ", path.call(print, "id"), ";"]);
+
+    case "DeclareExportDeclaration":
+    case "DeclareExportAllDeclaration":
+      return concat(["declare ", printExportDeclaration(path, options, print)]);
+
+    case "EnumDeclaration":
+      return concat([
+        "enum ",
+        path.call(print, "id"),
+        path.call(print, "body"),
+      ]);
+
+    case "EnumBooleanBody":
+    case "EnumNumberBody":
+    case "EnumStringBody":
+    case "EnumSymbolBody": {
+      if (n.type === "EnumSymbolBody" || n.explicitType) {
+        parts.push(
+          " of ",
+          // EnumBooleanBody => boolean, etc.
+          n.type.slice(4, -4).toLowerCase(),
+        );
+      }
+
+      parts.push(
+        " {\n",
+        fromString("\n")
+          .join(path.map(print, "members"))
+          .indent(options.tabWidth),
+        "\n}",
+      );
+
+      return concat(parts);
+    }
+
+    case "EnumDefaultedMember":
+      return concat([path.call(print, "id"), ","]);
+
+    case "EnumBooleanMember":
+    case "EnumNumberMember":
+    case "EnumStringMember":
+      return concat([
+        path.call(print, "id"),
+        " = ",
+        path.call(print, "init"),
+        ",",
+      ]);
+
+    case "InferredPredicate":
+      return fromString("%checks", options);
+
+    case "DeclaredPredicate":
+      return concat(["%checks(", path.call(print, "value"), ")"]);
+
+    case "FunctionTypeAnnotation": {
+      // FunctionTypeAnnotation is ambiguous:
+      // declare function(a: B): void; OR
+      // const A: (a: B) => void;
+      const parent = path.getParentNode(0);
+      const isArrowFunctionTypeAnnotation = !(
+        namedTypes.ObjectTypeCallProperty.check(parent) ||
+        (namedTypes.ObjectTypeInternalSlot.check(parent) && parent.method) ||
+        namedTypes.DeclareFunction.check(path.getParentNode(2))
+      );
+
+      const needsColon =
+        isArrowFunctionTypeAnnotation &&
+        !namedTypes.FunctionTypeParam.check(parent) &&
+        !namedTypes.TypeAlias.check(parent);
+
+      if (needsColon) {
+        parts.push(": ");
+      }
+
+      const hasTypeParameters = !!n.typeParameters;
+      const needsParens =
+        hasTypeParameters || n.params.length !== 1 || n.params[0].name;
+
+      parts.push(
+        hasTypeParameters ? path.call(print, "typeParameters") : "",
+        needsParens ? "(" : "",
+        printFunctionParams(path, options, print),
+        needsParens ? ")" : "",
+      );
+
+      // The returnType is not wrapped in a TypeAnnotation, so the colon
+      // needs to be added separately.
+      if (n.returnType) {
+        parts.push(
+          isArrowFunctionTypeAnnotation ? " => " : ": ",
+          path.call(print, "returnType"),
+        );
+      }
+
+      return concat(parts);
+    }
+
+    case "FunctionTypeParam": {
+      const name = path.call(print, "name");
+      parts.push(name);
+      if (n.optional) {
+        parts.push("?");
+      }
+      if (name.infos[0].line) {
+        parts.push(": ");
+      }
+      parts.push(path.call(print, "typeAnnotation"));
+
+      return concat(parts);
+    }
+
+    case "GenericTypeAnnotation":
+      return concat([
+        path.call(print, "id"),
+        path.call(print, "typeParameters"),
+      ]);
+
+    case "DeclareInterface":
+      parts.push("declare ");
+    // Fall through to InterfaceDeclaration...
+
+    case "InterfaceDeclaration":
+    case "TSInterfaceDeclaration":
+      if (n.declare) {
+        parts.push("declare ");
+      }
+
+      parts.push(
+        "interface ",
+        path.call(print, "id"),
+        path.call(print, "typeParameters"),
+        " ",
+      );
+
+      if (n["extends"] && n["extends"].length > 0) {
+        parts.push(
+          "extends ",
+          fromString(", ").join(path.map(print, "extends")),
+          " ",
+        );
+      }
+
+      if (n.body) {
+        parts.push(path.call(print, "body"));
+      }
+
+      return concat(parts);
+
+    case "ClassImplements":
+    case "InterfaceExtends":
+      return concat([
+        path.call(print, "id"),
+        path.call(print, "typeParameters"),
+      ]);
+
+    case "IntersectionTypeAnnotation":
+      return fromString(" & ").join(path.map(print, "types"));
+
+    case "NullableTypeAnnotation":
+      return concat(["?", path.call(print, "typeAnnotation")]);
+
+    case "NullLiteralTypeAnnotation":
+      return fromString("null", options);
+
+    case "ThisTypeAnnotation":
+      return fromString("this", options);
+
+    case "NumberTypeAnnotation":
+      return fromString("number", options);
+
+    case "ObjectTypeCallProperty":
+      return path.call(print, "value");
+
+    case "ObjectTypeIndexer":
+      if (n.static) {
+        parts.push("static ");
+      }
+
+      parts.push(printVariance(path, print), "[");
+
+      if (n.id) {
+        parts.push(path.call(print, "id"), ": ");
+      }
+
+      parts.push(path.call(print, "key"), "]: ", path.call(print, "value"));
+
+      return concat(parts);
+
+    case "ObjectTypeProperty":
+      return concat([
+        printVariance(path, print),
+        path.call(print, "key"),
+        n.optional ? "?" : "",
+        ": ",
+        path.call(print, "value"),
+      ]);
+
+    case "ObjectTypeInternalSlot":
+      return concat([
+        n.static ? "static " : "",
+        "[[",
+        path.call(print, "id"),
+        "]]",
+        n.optional ? "?" : "",
+        n.value.type !== "FunctionTypeAnnotation" ? ": " : "",
+        path.call(print, "value"),
+      ]);
+
+    case "QualifiedTypeIdentifier":
+      return concat([
+        path.call(print, "qualification"),
+        ".",
+        path.call(print, "id"),
+      ]);
+
+    case "StringLiteralTypeAnnotation":
+      return fromString(nodeStr(n.value, options), options);
+
+    case "NumberLiteralTypeAnnotation":
+    case "NumericLiteralTypeAnnotation":
+      assert.strictEqual(typeof n.value, "number");
+      return fromString(JSON.stringify(n.value), options);
+
+    case "BigIntLiteralTypeAnnotation":
+      return fromString(n.raw, options);
+
+    case "StringTypeAnnotation":
+      return fromString("string", options);
+
+    case "DeclareTypeAlias":
+      parts.push("declare ");
+    // Fall through to TypeAlias...
+
+    case "TypeAlias":
+      return concat([
+        "type ",
+        path.call(print, "id"),
+        path.call(print, "typeParameters"),
+        " = ",
+        path.call(print, "right"),
+        ";",
+      ]);
+
+    case "DeclareOpaqueType":
+      parts.push("declare ");
+    // Fall through to OpaqueType...
+
+    case "OpaqueType":
+      parts.push(
+        "opaque type ",
+        path.call(print, "id"),
+        path.call(print, "typeParameters"),
+      );
+
+      if (n["supertype"]) {
+        parts.push(": ", path.call(print, "supertype"));
+      }
+
+      if (n["impltype"]) {
+        parts.push(" = ", path.call(print, "impltype"));
+      }
+
+      parts.push(";");
+
+      return concat(parts);
+
+    case "TypeCastExpression":
+      return concat([
+        "(",
+        path.call(print, "expression"),
+        path.call(print, "typeAnnotation"),
+        ")",
+      ]);
+
+    case "TypeParameterDeclaration":
+    case "TypeParameterInstantiation":
+      return concat([
+        "<",
+        fromString(", ").join(path.map(print, "params")),
+        ">",
+      ]);
+
+    case "Variance":
+      if (n.kind === "plus") {
+        return fromString("+");
+      }
+
+      if (n.kind === "minus") {
+        return fromString("-");
+      }
+
+      return fromString("");
+
+    case "TypeParameter":
+      if (n.variance) {
+        parts.push(printVariance(path, print));
+      }
+
+      parts.push(path.call(print, "name"));
+
+      if (n.bound) {
+        parts.push(path.call(print, "bound"));
+      }
+
+      if (n["default"]) {
+        parts.push("=", path.call(print, "default"));
+      }
+
+      return concat(parts);
+
+    case "TypeofTypeAnnotation":
+      return concat([
+        fromString("typeof ", options),
+        path.call(print, "argument"),
+      ]);
+
+    case "IndexedAccessType":
+    case "OptionalIndexedAccessType":
+      return concat([
+        path.call(print, "objectType"),
+        n.optional ? "?." : "",
+        "[",
+        path.call(print, "indexType"),
+        "]",
+      ]);
+
+    case "UnionTypeAnnotation":
+      return fromString(" | ").join(path.map(print, "types"));
+
+    case "VoidTypeAnnotation":
+      return fromString("void", options);
+
+    case "NullTypeAnnotation":
+      return fromString("null", options);
+
+    case "SymbolTypeAnnotation":
+      return fromString("symbol", options);
+
+    case "BigIntTypeAnnotation":
+      return fromString("bigint", options);
+
+    // Type Annotations for TypeScript (when using Babylon as parser)
+    case "TSType":
+      throw new Error("unprintable type: " + JSON.stringify(n.type));
+
+    case "TSNumberKeyword":
+      return fromString("number", options);
+
+    case "TSBigIntKeyword":
+      return fromString("bigint", options);
+
+    case "TSObjectKeyword":
+      return fromString("object", options);
+
+    case "TSBooleanKeyword":
+      return fromString("boolean", options);
+
+    case "TSStringKeyword":
+      return fromString("string", options);
+
+    case "TSSymbolKeyword":
+      return fromString("symbol", options);
+
+    case "TSAnyKeyword":
+      return fromString("any", options);
+
+    case "TSVoidKeyword":
+      return fromString("void", options);
+
+    case "TSIntrinsicKeyword":
+      return fromString("intrinsic", options);
+
+    case "TSThisType":
+      return fromString("this", options);
+
+    case "TSNullKeyword":
+      return fromString("null", options);
+
+    case "TSUndefinedKeyword":
+      return fromString("undefined", options);
+
+    case "TSUnknownKeyword":
+      return fromString("unknown", options);
+
+    case "TSNeverKeyword":
+      return fromString("never", options);
+
+    case "TSArrayType":
+      return concat([path.call(print, "elementType"), "[]"]);
+
+    case "TSLiteralType":
+      return path.call(print, "literal");
+
+    case "TSUnionType":
+      return fromString(" | ").join(path.map(print, "types"));
+
+    case "TSIntersectionType":
+      return fromString(" & ").join(path.map(print, "types"));
+
+    case "TSConditionalType":
+      parts.push(
+        path.call(print, "checkType"),
+        " extends ",
+        path.call(print, "extendsType"),
+        " ? ",
+        path.call(print, "trueType"),
+        " : ",
+        path.call(print, "falseType"),
+      );
+
+      return concat(parts);
+
+    case "TSInferType":
+      parts.push("infer ", path.call(print, "typeParameter"));
+
+      return concat(parts);
+
+    case "TSParenthesizedType":
+      return concat(["(", path.call(print, "typeAnnotation"), ")"]);
+
+    case "TSFunctionType":
+      return concat([
+        path.call(print, "typeParameters"),
+        "(",
+        printFunctionParams(path, options, print),
+        ") => ",
+        path.call(print, "typeAnnotation", "typeAnnotation"),
+      ]);
+
+    case "TSConstructorType":
+      return concat([
+        "new ",
+        path.call(print, "typeParameters"),
+        "(",
+        printFunctionParams(path, options, print),
+        ") => ",
+        path.call(print, "typeAnnotation", "typeAnnotation"),
+      ]);
+
+    case "TSMappedType": {
+      parts.push(
+        n.readonly ? "readonly " : "",
+        "[",
+        path.call(print, "typeParameter"),
+        "]",
+        n.optional ? "?" : "",
+      );
+
+      if (n.typeAnnotation) {
+        parts.push(": ", path.call(print, "typeAnnotation"), ";");
+      }
+
+      return concat(["{\n", concat(parts).indent(options.tabWidth), "\n}"]);
+    }
+
+    case "TSTupleType":
+      return concat([
+        "[",
+        fromString(", ").join(path.map(print, "elementTypes")),
+        "]",
+      ]);
+
+    case "TSNamedTupleMember":
+      parts.push(path.call(print, "label"));
+
+      if (n.optional) {
+        parts.push("?");
+      }
+
+      parts.push(": ", path.call(print, "elementType"));
+
+      return concat(parts);
+
+    case "TSRestType":
+      return concat(["...", path.call(print, "typeAnnotation")]);
+
+    case "TSOptionalType":
+      return concat([path.call(print, "typeAnnotation"), "?"]);
+
+    case "TSIndexedAccessType":
+      return concat([
+        path.call(print, "objectType"),
+        "[",
+        path.call(print, "indexType"),
+        "]",
+      ]);
+
+    case "TSTypeOperator":
+      return concat([
+        path.call(print, "operator"),
+        " ",
+        path.call(print, "typeAnnotation"),
+      ]);
+
+    case "TSTypeLiteral": {
+      const members = fromString("\n").join(
+        path.map(print, "members").map((member: Lines) => {
+          if (lastNonSpaceCharacter(member) !== ";") {
+            return member.concat(";");
+          }
+          return member;
+        })
+      );
+
+      if (members.isEmpty()) {
+        return fromString("{}", options);
+      }
+
+      parts.push("{\n", members.indent(options.tabWidth), "\n}");
+
+      return concat(parts);
+    }
+
+    case "TSEnumMember":
+      parts.push(path.call(print, "id"));
+      if (n.initializer) {
+        parts.push(" = ", path.call(print, "initializer"));
+      }
+      return concat(parts);
+
+    case "TSTypeQuery":
+      return concat(["typeof ", path.call(print, "exprName")]);
+
+    case "TSParameterProperty":
+      if (n.accessibility) {
+        parts.push(n.accessibility, " ");
+      }
+
+      if (n.export) {
+        parts.push("export ");
+      }
+
+      if (n.static) {
+        parts.push("static ");
+      }
+
+      if (n.readonly) {
+        parts.push("readonly ");
+      }
+
+      parts.push(path.call(print, "parameter"));
+
+      return concat(parts);
+
+    case "TSTypeReference":
+      return concat([
+        path.call(print, "typeName"),
+        path.call(print, "typeParameters"),
+      ]);
+
+    case "TSQualifiedName":
+      return concat([path.call(print, "left"), ".", path.call(print, "right")]);
+
+    case "TSAsExpression":
+    case "TSSatisfiesExpression":
+    {
+      const expression = path.call(print, "expression");
+      parts.push(
+        expression,
+        n.type === "TSSatisfiesExpression" ? " satisfies " : " as ",
+        path.call(print, "typeAnnotation"),
+      );
+      return concat(parts);
+    }
+
+    case "TSTypeCastExpression":
+      return concat([
+        path.call(print, "expression"),
+        path.call(print, "typeAnnotation"),
+      ]);
+
+    case "TSNonNullExpression":
+      return concat([path.call(print, "expression"), "!"]);
+
+    case "TSTypeAnnotation":
+      return concat([": ", path.call(print, "typeAnnotation")]);
+
+    case "TSIndexSignature":
+      return concat([
+        n.readonly ? "readonly " : "",
+        "[",
+        path.map(print, "parameters"),
+        "]",
+        path.call(print, "typeAnnotation"),
+      ]);
+
+    case "TSPropertySignature":
+      parts.push(printVariance(path, print), n.readonly ? "readonly " : "");
+
+      if (n.computed) {
+        parts.push("[", path.call(print, "key"), "]");
+      } else {
+        parts.push(path.call(print, "key"));
+      }
+
+      parts.push(n.optional ? "?" : "", path.call(print, "typeAnnotation"));
+
+      return concat(parts);
+
+    case "TSMethodSignature":
+      if (n.computed) {
+        parts.push("[", path.call(print, "key"), "]");
+      } else {
+        parts.push(path.call(print, "key"));
+      }
+
+      if (n.optional) {
+        parts.push("?");
+      }
+
+      parts.push(
+        path.call(print, "typeParameters"),
+        "(",
+        printFunctionParams(path, options, print),
+        ")",
+        path.call(print, "typeAnnotation"),
+      );
+
+      return concat(parts);
+
+    case "TSTypePredicate":
+      if (n.asserts) {
+        parts.push("asserts ");
+      }
+
+      parts.push(path.call(print, "parameterName"));
+
+      if (n.typeAnnotation) {
+        parts.push(
+          " is ",
+          path.call(print, "typeAnnotation", "typeAnnotation"),
+        );
+      }
+
+      return concat(parts);
+
+    case "TSCallSignatureDeclaration":
+      return concat([
+        path.call(print, "typeParameters"),
+        "(",
+        printFunctionParams(path, options, print),
+        ")",
+        path.call(print, "typeAnnotation"),
+      ]);
+
+    case "TSConstructSignatureDeclaration":
+      if (n.typeParameters) {
+        parts.push("new", path.call(print, "typeParameters"));
+      } else {
+        parts.push("new ");
+      }
+
+      parts.push(
+        "(",
+        printFunctionParams(path, options, print),
+        ")",
+        path.call(print, "typeAnnotation"),
+      );
+
+      return concat(parts);
+
+    case "TSTypeAliasDeclaration":
+      return concat([
+        n.declare ? "declare " : "",
+        "type ",
+        path.call(print, "id"),
+        path.call(print, "typeParameters"),
+        " = ",
+        path.call(print, "typeAnnotation"),
+        ";",
+      ]);
+
+    case "TSTypeParameter": {
+      parts.push(path.call(print, "name"));
+
+      // ambiguous because of TSMappedType
+      const parent = path.getParentNode(0);
+      const isInMappedType = namedTypes.TSMappedType.check(parent);
+
+      if (n.constraint) {
+        parts.push(
+          isInMappedType ? " in " : " extends ",
+          path.call(print, "constraint"),
+        );
+      }
+
+      if (n["default"]) {
+        parts.push(" = ", path.call(print, "default"));
+      }
+
+      return concat(parts);
+    }
+
+    case "TSTypeAssertion": {
+      parts.push(
+        "<",
+        path.call(print, "typeAnnotation"),
+        "> ",
+        path.call(print, "expression"),
+      );
+      return concat(parts);
+    }
+
+    case "TSTypeParameterDeclaration":
+    case "TSTypeParameterInstantiation":
+      return concat([
+        "<",
+        fromString(", ").join(path.map(print, "params")),
+        ">",
+      ]);
+
+    case "TSEnumDeclaration": {
+      parts.push(
+        n.declare ? "declare " : "",
+        n.const ? "const " : "",
+        "enum ",
+        path.call(print, "id"),
+      );
+
+      const memberLines = fromString(",\n").join(path.map(print, "members"));
+
+      if (memberLines.isEmpty()) {
+        parts.push(" {}");
+      } else {
+        parts.push(" {\n", memberLines.indent(options.tabWidth), "\n}");
+      }
+
+      return concat(parts);
+    }
+
+    case "TSExpressionWithTypeArguments":
+      return concat([
+        path.call(print, "expression"),
+        path.call(print, "typeParameters"),
+      ]);
+
+    case "TSInterfaceBody": {
+      const lines = fromString("\n").join(
+        path.map(print, "body").map((element: Lines) => {
+          if (lastNonSpaceCharacter(element) !== ";") {
+            return element.concat(";");
+          }
+          return element;
+        })
+      );
+      if (lines.isEmpty()) {
+        return fromString("{}", options);
+      }
+      return concat(["{\n", lines.indent(options.tabWidth), "\n}"]);
+    }
+
+    case "TSImportType":
+      parts.push("import(", path.call(print, "argument"), ")");
+
+      if (n.qualifier) {
+        parts.push(".", path.call(print, "qualifier"));
+      }
+
+      if (n.typeParameters) {
+        parts.push(path.call(print, "typeParameters"));
+      }
+
+      return concat(parts);
+
+    case "TSImportEqualsDeclaration":
+      if (n.isExport) {
+        parts.push("export ");
+      }
+
+      parts.push(
+        "import ",
+        path.call(print, "id"),
+        " = ",
+        path.call(print, "moduleReference"),
+      );
+
+      return maybeAddSemicolon(concat(parts));
+
+    case "TSExternalModuleReference":
+      return concat(["require(", path.call(print, "expression"), ")"]);
+
+    case "TSModuleDeclaration": {
+      const parent = path.getParentNode();
+
+      if (parent.type === "TSModuleDeclaration") {
+        parts.push(".");
+      } else {
+        if (n.declare) {
+          parts.push("declare ");
+        }
+
+        if (!n.global) {
+          const isExternal =
+            n.id.type === "StringLiteral" ||
+            (n.id.type === "Literal" && typeof n.id.value === "string");
+
+          if (isExternal) {
+            parts.push("module ");
+          } else if (n.loc && n.loc.lines && n.id.loc) {
+            const prefix = n.loc.lines.sliceString(n.loc.start, n.id.loc.start);
+
+            // These keywords are fundamentally ambiguous in the
+            // Babylon parser, and not reflected in the AST, so
+            // the best we can do is to match the original code,
+            // when possible.
+            if (prefix.indexOf("module") >= 0) {
+              parts.push("module ");
+            } else {
+              parts.push("namespace ");
+            }
+          } else {
+            parts.push("namespace ");
+          }
+        }
+      }
+
+      parts.push(path.call(print, "id"));
+
+      if (n.body) {
+        parts.push(" ");
+        parts.push(path.call(print, "body"));
+      }
+
+      return concat(parts);
+    }
+
+    case "TSModuleBlock": {
+      const naked = path.call(
+        (bodyPath: any) => printStatementSequence(bodyPath, options, print),
+        "body",
+      );
+
+      if (naked.isEmpty()) {
+        parts.push("{}");
+      } else {
+        parts.push("{\n", naked.indent(options.tabWidth), "\n}");
+      }
+
+      return concat(parts);
+    }
+
+    case "TSInstantiationExpression": {
+      parts.push(
+        path.call(print, "expression"),
+        path.call(print, "typeParameters"),
+      );
+
+      return concat(parts);
+    }
+
+
+    // https://github.com/babel/babel/pull/10148
+    case "V8IntrinsicIdentifier":
+      return concat(["%", path.call(print, "name")]);
+
+    // https://github.com/babel/babel/pull/13191
+    case "TopicReference":
+      return fromString("#");
+
+    // Unhandled types below. If encountered, nodes of these types should
+    // be either left alone or desugared into AST types that are fully
+    // supported by the pretty-printer.
+    case "ClassHeritage": // TODO
+    case "ComprehensionBlock": // TODO
+    case "ComprehensionExpression": // TODO
+    case "Glob": // TODO
+    case "GeneratorExpression": // TODO
+    case "LetStatement": // TODO
+    case "LetExpression": // TODO
+    case "GraphExpression": // TODO
+    case "GraphIndexExpression": // TODO
+    case "XMLDefaultDeclaration":
+    case "XMLAnyName":
+    case "XMLQualifiedIdentifier":
+    case "XMLFunctionQualifiedIdentifier":
+    case "XMLAttributeSelector":
+    case "XMLFilterExpression":
+    case "XML":
+    case "XMLElement":
+    case "XMLList":
+    case "XMLEscape":
+    case "XMLText":
+    case "XMLStartTag":
+    case "XMLEndTag":
+    case "XMLPointTag":
+    case "XMLName":
+    case "XMLAttribute":
+    case "XMLCdata":
+    case "XMLComment":
+    case "XMLProcessingInstruction":
+    default:
+      debugger;
+      throw new Error("unknown type: " + JSON.stringify(n.type));
+  }
+}
+
+function printDecorators(path: any, printPath: any) {
+  const parts: any[] = [];
+  const node = path.getValue();
+
+  if (
+    node.decorators &&
+    node.decorators.length > 0 &&
+    // If the parent node is an export declaration, it will be
+    // responsible for printing node.decorators.
+    !util.getParentExportDeclaration(path)
+  ) {
+    path.each(function (decoratorPath: any) {
+      parts.push(printPath(decoratorPath), "\n");
+    }, "decorators");
+  } else if (
+    util.isExportDeclaration(node) &&
+    node.declaration &&
+    node.declaration.decorators
+  ) {
+    // Export declarations are responsible for printing any decorators
+    // that logically apply to node.declaration.
+    path.each(
+      function (decoratorPath: any) {
+        parts.push(printPath(decoratorPath), "\n");
+      },
+      "declaration",
+      "decorators",
+    );
+  }
+
+  return concat(parts);
+}
+
+function printStatementSequence(path: any, options: any, print: any) {
+  const filtered: any[] = [];
+  let sawComment = false;
+  let sawStatement = false;
+
+  path.each(function (stmtPath: any) {
+    const stmt = stmtPath.getValue();
+
+    // Just in case the AST has been modified to contain falsy
+    // "statements," it's safer simply to skip them.
+    if (!stmt) {
+      return;
+    }
+
+    // Skip printing EmptyStatement nodes to avoid leaving stray
+    // semicolons lying around.
+    if (
+      stmt.type === "EmptyStatement" &&
+      !(stmt.comments && stmt.comments.length > 0)
+    ) {
+      return;
+    }
+
+    if (namedTypes.Comment.check(stmt)) {
+      // The pretty printer allows a dangling Comment node to act as
+      // a Statement when the Comment can't be attached to any other
+      // non-Comment node in the tree.
+      sawComment = true;
+    } else if (namedTypes.Statement.check(stmt)) {
+      sawStatement = true;
+    } else {
+      // When the pretty printer encounters a string instead of an
+      // AST node, it just prints the string. This behavior can be
+      // useful for fine-grained formatting decisions like inserting
+      // blank lines.
+      isString.assert(stmt);
+    }
+
+    // We can't hang onto stmtPath outside of this function, because
+    // it's just a reference to a mutable FastPath object, so we have
+    // to go ahead and print it here.
+    filtered.push({
+      node: stmt,
+      printed: print(stmtPath),
+    });
+  });
+
+  if (sawComment) {
+    assert.strictEqual(
+      sawStatement,
+      false,
+      "Comments may appear as statements in otherwise empty statement " +
+        "lists, but may not coexist with non-Comment nodes.",
+    );
+  }
+
+  let prevTrailingSpace: any = null;
+  const len = filtered.length;
+  const parts: any[] = [];
+
+  filtered.forEach(function (info, i) {
+    const printed = info.printed;
+    const stmt = info.node;
+    const multiLine = printed.length > 1;
+    const notFirst = i > 0;
+    const notLast = i < len - 1;
+    let leadingSpace;
+    let trailingSpace;
+    const lines = stmt && stmt.loc && stmt.loc.lines;
+    const trueLoc =
+      lines && options.reuseWhitespace && util.getTrueLoc(stmt, lines);
+
+    if (notFirst) {
+      if (trueLoc) {
+        const beforeStart = lines.skipSpaces(trueLoc.start, true);
+        const beforeStartLine = beforeStart ? beforeStart.line : 1;
+        const leadingGap = trueLoc.start.line - beforeStartLine;
+        leadingSpace = Array(leadingGap + 1).join("\n");
+      } else {
+        leadingSpace = multiLine ? "\n\n" : "\n";
+      }
+    } else {
+      leadingSpace = "";
+    }
+
+    if (notLast) {
+      if (trueLoc) {
+        const afterEnd = lines.skipSpaces(trueLoc.end);
+        const afterEndLine = afterEnd ? afterEnd.line : lines.length;
+        const trailingGap = afterEndLine - trueLoc.end.line;
+        trailingSpace = Array(trailingGap + 1).join("\n");
+      } else {
+        trailingSpace = multiLine ? "\n\n" : "\n";
+      }
+    } else {
+      trailingSpace = "";
+    }
+
+    parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);
+
+    if (notLast) {
+      prevTrailingSpace = trailingSpace;
+    } else if (trailingSpace) {
+      parts.push(trailingSpace);
+    }
+  });
+
+  return concat(parts);
+}
+
+function maxSpace(s1: any, s2: any) {
+  if (!s1 && !s2) {
+    return fromString("");
+  }
+
+  if (!s1) {
+    return fromString(s2);
+  }
+
+  if (!s2) {
+    return fromString(s1);
+  }
+
+  const spaceLines1 = fromString(s1);
+  const spaceLines2 = fromString(s2);
+
+  if (spaceLines2.length > spaceLines1.length) {
+    return spaceLines2;
+  }
+
+  return spaceLines1;
+}
+
+function printClassMemberModifiers(node: any): string[] {
+  const parts = [];
+
+  if (node.declare) {
+    parts.push("declare ");
+  }
+
+  const access = node.accessibility || node.access;
+  if (typeof access === "string") {
+    parts.push(access, " ");
+  }
+
+  if (node.static) {
+    parts.push("static ");
+  }
+
+  if (node.override) {
+    parts.push("override ");
+  }
+
+  if (node.abstract) {
+    parts.push("abstract ");
+  }
+
+  if (node.readonly) {
+    parts.push("readonly ");
+  }
+
+  return parts;
+}
+
+function printMethod(path: any, options: any, print: any) {
+  const node = path.getNode();
+  const kind = node.kind;
+  const parts = [];
+
+  let nodeValue = node.value;
+  if (!namedTypes.FunctionExpression.check(nodeValue)) {
+    nodeValue = node;
+  }
+
+  parts.push(...printClassMemberModifiers(node));
+
+  if (nodeValue.async) {
+    parts.push("async ");
+  }
+
+  if (nodeValue.generator) {
+    parts.push("*");
+  }
+
+  if (kind === "get" || kind === "set") {
+    parts.push(kind, " ");
+  }
+
+  let key = path.call(print, "key");
+  if (node.computed) {
+    key = concat(["[", key, "]"]);
+  }
+
+  parts.push(key);
+
+  if (node.optional) {
+    parts.push("?");
+  }
+
+  if (node === nodeValue) {
+    parts.push(
+      path.call(print, "typeParameters"),
+      "(",
+      printFunctionParams(path, options, print),
+      ")",
+      path.call(print, "returnType"),
+    );
+
+    if (node.body) {
+      parts.push(" ", path.call(print, "body"));
+    } else {
+      parts.push(";");
+    }
+  } else {
+    parts.push(
+      path.call(print, "value", "typeParameters"),
+      "(",
+      path.call(
+        (valuePath: any) => printFunctionParams(valuePath, options, print),
+        "value",
+      ),
+      ")",
+      path.call(print, "value", "returnType"),
+    );
+
+    if (nodeValue.body) {
+      parts.push(" ", path.call(print, "value", "body"));
+    } else {
+      parts.push(";");
+    }
+  }
+
+  return concat(parts);
+}
+
+function printArgumentsList(path: any, options: any, print: any) {
+  const printed = path.map(print, "arguments");
+  const trailingComma = util.isTrailingCommaEnabled(options, "parameters");
+
+  let joined = fromString(", ").join(printed);
+  if (joined.getLineLength(1) > options.wrapColumn) {
+    joined = fromString(",\n").join(printed);
+    return concat([
+      "(\n",
+      joined.indent(options.tabWidth),
+      trailingComma ? ",\n)" : "\n)",
+    ]);
+  }
+
+  return concat(["(", joined, ")"]);
+}
+
+function printFunctionParams(path: any, options: any, print: any) {
+  const fun = path.getValue();
+
+  let params;
+  let printed: Array<Lines> = [];
+  if (fun.params) {
+    params = fun.params;
+    printed = path.map(print, "params");
+  } else if (fun.parameters) {
+    params = fun.parameters;
+    printed = path.map(print, "parameters");
+  }
+
+  if (fun.defaults) {
+    path.each(function (defExprPath: any) {
+      const i = defExprPath.getName();
+      const p = printed[i];
+      if (p && defExprPath.getValue()) {
+        printed[i] = concat([p, " = ", print(defExprPath)]);
+      }
+    }, "defaults");
+  }
+
+  if (fun.rest) {
+    printed.push(concat(["...", path.call(print, "rest")]));
+  }
+
+  let joined = fromString(", ").join(printed);
+  if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {
+    joined = fromString(",\n").join(printed);
+    if (
+      util.isTrailingCommaEnabled(options, "parameters") &&
+      !fun.rest &&
+      params[params.length - 1].type !== "RestElement"
+    ) {
+      joined = concat([joined, ",\n"]);
+    } else {
+      joined = concat([joined, "\n"]);
+    }
+    return concat(["\n", joined.indent(options.tabWidth)]);
+  }
+
+  return joined;
+}
+
+function maybePrintImportAssertions(
+  path: any,
+  options: any,
+  print: any,
+): Lines {
+  const n = path.getValue();
+  if (n.assertions && n.assertions.length > 0) {
+    const parts: (string | Lines)[] = [" assert {"];
+    const printed = path.map(print, "assertions");
+    const flat = fromString(", ").join(printed);
+    if (flat.length > 1 || flat.getLineLength(1) > options.wrapColumn) {
+      parts.push(
+        "\n",
+        fromString(",\n").join(printed).indent(options.tabWidth),
+        "\n}",
+      );
+    } else {
+      parts.push(" ", flat, " }");
+    }
+    return concat(parts);
+  }
+  return fromString("");
+}
+
+function printExportDeclaration(path: any, options: any, print: any) {
+  const decl = path.getValue();
+  const parts: (string | Lines)[] = ["export "];
+  if (decl.exportKind && decl.exportKind === "type") {
+    if (!decl.declaration) {
+      parts.push("type ");
+    }
+  }
+  const shouldPrintSpaces = options.objectCurlySpacing;
+
+  namedTypes.Declaration.assert(decl);
+
+  if (decl["default"] || decl.type === "ExportDefaultDeclaration") {
+    parts.push("default ");
+  }
+
+  if (decl.declaration) {
+    parts.push(path.call(print, "declaration"));
+  } else if (decl.specifiers) {
+    if (
+      decl.specifiers.length === 1 &&
+      decl.specifiers[0].type === "ExportBatchSpecifier"
+    ) {
+      parts.push("*");
+    } else if (decl.specifiers.length === 0) {
+      parts.push("{}");
+    } else if (decl.specifiers[0].type === "ExportDefaultSpecifier") {
+      const unbracedSpecifiers: any[] = [];
+      const bracedSpecifiers: any[] = [];
+
+      path.each(function (specifierPath: any) {
+        const spec = specifierPath.getValue();
+        if (spec.type === "ExportDefaultSpecifier") {
+          unbracedSpecifiers.push(print(specifierPath));
+        } else {
+          bracedSpecifiers.push(print(specifierPath));
+        }
+      }, "specifiers");
+
+      unbracedSpecifiers.forEach((lines, i) => {
+        if (i > 0) {
+          parts.push(", ");
+        }
+        parts.push(lines);
+      });
+
+      if (bracedSpecifiers.length > 0) {
+        let lines = fromString(", ").join(bracedSpecifiers);
+        if (lines.getLineLength(1) > options.wrapColumn) {
+          lines = concat([
+            fromString(",\n").join(bracedSpecifiers).indent(options.tabWidth),
+            ",",
+          ]);
+        }
+
+        if (unbracedSpecifiers.length > 0) {
+          parts.push(", ");
+        }
+
+        if (lines.length > 1) {
+          parts.push("{\n", lines, "\n}");
+        } else if (options.objectCurlySpacing) {
+          parts.push("{ ", lines, " }");
+        } else {
+          parts.push("{", lines, "}");
+        }
+      }
+    } else {
+      parts.push(
+        shouldPrintSpaces ? "{ " : "{",
+        fromString(", ").join(path.map(print, "specifiers")),
+        shouldPrintSpaces ? " }" : "}",
+      );
+    }
+
+    if (decl.source) {
+      parts.push(
+        " from ",
+        path.call(print, "source"),
+        maybePrintImportAssertions(path, options, print),
+      );
+    }
+  }
+
+  let lines = concat(parts);
+  if (
+    lastNonSpaceCharacter(lines) !== ";" &&
+    !(
+      decl.declaration &&
+      (decl.declaration.type === "FunctionDeclaration" ||
+        decl.declaration.type === "ClassDeclaration" ||
+        decl.declaration.type === "TSModuleDeclaration" ||
+        decl.declaration.type === "TSInterfaceDeclaration" ||
+        decl.declaration.type === "TSEnumDeclaration")
+    )
+  ) {
+    lines = concat([lines, ";"]);
+  }
+  return lines;
+}
+
+function printFlowDeclaration(path: any, parts: any) {
+  const parentExportDecl = util.getParentExportDeclaration(path);
+
+  if (parentExportDecl) {
+    assert.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
+  } else {
+    // If the parent node has type DeclareExportDeclaration, then it
+    // will be responsible for printing the "declare" token. Otherwise
+    // it needs to be printed with this non-exported declaration node.
+    parts.unshift("declare ");
+  }
+
+  return concat(parts);
+}
+
+function printVariance(path: any, print: any) {
+  return path.call(function (variancePath: any) {
+    const value = variancePath.getValue();
+
+    if (value) {
+      if (value === "plus") {
+        return fromString("+");
+      }
+
+      if (value === "minus") {
+        return fromString("-");
+      }
+
+      return print(variancePath);
+    }
+
+    return fromString("");
+  }, "variance");
+}
+
+function adjustClause(clause: any, options: any) {
+  if (clause.length > 1) return concat([" ", clause]);
+
+  return concat(["\n", maybeAddSemicolon(clause).indent(options.tabWidth)]);
+}
+
+function lastNonSpaceCharacter(lines: any) {
+  const pos = lines.lastPos();
+  do {
+    const ch = lines.charAt(pos);
+    if (/\S/.test(ch)) return ch;
+  } while (lines.prevPos(pos));
+}
+
+function endsWithBrace(lines: any) {
+  return lastNonSpaceCharacter(lines) === "}";
+}
+
+function swapQuotes(str: string) {
+  return str.replace(/['"]/g, (m) => (m === '"' ? "'" : '"'));
+}
+
+function getPossibleRaw(
+  node:
+    | types.namedTypes.Literal
+    | types.namedTypes.NumericLiteral
+    | types.namedTypes.StringLiteral
+    | types.namedTypes.RegExpLiteral
+    | types.namedTypes.BigIntLiteral
+    | types.namedTypes.DecimalLiteral,
+): string | void {
+  const value = types.getFieldValue(node, "value");
+  const extra = types.getFieldValue(node, "extra");
+
+  if (extra && typeof extra.raw === "string" && value == extra.rawValue) {
+    return extra.raw;
+  }
+
+  if (node.type === "Literal") {
+    const raw = (node as typeof extra).raw;
+    if (typeof raw === "string" && value == raw) {
+      return raw;
+    }
+  }
+}
+
+function jsSafeStringify(str: string) {
+  return JSON.stringify(str).replace(/[\u2028\u2029]/g, function (m) {
+    return "\\u" + m.charCodeAt(0).toString(16);
+  });
+}
+
+function nodeStr(str: string, options: any) {
+  isString.assert(str);
+  switch (options.quote) {
+    case "auto": {
+      const double = jsSafeStringify(str);
+      const single = swapQuotes(jsSafeStringify(swapQuotes(str)));
+      return double.length > single.length ? single : double;
+    }
+    case "single":
+      return swapQuotes(jsSafeStringify(swapQuotes(str)));
+    case "double":
+    default:
+      return jsSafeStringify(str);
+  }
+}
+
+function maybeAddSemicolon(lines: any) {
+  const eoc = lastNonSpaceCharacter(lines);
+  if (!eoc || "\n};".indexOf(eoc) < 0) return concat([lines, ";"]);
+  return lines;
+}
diff --git a/node_modules/recast/lib/util.d.ts b/node_modules/recast/lib/util.d.ts
index 1d2b6e1..be90a93 100644
--- a/node_modules/recast/lib/util.d.ts
+++ b/node_modules/recast/lib/util.d.ts
@@ -1,4 +1,4 @@
-export declare function getLineTerminator(): any;
+export declare function getLineTerminator(): string;
 export declare function isBrowser(): boolean;
 export declare function getOption(options: any, key: any, defaultValue: any): any;
 export declare function getUnionOfKeys(...args: any[]): any;
diff --git a/node_modules/recast/lib/util.js b/node_modules/recast/lib/util.js
index 2d39d66..8a7c968 100644
--- a/node_modules/recast/lib/util.js
+++ b/node_modules/recast/lib/util.js
@@ -6,11 +6,12 @@ var assert_1 = tslib_1.__importDefault(require("assert"));
 var types = tslib_1.__importStar(require("ast-types"));
 var n = types.namedTypes;
 var source_map_1 = tslib_1.__importDefault(require("source-map"));
+var os_1 = require("os");
 var SourceMapConsumer = source_map_1.default.SourceMapConsumer;
 var SourceMapGenerator = source_map_1.default.SourceMapGenerator;
 var hasOwn = Object.prototype.hasOwnProperty;
 function getLineTerminator() {
-    return isBrowser() ? "\n" : require("os").EOL || "\n";
+    return isBrowser() ? "\n" : os_1.EOL || "\n";
 }
 exports.getLineTerminator = getLineTerminator;
 function isBrowser() {
diff --git a/node_modules/recast/lib/util.ts b/node_modules/recast/lib/util.ts
new file mode 100644
index 0000000..e665cf6
--- /dev/null
+++ b/node_modules/recast/lib/util.ts
@@ -0,0 +1,361 @@
+import assert from "assert";
+import * as types from "ast-types";
+const n = types.namedTypes;
+import sourceMap from "source-map";
+import { EOL } from "os";
+const SourceMapConsumer = sourceMap.SourceMapConsumer;
+const SourceMapGenerator = sourceMap.SourceMapGenerator;
+const hasOwn = Object.prototype.hasOwnProperty;
+
+export function getLineTerminator() {
+  return isBrowser() ? "\n" : EOL || "\n";
+}
+
+export function isBrowser() {
+  return (
+    typeof window !== "undefined" && typeof window.document !== "undefined"
+  );
+}
+
+export function getOption(options: any, key: any, defaultValue: any) {
+  if (options && hasOwn.call(options, key)) {
+    return options[key];
+  }
+  return defaultValue;
+}
+
+export function getUnionOfKeys(...args: any[]) {
+  const result: any = {};
+  const argc = args.length;
+  for (let i = 0; i < argc; ++i) {
+    const keys = Object.keys(args[i]);
+    const keyCount = keys.length;
+    for (let j = 0; j < keyCount; ++j) {
+      result[keys[j]] = true;
+    }
+  }
+  return result;
+}
+
+export function comparePos(pos1: any, pos2: any) {
+  return pos1.line - pos2.line || pos1.column - pos2.column;
+}
+
+export function copyPos(pos: any) {
+  return {
+    line: pos.line,
+    column: pos.column,
+  };
+}
+
+export function composeSourceMaps(formerMap: any, latterMap: any) {
+  if (formerMap) {
+    if (!latterMap) {
+      return formerMap;
+    }
+  } else {
+    return latterMap || null;
+  }
+
+  const smcFormer = new SourceMapConsumer(formerMap);
+  const smcLatter = new SourceMapConsumer(latterMap);
+  const smg = new SourceMapGenerator({
+    file: latterMap.file,
+    sourceRoot: latterMap.sourceRoot,
+  });
+
+  const sourcesToContents: any = {};
+
+  smcLatter.eachMapping(function (mapping) {
+    const origPos = smcFormer.originalPositionFor({
+      line: mapping.originalLine,
+      column: mapping.originalColumn,
+    });
+
+    const sourceName = origPos.source;
+    if (sourceName === null) {
+      return;
+    }
+
+    smg.addMapping({
+      source: sourceName,
+      original: copyPos(origPos),
+      generated: {
+        line: mapping.generatedLine,
+        column: mapping.generatedColumn,
+      },
+      name: mapping.name,
+    });
+
+    const sourceContent = smcFormer.sourceContentFor(sourceName);
+    if (sourceContent && !hasOwn.call(sourcesToContents, sourceName)) {
+      sourcesToContents[sourceName] = sourceContent;
+      smg.setSourceContent(sourceName, sourceContent);
+    }
+  });
+
+  return (smg as any).toJSON();
+}
+
+export function getTrueLoc(node: any, lines: any) {
+  // It's possible that node is newly-created (not parsed by Esprima),
+  // in which case it probably won't have a .loc property (or an
+  // .original property for that matter). That's fine; we'll just
+  // pretty-print it as usual.
+  if (!node.loc) {
+    return null;
+  }
+
+  const result = {
+    start: node.loc.start,
+    end: node.loc.end,
+  };
+
+  function include(node: any) {
+    expandLoc(result, node.loc);
+  }
+
+  // If the node is an export declaration and its .declaration has any
+  // decorators, their locations might contribute to the true start/end
+  // positions of the export declaration node.
+  if (
+    node.declaration &&
+    node.declaration.decorators &&
+    isExportDeclaration(node)
+  ) {
+    node.declaration.decorators.forEach(include);
+  }
+
+  if (comparePos(result.start, result.end) < 0) {
+    // Trim leading whitespace.
+    result.start = copyPos(result.start);
+    lines.skipSpaces(result.start, false, true);
+
+    if (comparePos(result.start, result.end) < 0) {
+      // Trim trailing whitespace, if the end location is not already the
+      // same as the start location.
+      result.end = copyPos(result.end);
+      lines.skipSpaces(result.end, true, true);
+    }
+  }
+
+  // If the node has any comments, their locations might contribute to
+  // the true start/end positions of the node.
+  if (node.comments) {
+    node.comments.forEach(include);
+  }
+
+  return result;
+}
+
+function expandLoc(parentLoc: any, childLoc: any) {
+  if (parentLoc && childLoc) {
+    if (comparePos(childLoc.start, parentLoc.start) < 0) {
+      parentLoc.start = childLoc.start;
+    }
+
+    if (comparePos(parentLoc.end, childLoc.end) < 0) {
+      parentLoc.end = childLoc.end;
+    }
+  }
+}
+
+export function fixFaultyLocations(node: any, lines: any) {
+  const loc = node.loc;
+  if (loc) {
+    if (loc.start.line < 1) {
+      loc.start.line = 1;
+    }
+
+    if (loc.end.line < 1) {
+      loc.end.line = 1;
+    }
+  }
+
+  if (node.type === "File") {
+    // Babylon returns File nodes whose .loc.{start,end} do not include
+    // leading or trailing whitespace.
+    loc.start = lines.firstPos();
+    loc.end = lines.lastPos();
+  }
+
+  fixForLoopHead(node, lines);
+  fixTemplateLiteral(node, lines);
+
+  if (loc && node.decorators) {
+    // Expand the .loc of the node responsible for printing the decorators
+    // (here, the decorated node) so that it includes node.decorators.
+    node.decorators.forEach(function (decorator: any) {
+      expandLoc(loc, decorator.loc);
+    });
+  } else if (node.declaration && isExportDeclaration(node)) {
+    // Nullify .loc information for the child declaration so that we never
+    // try to reprint it without also reprinting the export declaration.
+    node.declaration.loc = null;
+
+    // Expand the .loc of the node responsible for printing the decorators
+    // (here, the export declaration) so that it includes node.decorators.
+    const decorators = node.declaration.decorators;
+    if (decorators) {
+      decorators.forEach(function (decorator: any) {
+        expandLoc(loc, decorator.loc);
+      });
+    }
+  } else if (
+    (n.MethodDefinition && n.MethodDefinition.check(node)) ||
+    (n.Property.check(node) && (node.method || node.shorthand))
+  ) {
+    // If the node is a MethodDefinition or a .method or .shorthand
+    // Property, then the location information stored in
+    // node.value.loc is very likely untrustworthy (just the {body}
+    // part of a method, or nothing in the case of shorthand
+    // properties), so we null out that information to prevent
+    // accidental reuse of bogus source code during reprinting.
+    node.value.loc = null;
+
+    if (n.FunctionExpression.check(node.value)) {
+      // FunctionExpression method values should be anonymous,
+      // because their .id fields are ignored anyway.
+      node.value.id = null;
+    }
+  } else if (node.type === "ObjectTypeProperty") {
+    const loc = node.loc;
+    let end = loc && loc.end;
+    if (end) {
+      end = copyPos(end);
+      if (lines.prevPos(end) && lines.charAt(end) === ",") {
+        // Some parsers accidentally include trailing commas in the
+        // .loc.end information for ObjectTypeProperty nodes.
+        if ((end = lines.skipSpaces(end, true, true))) {
+          loc.end = end;
+        }
+      }
+    }
+  }
+}
+
+function fixForLoopHead(node: any, lines: any) {
+  if (node.type !== "ForStatement") {
+    return;
+  }
+
+  function fix(child: any) {
+    const loc = child && child.loc;
+    const start = loc && loc.start;
+    const end = loc && copyPos(loc.end);
+
+    while (start && end && comparePos(start, end) < 0) {
+      lines.prevPos(end);
+      if (lines.charAt(end) === ";") {
+        // Update child.loc.end to *exclude* the ';' character.
+        loc.end.line = end.line;
+        loc.end.column = end.column;
+      } else {
+        break;
+      }
+    }
+  }
+
+  fix(node.init);
+  fix(node.test);
+  fix(node.update);
+}
+
+function fixTemplateLiteral(node: any, lines: any) {
+  if (node.type !== "TemplateLiteral") {
+    return;
+  }
+
+  if (node.quasis.length === 0) {
+    // If there are no quasi elements, then there is nothing to fix.
+    return;
+  }
+
+  // node.loc is not present when using export default with a template literal
+  if (node.loc) {
+    // First we need to exclude the opening ` from the .loc of the first
+    // quasi element, in case the parser accidentally decided to include it.
+    const afterLeftBackTickPos = copyPos(node.loc.start);
+    assert.strictEqual(lines.charAt(afterLeftBackTickPos), "`");
+    assert.ok(lines.nextPos(afterLeftBackTickPos));
+    const firstQuasi = node.quasis[0];
+    if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {
+      firstQuasi.loc.start = afterLeftBackTickPos;
+    }
+
+    // Next we need to exclude the closing ` from the .loc of the last quasi
+    // element, in case the parser accidentally decided to include it.
+    const rightBackTickPos = copyPos(node.loc.end);
+    assert.ok(lines.prevPos(rightBackTickPos));
+    assert.strictEqual(lines.charAt(rightBackTickPos), "`");
+    const lastQuasi = node.quasis[node.quasis.length - 1];
+    if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {
+      lastQuasi.loc.end = rightBackTickPos;
+    }
+  }
+
+  // Now we need to exclude ${ and } characters from the .loc's of all
+  // quasi elements, since some parsers accidentally include them.
+  node.expressions.forEach(function (expr: any, i: any) {
+    // Rewind from expr.loc.start over any whitespace and the ${ that
+    // precedes the expression. The position of the $ should be the same
+    // as the .loc.end of the preceding quasi element, but some parsers
+    // accidentally include the ${ in the .loc of the quasi element.
+    const dollarCurlyPos = lines.skipSpaces(expr.loc.start, true, false);
+    if (
+      lines.prevPos(dollarCurlyPos) &&
+      lines.charAt(dollarCurlyPos) === "{" &&
+      lines.prevPos(dollarCurlyPos) &&
+      lines.charAt(dollarCurlyPos) === "$"
+    ) {
+      const quasiBefore = node.quasis[i];
+      if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {
+        quasiBefore.loc.end = dollarCurlyPos;
+      }
+    }
+
+    // Likewise, some parsers accidentally include the } that follows
+    // the expression in the .loc of the following quasi element.
+    const rightCurlyPos = lines.skipSpaces(expr.loc.end, false, false);
+    if (lines.charAt(rightCurlyPos) === "}") {
+      assert.ok(lines.nextPos(rightCurlyPos));
+      // Now rightCurlyPos is technically the position just after the }.
+      const quasiAfter = node.quasis[i + 1];
+      if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {
+        quasiAfter.loc.start = rightCurlyPos;
+      }
+    }
+  });
+}
+
+export function isExportDeclaration(node: any) {
+  if (node)
+    switch (node.type) {
+      case "ExportDeclaration":
+      case "ExportDefaultDeclaration":
+      case "ExportDefaultSpecifier":
+      case "DeclareExportDeclaration":
+      case "ExportNamedDeclaration":
+      case "ExportAllDeclaration":
+        return true;
+    }
+
+  return false;
+}
+
+export function getParentExportDeclaration(path: any) {
+  const parentNode = path.getParentNode();
+  if (path.getName() === "declaration" && isExportDeclaration(parentNode)) {
+    return parentNode;
+  }
+
+  return null;
+}
+
+export function isTrailingCommaEnabled(options: any, context: any) {
+  const trailingComma = options.trailingComma;
+  if (typeof trailingComma === "object") {
+    return !!trailingComma[context];
+  }
+  return !!trailingComma;
+}
diff --git a/node_modules/recast/main.d.ts b/node_modules/recast/main.d.ts
index ae89c3b..767c0cb 100644
--- a/node_modules/recast/main.d.ts
+++ b/node_modules/recast/main.d.ts
@@ -1,6 +1,6 @@
 import * as types from "ast-types";
-import { parse } from "./lib/parser";
-import { Options } from "./lib/options";
+import { parse } from "./lib/parser.js";
+import { Options } from "./lib/options.js";
 export { 
 /**
  * Parse a string of code into an augmented syntax tree suitable for
@@ -28,16 +28,16 @@ export { visit } from "ast-types";
 /**
  * Options shared between parsing and printing.
  */
-export { Options } from "./lib/options";
+export { Options } from "./lib/options.js";
 /**
  * Reprint a modified syntax tree using as much of the original source
  * code as possible.
  */
-export declare function print(node: types.ASTNode, options?: Options): import("./lib/printer").PrintResultType;
+export declare function print(node: types.ASTNode, options?: Options): import("./lib/printer.js").PrintResultType;
 /**
  * Print without attempting to reuse any original source code.
  */
-export declare function prettyPrint(node: types.ASTNode, options?: Options): import("./lib/printer").PrintResultType;
+export declare function prettyPrint(node: types.ASTNode, options?: Options): import("./lib/printer.js").PrintResultType;
 /**
  * Convenient command-line interface (see e.g. example/add-braces).
  */
diff --git a/node_modules/recast/main.js b/node_modules/recast/main.js
index 4ef3aff..c886bbf 100644
--- a/node_modules/recast/main.js
+++ b/node_modules/recast/main.js
@@ -5,9 +5,9 @@ var tslib_1 = require("tslib");
 var fs_1 = tslib_1.__importDefault(require("fs"));
 var types = tslib_1.__importStar(require("ast-types"));
 exports.types = types;
-var parser_1 = require("./lib/parser");
-Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parser_1.parse; } });
-var printer_1 = require("./lib/printer");
+var parser_js_1 = require("./lib/parser.js");
+Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parser_js_1.parse; } });
+var printer_js_1 = require("./lib/printer.js");
 /**
  * Traverse and potentially modify an abstract syntax tree using a
  * convenient visitor syntax:
@@ -28,14 +28,14 @@ Object.defineProperty(exports, "visit", { enumerable: true, get: function () { r
  * code as possible.
  */
 function print(node, options) {
-    return new printer_1.Printer(options).print(node);
+    return new printer_js_1.Printer(options).print(node);
 }
 exports.print = print;
 /**
  * Print without attempting to reuse any original source code.
  */
 function prettyPrint(node, options) {
-    return new printer_1.Printer(options).printGenerically(node);
+    return new printer_js_1.Printer(options).printGenerically(node);
 }
 exports.prettyPrint = prettyPrint;
 /**
@@ -59,7 +59,7 @@ function defaultWriteback(output) {
 }
 function runString(code, transformer, options) {
     var writeback = (options && options.writeback) || defaultWriteback;
-    transformer((0, parser_1.parse)(code, options), function (node) {
+    transformer((0, parser_js_1.parse)(code, options), function (node) {
         writeback(print(node, options).code);
     });
 }
diff --git a/node_modules/recast/main.ts b/node_modules/recast/main.ts
new file mode 100644
index 0000000..850abc7
--- /dev/null
+++ b/node_modules/recast/main.ts
@@ -0,0 +1,93 @@
+import fs from "fs";
+import * as types from "ast-types";
+import { parse } from "./lib/parser.js";
+import { Printer } from "./lib/printer.js";
+import { Options } from "./lib/options.js";
+
+export {
+  /**
+   * Parse a string of code into an augmented syntax tree suitable for
+   * arbitrary modification and reprinting.
+   */
+  parse,
+  /**
+   * Convenient shorthand for the ast-types package.
+   */
+  types,
+};
+
+/**
+ * Traverse and potentially modify an abstract syntax tree using a
+ * convenient visitor syntax:
+ *
+ *   recast.visit(ast, {
+ *     names: [],
+ *     visitIdentifier: function(path) {
+ *       var node = path.value;
+ *       this.visitor.names.push(node.name);
+ *       this.traverse(path);
+ *     }
+ *   });
+ */
+export { visit } from "ast-types";
+
+/**
+ * Options shared between parsing and printing.
+ */
+export { Options } from "./lib/options.js";
+
+/**
+ * Reprint a modified syntax tree using as much of the original source
+ * code as possible.
+ */
+export function print(node: types.ASTNode, options?: Options) {
+  return new Printer(options).print(node);
+}
+
+/**
+ * Print without attempting to reuse any original source code.
+ */
+export function prettyPrint(node: types.ASTNode, options?: Options) {
+  return new Printer(options).printGenerically(node);
+}
+
+/**
+ * Convenient command-line interface (see e.g. example/add-braces).
+ */
+export function run(transformer: Transformer, options?: RunOptions) {
+  return runFile(process.argv[2], transformer, options);
+}
+
+export interface Transformer {
+  (ast: types.ASTNode, callback: (ast: types.ASTNode) => void): void;
+}
+
+export interface RunOptions extends Options {
+  writeback?(code: string): void;
+}
+
+function runFile(path: any, transformer: Transformer, options?: RunOptions) {
+  fs.readFile(path, "utf-8", function (err, code) {
+    if (err) {
+      console.error(err);
+      return;
+    }
+
+    runString(code, transformer, options);
+  });
+}
+
+function defaultWriteback(output: string) {
+  process.stdout.write(output);
+}
+
+function runString(
+  code: string,
+  transformer: Transformer,
+  options?: RunOptions,
+) {
+  const writeback = (options && options.writeback) || defaultWriteback;
+  transformer(parse(code, options), function (node: any) {
+    writeback(print(node, options).code);
+  });
+}
diff --git a/node_modules/recast/package-lock.json b/node_modules/recast/package-lock.json
new file mode 100644
index 0000000..f22f6f6
--- /dev/null
+++ b/node_modules/recast/package-lock.json
@@ -0,0 +1,9259 @@
+{
+  "name": "recast",
+  "version": "0.23.2",
+  "lockfileVersion": 2,
+  "requires": true,
+  "packages": {
+    "": {
+      "name": "recast",
+      "version": "0.23.2",
+      "license": "MIT",
+      "dependencies": {
+        "assert": "^2.0.0",
+        "ast-types": "^0.16.1",
+        "esprima": "~4.0.0",
+        "source-map": "~0.6.1",
+        "tslib": "^2.0.1"
+      },
+      "devDependencies": {
+        "@babel/core": "7.20.5",
+        "@babel/parser": "7.20.5",
+        "@babel/preset-env": "7.20.2",
+        "@types/babylon": "^6.16.6",
+        "@types/esprima": "4.0.3",
+        "@types/glob": "8.0.0",
+        "@types/mocha": "10.0.1",
+        "@types/node": "18.11.15",
+        "@typescript-eslint/parser": "^5.47.1",
+        "babylon": "^6.18.0",
+        "eslint": "^8.40.0",
+        "esprima-fb": "15001.1001.0-dev-harmony-fb",
+        "flow-parser": "0.195.0",
+        "glob": "8.0.3",
+        "lint-staged": "^13.2.2",
+        "mocha": "^10.2.0",
+        "prettier": "^2.6.2",
+        "reify": "0.20.12",
+        "typescript": "^4.9.4"
+      },
+      "engines": {
+        "node": ">= 4"
+      }
+    },
+    "node_modules/@ampproject/remapping": {
+      "version": "2.2.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.2.0.tgz",
+      "integrity": "sha512-qRmjj8nj9qmLTQXXmaR1cck3UXSRMPrbsLJAasZpF+t3riI71BXed5ebIOYwQntykeZuhjsdweEc9BxH5Jc26w==",
+      "dev": true,
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.1.0",
+        "@jridgewell/trace-mapping": "^0.3.9"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/code-frame": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.18.6.tgz",
+      "integrity": "sha512-TDCmlK5eOvH+eH7cdAFlNXeVJqWIQ7gW9tY1GJIpUtFb6CmjVyq2VM3u71bOyR8CRihcCgMUYoDNyLXao3+70Q==",
+      "dev": true,
+      "dependencies": {
+        "@babel/highlight": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/compat-data": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.20.5.tgz",
+      "integrity": "sha512-KZXo2t10+/jxmkhNXc7pZTqRvSOIvVv/+lJwHS+B2rErwOyjuVRh60yVpb7liQ1U5t7lLJ1bz+t8tSypUZdm0g==",
+      "dev": true,
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/core": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.20.5.tgz",
+      "integrity": "sha512-UdOWmk4pNWTm/4DlPUl/Pt4Gz4rcEMb7CY0Y3eJl5Yz1vI8ZJGmHWaVE55LoxRjdpx0z259GE9U5STA9atUinQ==",
+      "dev": true,
+      "dependencies": {
+        "@ampproject/remapping": "^2.1.0",
+        "@babel/code-frame": "^7.18.6",
+        "@babel/generator": "^7.20.5",
+        "@babel/helper-compilation-targets": "^7.20.0",
+        "@babel/helper-module-transforms": "^7.20.2",
+        "@babel/helpers": "^7.20.5",
+        "@babel/parser": "^7.20.5",
+        "@babel/template": "^7.18.10",
+        "@babel/traverse": "^7.20.5",
+        "@babel/types": "^7.20.5",
+        "convert-source-map": "^1.7.0",
+        "debug": "^4.1.0",
+        "gensync": "^1.0.0-beta.2",
+        "json5": "^2.2.1",
+        "semver": "^6.3.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/babel"
+      }
+    },
+    "node_modules/@babel/core/node_modules/semver": {
+      "version": "6.3.0",
+      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
+      "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
+      "dev": true,
+      "bin": {
+        "semver": "bin/semver.js"
+      }
+    },
+    "node_modules/@babel/generator": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.20.5.tgz",
+      "integrity": "sha512-jl7JY2Ykn9S0yj4DQP82sYvPU+T3g0HFcWTqDLqiuA9tGRNIj9VfbtXGAYTTkyNEnQk1jkMGOdYka8aG/lulCA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/types": "^7.20.5",
+        "@jridgewell/gen-mapping": "^0.3.2",
+        "jsesc": "^2.5.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/generator/node_modules/@jridgewell/gen-mapping": {
+      "version": "0.3.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.2.tgz",
+      "integrity": "sha512-mh65xKQAzI6iBcFzwv28KVWSmCkdRBWoOh+bYQGW3+6OZvbbN3TqMGo5hqYxQniRcH9F2VZIoJCm4pa3BPDK/A==",
+      "dev": true,
+      "dependencies": {
+        "@jridgewell/set-array": "^1.0.1",
+        "@jridgewell/sourcemap-codec": "^1.4.10",
+        "@jridgewell/trace-mapping": "^0.3.9"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/helper-annotate-as-pure": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-annotate-as-pure/-/helper-annotate-as-pure-7.18.6.tgz",
+      "integrity": "sha512-duORpUiYrEpzKIop6iNbjnwKLAKnJ47csTyRACyEmWj0QdUrm5aqNJGHSSEQSUAvNW0ojX0dOmK9dZduvkfeXA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/types": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-builder-binary-assignment-operator-visitor": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-builder-binary-assignment-operator-visitor/-/helper-builder-binary-assignment-operator-visitor-7.18.9.tgz",
+      "integrity": "sha512-yFQ0YCHoIqarl8BCRwBL8ulYUaZpz3bNsA7oFepAzee+8/+ImtADXNOmO5vJvsPff3qi+hvpkY/NYBTrBQgdNw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-explode-assignable-expression": "^7.18.6",
+        "@babel/types": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-compilation-targets": {
+      "version": "7.20.0",
+      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.20.0.tgz",
+      "integrity": "sha512-0jp//vDGp9e8hZzBc6N/KwA5ZK3Wsm/pfm4CrY7vzegkVxc65SgSn6wYOnwHe9Js9HRQ1YTCKLGPzDtaS3RoLQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/compat-data": "^7.20.0",
+        "@babel/helper-validator-option": "^7.18.6",
+        "browserslist": "^4.21.3",
+        "semver": "^6.3.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0"
+      }
+    },
+    "node_modules/@babel/helper-compilation-targets/node_modules/semver": {
+      "version": "6.3.0",
+      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
+      "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
+      "dev": true,
+      "bin": {
+        "semver": "bin/semver.js"
+      }
+    },
+    "node_modules/@babel/helper-create-class-features-plugin": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-create-class-features-plugin/-/helper-create-class-features-plugin-7.20.5.tgz",
+      "integrity": "sha512-3RCdA/EmEaikrhayahwToF0fpweU/8o2p8vhc1c/1kftHOdTKuC65kik/TLc+qfbS8JKw4qqJbne4ovICDhmww==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-annotate-as-pure": "^7.18.6",
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-function-name": "^7.19.0",
+        "@babel/helper-member-expression-to-functions": "^7.18.9",
+        "@babel/helper-optimise-call-expression": "^7.18.6",
+        "@babel/helper-replace-supers": "^7.19.1",
+        "@babel/helper-split-export-declaration": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0"
+      }
+    },
+    "node_modules/@babel/helper-create-regexp-features-plugin": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-create-regexp-features-plugin/-/helper-create-regexp-features-plugin-7.20.5.tgz",
+      "integrity": "sha512-m68B1lkg3XDGX5yCvGO0kPx3v9WIYLnzjKfPcQiwntEQa5ZeRkPmo2X/ISJc8qxWGfwUr+kvZAeEzAwLec2r2w==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-annotate-as-pure": "^7.18.6",
+        "regexpu-core": "^5.2.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0"
+      }
+    },
+    "node_modules/@babel/helper-define-polyfill-provider": {
+      "version": "0.3.3",
+      "resolved": "https://registry.npmjs.org/@babel/helper-define-polyfill-provider/-/helper-define-polyfill-provider-0.3.3.tgz",
+      "integrity": "sha512-z5aQKU4IzbqCC1XH0nAqfsFLMVSo22SBKUc0BxGrLkolTdPTructy0ToNnlO2zA4j9Q/7pjMZf0DSY+DSTYzww==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-compilation-targets": "^7.17.7",
+        "@babel/helper-plugin-utils": "^7.16.7",
+        "debug": "^4.1.1",
+        "lodash.debounce": "^4.0.8",
+        "resolve": "^1.14.2",
+        "semver": "^6.1.2"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.4.0-0"
+      }
+    },
+    "node_modules/@babel/helper-define-polyfill-provider/node_modules/semver": {
+      "version": "6.3.0",
+      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
+      "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
+      "dev": true,
+      "bin": {
+        "semver": "bin/semver.js"
+      }
+    },
+    "node_modules/@babel/helper-environment-visitor": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-environment-visitor/-/helper-environment-visitor-7.18.9.tgz",
+      "integrity": "sha512-3r/aACDJ3fhQ/EVgFy0hpj8oHyHpQc+LPtJoY9SzTThAsStm4Ptegq92vqKoE3vD706ZVFWITnMnxucw+S9Ipg==",
+      "dev": true,
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-explode-assignable-expression": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-explode-assignable-expression/-/helper-explode-assignable-expression-7.18.6.tgz",
+      "integrity": "sha512-eyAYAsQmB80jNfg4baAtLeWAQHfHFiR483rzFK+BhETlGZaQC9bsfrugfXDCbRHLQbIA7U5NxhhOxN7p/dWIcg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/types": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-function-name": {
+      "version": "7.19.0",
+      "resolved": "https://registry.npmjs.org/@babel/helper-function-name/-/helper-function-name-7.19.0.tgz",
+      "integrity": "sha512-WAwHBINyrpqywkUH0nTnNgI5ina5TFn85HKS0pbPDfxFfhyR/aNQEn4hGi1P1JyT//I0t4OgXUlofzWILRvS5w==",
+      "dev": true,
+      "dependencies": {
+        "@babel/template": "^7.18.10",
+        "@babel/types": "^7.19.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-hoist-variables": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-hoist-variables/-/helper-hoist-variables-7.18.6.tgz",
+      "integrity": "sha512-UlJQPkFqFULIcyW5sbzgbkxn2FKRgwWiRexcuaR8RNJRy8+LLveqPjwZV/bwrLZCN0eUHD/x8D0heK1ozuoo6Q==",
+      "dev": true,
+      "dependencies": {
+        "@babel/types": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-member-expression-to-functions": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-member-expression-to-functions/-/helper-member-expression-to-functions-7.18.9.tgz",
+      "integrity": "sha512-RxifAh2ZoVU67PyKIO4AMi1wTenGfMR/O/ae0CCRqwgBAt5v7xjdtRw7UoSbsreKrQn5t7r89eruK/9JjYHuDg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/types": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-module-imports": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.18.6.tgz",
+      "integrity": "sha512-0NFvs3VkuSYbFi1x2Vd6tKrywq+z/cLeYC/RJNFrIX/30Bf5aiGYbtvGXolEktzJH8o5E5KJ3tT+nkxuuZFVlA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/types": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-module-transforms": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.20.2.tgz",
+      "integrity": "sha512-zvBKyJXRbmK07XhMuujYoJ48B5yvvmM6+wcpv6Ivj4Yg6qO7NOZOSnvZN9CRl1zz1Z4cKf8YejmCMh8clOoOeA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-module-imports": "^7.18.6",
+        "@babel/helper-simple-access": "^7.20.2",
+        "@babel/helper-split-export-declaration": "^7.18.6",
+        "@babel/helper-validator-identifier": "^7.19.1",
+        "@babel/template": "^7.18.10",
+        "@babel/traverse": "^7.20.1",
+        "@babel/types": "^7.20.2"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-optimise-call-expression": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-optimise-call-expression/-/helper-optimise-call-expression-7.18.6.tgz",
+      "integrity": "sha512-HP59oD9/fEHQkdcbgFCnbmgH5vIQTJbxh2yf+CdM89/glUNnuzr87Q8GIjGEnOktTROemO0Pe0iPAYbqZuOUiA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/types": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-plugin-utils": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.20.2.tgz",
+      "integrity": "sha512-8RvlJG2mj4huQ4pZ+rU9lqKi9ZKiRmuvGuM2HlWmkmgOhbs6zEAw6IEiJ5cQqGbDzGZOhwuOQNtZMi/ENLjZoQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-remap-async-to-generator": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-remap-async-to-generator/-/helper-remap-async-to-generator-7.18.9.tgz",
+      "integrity": "sha512-dI7q50YKd8BAv3VEfgg7PS7yD3Rtbi2J1XMXaalXO0W0164hYLnh8zpjRS0mte9MfVp/tltvr/cfdXPvJr1opA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-annotate-as-pure": "^7.18.6",
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-wrap-function": "^7.18.9",
+        "@babel/types": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0"
+      }
+    },
+    "node_modules/@babel/helper-replace-supers": {
+      "version": "7.19.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-replace-supers/-/helper-replace-supers-7.19.1.tgz",
+      "integrity": "sha512-T7ahH7wV0Hfs46SFh5Jz3s0B6+o8g3c+7TMxu7xKfmHikg7EAZ3I2Qk9LFhjxXq8sL7UkP5JflezNwoZa8WvWw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-member-expression-to-functions": "^7.18.9",
+        "@babel/helper-optimise-call-expression": "^7.18.6",
+        "@babel/traverse": "^7.19.1",
+        "@babel/types": "^7.19.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-simple-access": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/helper-simple-access/-/helper-simple-access-7.20.2.tgz",
+      "integrity": "sha512-+0woI/WPq59IrqDYbVGfshjT5Dmk/nnbdpcF8SnMhhXObpTq2KNBdLFRFrkVdbDOyUmHBCxzm5FHV1rACIkIbA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/types": "^7.20.2"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-skip-transparent-expression-wrappers": {
+      "version": "7.20.0",
+      "resolved": "https://registry.npmjs.org/@babel/helper-skip-transparent-expression-wrappers/-/helper-skip-transparent-expression-wrappers-7.20.0.tgz",
+      "integrity": "sha512-5y1JYeNKfvnT8sZcK9DVRtpTbGiomYIHviSP3OQWmDPU3DeH4a1ZlT/N2lyQ5P8egjcRaT/Y9aNqUxK0WsnIIg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/types": "^7.20.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-split-export-declaration": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-split-export-declaration/-/helper-split-export-declaration-7.18.6.tgz",
+      "integrity": "sha512-bde1etTx6ZyTmobl9LLMMQsaizFVZrquTEHOqKeQESMKo4PlObf+8+JA25ZsIpZhT/WEd39+vOdLXAFG/nELpA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/types": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-string-parser": {
+      "version": "7.19.4",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.19.4.tgz",
+      "integrity": "sha512-nHtDoQcuqFmwYNYPz3Rah5ph2p8PFeFCsZk9A/48dPc/rGocJ5J3hAAZ7pb76VWX3fZKu+uEr/FhH5jLx7umrw==",
+      "dev": true,
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-identifier": {
+      "version": "7.19.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.19.1.tgz",
+      "integrity": "sha512-awrNfaMtnHUr653GgGEs++LlAvW6w+DcPrOliSMXWCKo597CwL5Acf/wWdNkf/tfEQE3mjkeD1YOVZOUV/od1w==",
+      "dev": true,
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-validator-option": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.18.6.tgz",
+      "integrity": "sha512-XO7gESt5ouv/LRJdrVjkShckw6STTaB7l9BrpBaAHDeF5YZT+01PCwmR0SJHnkW6i8OwW/EVWRShfi4j2x+KQw==",
+      "dev": true,
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helper-wrap-function": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-wrap-function/-/helper-wrap-function-7.20.5.tgz",
+      "integrity": "sha512-bYMxIWK5mh+TgXGVqAtnu5Yn1un+v8DDZtqyzKRLUzrh70Eal2O3aZ7aPYiMADO4uKlkzOiRiZ6GX5q3qxvW9Q==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-function-name": "^7.19.0",
+        "@babel/template": "^7.18.10",
+        "@babel/traverse": "^7.20.5",
+        "@babel/types": "^7.20.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/helpers": {
+      "version": "7.20.6",
+      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.20.6.tgz",
+      "integrity": "sha512-Pf/OjgfgFRW5bApskEz5pvidpim7tEDPlFtKcNRXWmfHGn9IEI2W2flqRQXTFb7gIPTyK++N6rVHuwKut4XK6w==",
+      "dev": true,
+      "dependencies": {
+        "@babel/template": "^7.18.10",
+        "@babel/traverse": "^7.20.5",
+        "@babel/types": "^7.20.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/highlight": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.18.6.tgz",
+      "integrity": "sha512-u7stbOuYjaPezCuLj29hNW1v64M2Md2qupEKP1fHc7WdOA3DgLh37suiSrZYY7haUB7iBeQZ9P1uiRF359do3g==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-validator-identifier": "^7.18.6",
+        "chalk": "^2.0.0",
+        "js-tokens": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/parser": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.20.5.tgz",
+      "integrity": "sha512-r27t/cy/m9uKLXQNWWebeCUHgnAZq0CpG1OwKRxzJMP1vpSU4bSIK2hq+/cp0bQxetkXx38n09rNu8jVkcK/zA==",
+      "dev": true,
+      "bin": {
+        "parser": "bin/babel-parser.js"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression/-/plugin-bugfix-safari-id-destructuring-collision-in-function-expression-7.18.6.tgz",
+      "integrity": "sha512-Dgxsyg54Fx1d4Nge8UnvTrED63vrwOdPmyvPzlNN/boaliRP54pm3pGzZD1SJUwrBA+Cs/xdG8kXX6Mn/RfISQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0"
+      }
+    },
+    "node_modules/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining/-/plugin-bugfix-v8-spread-parameters-in-optional-chaining-7.18.9.tgz",
+      "integrity": "sha512-AHrP9jadvH7qlOj6PINbgSuphjQUAK7AOT7DPjBo9EHoLhQTnnK5u45e1Hd4DbSQEO9nqPWtQ89r+XEOWFScKg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.9",
+        "@babel/helper-skip-transparent-expression-wrappers": "^7.18.9",
+        "@babel/plugin-proposal-optional-chaining": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.13.0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-async-generator-functions": {
+      "version": "7.20.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-async-generator-functions/-/plugin-proposal-async-generator-functions-7.20.1.tgz",
+      "integrity": "sha512-Gh5rchzSwE4kC+o/6T8waD0WHEQIsDmjltY8WnWRXHUdH8axZhuH86Ov9M72YhJfDrZseQwuuWaaIT/TmePp3g==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-plugin-utils": "^7.19.0",
+        "@babel/helper-remap-async-to-generator": "^7.18.9",
+        "@babel/plugin-syntax-async-generators": "^7.8.4"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-class-properties": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-class-properties/-/plugin-proposal-class-properties-7.18.6.tgz",
+      "integrity": "sha512-cumfXOF0+nzZrrN8Rf0t7M+tF6sZc7vhQwYQck9q1/5w2OExlD+b4v4RpMJFaV1Z7WcDRgO6FqvxqxGlwo+RHQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-create-class-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-class-static-block": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-class-static-block/-/plugin-proposal-class-static-block-7.18.6.tgz",
+      "integrity": "sha512-+I3oIiNxrCpup3Gi8n5IGMwj0gOCAjcJUSQEcotNnCCPMEnixawOQ+KeJPlgfjzx+FKQ1QSyZOWe7wmoJp7vhw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-create-class-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-class-static-block": "^7.14.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.12.0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-dynamic-import": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-dynamic-import/-/plugin-proposal-dynamic-import-7.18.6.tgz",
+      "integrity": "sha512-1auuwmK+Rz13SJj36R+jqFPMJWyKEDd7lLSdOj4oJK0UTgGueSAtkrCvz9ewmgyU/P941Rv2fQwZJN8s6QruXw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-dynamic-import": "^7.8.3"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-export-namespace-from": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-export-namespace-from/-/plugin-proposal-export-namespace-from-7.18.9.tgz",
+      "integrity": "sha512-k1NtHyOMvlDDFeb9G5PhUXuGj8m/wiwojgQVEhJ/fsVsMCpLyOP4h0uGEjYJKrRI+EVPlb5Jk+Gt9P97lOGwtA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.9",
+        "@babel/plugin-syntax-export-namespace-from": "^7.8.3"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-json-strings": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-json-strings/-/plugin-proposal-json-strings-7.18.6.tgz",
+      "integrity": "sha512-lr1peyn9kOdbYc0xr0OdHTZ5FMqS6Di+H0Fz2I/JwMzGmzJETNeOFq2pBySw6X/KFL5EWDjlJuMsUGRFb8fQgQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-json-strings": "^7.8.3"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-logical-assignment-operators": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-logical-assignment-operators/-/plugin-proposal-logical-assignment-operators-7.18.9.tgz",
+      "integrity": "sha512-128YbMpjCrP35IOExw2Fq+x55LMP42DzhOhX2aNNIdI9avSWl2PI0yuBWarr3RYpZBSPtabfadkH2yeRiMD61Q==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.9",
+        "@babel/plugin-syntax-logical-assignment-operators": "^7.10.4"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-nullish-coalescing-operator": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-nullish-coalescing-operator/-/plugin-proposal-nullish-coalescing-operator-7.18.6.tgz",
+      "integrity": "sha512-wQxQzxYeJqHcfppzBDnm1yAY0jSRkUXR2z8RePZYrKwMKgMlE8+Z6LUno+bd6LvbGh8Gltvy74+9pIYkr+XkKA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-numeric-separator": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-numeric-separator/-/plugin-proposal-numeric-separator-7.18.6.tgz",
+      "integrity": "sha512-ozlZFogPqoLm8WBr5Z8UckIoE4YQ5KESVcNudyXOR8uqIkliTEgJ3RoketfG6pmzLdeZF0H/wjE9/cCEitBl7Q==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-numeric-separator": "^7.10.4"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-object-rest-spread": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-object-rest-spread/-/plugin-proposal-object-rest-spread-7.20.2.tgz",
+      "integrity": "sha512-Ks6uej9WFK+fvIMesSqbAto5dD8Dz4VuuFvGJFKgIGSkJuRGcrwGECPA1fDgQK3/DbExBJpEkTeYeB8geIFCSQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/compat-data": "^7.20.1",
+        "@babel/helper-compilation-targets": "^7.20.0",
+        "@babel/helper-plugin-utils": "^7.20.2",
+        "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
+        "@babel/plugin-transform-parameters": "^7.20.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-optional-catch-binding": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-optional-catch-binding/-/plugin-proposal-optional-catch-binding-7.18.6.tgz",
+      "integrity": "sha512-Q40HEhs9DJQyaZfUjjn6vE8Cv4GmMHCYuMGIWUnlxH6400VGxOuwWsPt4FxXxJkC/5eOzgn0z21M9gMT4MOhbw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-optional-catch-binding": "^7.8.3"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-optional-chaining": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-optional-chaining/-/plugin-proposal-optional-chaining-7.18.9.tgz",
+      "integrity": "sha512-v5nwt4IqBXihxGsW2QmCWMDS3B3bzGIk/EQVZz2ei7f3NJl8NzAJVvUmpDW5q1CRNY+Beb/k58UAH1Km1N411w==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.9",
+        "@babel/helper-skip-transparent-expression-wrappers": "^7.18.9",
+        "@babel/plugin-syntax-optional-chaining": "^7.8.3"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-private-methods": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-private-methods/-/plugin-proposal-private-methods-7.18.6.tgz",
+      "integrity": "sha512-nutsvktDItsNn4rpGItSNV2sz1XwS+nfU0Rg8aCx3W3NOKVzdMjJRu0O5OkgDp3ZGICSTbgRpxZoWsxoKRvbeA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-create-class-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-private-property-in-object": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-private-property-in-object/-/plugin-proposal-private-property-in-object-7.20.5.tgz",
+      "integrity": "sha512-Vq7b9dUA12ByzB4EjQTPo25sFhY+08pQDBSZRtUAkj7lb7jahaHR5igera16QZ+3my1nYR4dKsNdYj5IjPHilQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-annotate-as-pure": "^7.18.6",
+        "@babel/helper-create-class-features-plugin": "^7.20.5",
+        "@babel/helper-plugin-utils": "^7.20.2",
+        "@babel/plugin-syntax-private-property-in-object": "^7.14.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-proposal-unicode-property-regex": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-unicode-property-regex/-/plugin-proposal-unicode-property-regex-7.18.6.tgz",
+      "integrity": "sha512-2BShG/d5yoZyXZfVePH91urL5wTG6ASZU9M4o03lKK8u8UW1y08OMttBSOADTcJrnPMpvDXRG3G8fyLh4ovs8w==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-create-regexp-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=4"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-async-generators": {
+      "version": "7.8.4",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-async-generators/-/plugin-syntax-async-generators-7.8.4.tgz",
+      "integrity": "sha512-tycmZxkGfZaxhMRbXlPXuVFpdWlXpir2W4AMhSJgRKzk/eDlIXOhb2LHWoLpDF7TEHylV5zNhykX6KAgHJmTNw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-class-properties": {
+      "version": "7.12.13",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-properties/-/plugin-syntax-class-properties-7.12.13.tgz",
+      "integrity": "sha512-fm4idjKla0YahUNgFNLCB0qySdsoPiZP3iQE3rky0mBUtMZ23yDJ9SJdg6dXTSDnulOVqiF3Hgr9nbXvXTQZYA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.12.13"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-class-static-block": {
+      "version": "7.14.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-static-block/-/plugin-syntax-class-static-block-7.14.5.tgz",
+      "integrity": "sha512-b+YyPmr6ldyNnM6sqYeMWE+bgJcJpO6yS4QD7ymxgH34GBPNDM/THBh8iunyvKIZztiwLH4CJZ0RxTk9emgpjw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.14.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-dynamic-import": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-dynamic-import/-/plugin-syntax-dynamic-import-7.8.3.tgz",
+      "integrity": "sha512-5gdGbFon+PszYzqs83S3E5mpi7/y/8M9eC90MRTZfduQOYW76ig6SOSPNe41IG5LoP3FGBn2N0RjVDSQiS94kQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-export-namespace-from": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-export-namespace-from/-/plugin-syntax-export-namespace-from-7.8.3.tgz",
+      "integrity": "sha512-MXf5laXo6c1IbEbegDmzGPwGNTsHZmEy6QGznu5Sh2UCWvueywb2ee+CCE4zQiZstxU9BMoQO9i6zUFSY0Kj0Q==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.8.3"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-import-assertions": {
+      "version": "7.20.0",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-assertions/-/plugin-syntax-import-assertions-7.20.0.tgz",
+      "integrity": "sha512-IUh1vakzNoWalR8ch/areW7qFopR2AEw03JlG7BbrDqmQ4X3q9uuipQwSGrUn7oGiemKjtSLDhNtQHzMHr1JdQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.19.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-json-strings": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-json-strings/-/plugin-syntax-json-strings-7.8.3.tgz",
+      "integrity": "sha512-lY6kdGpWHvjoe2vk4WrAapEuBR69EMxZl+RoGRhrFGNYVK8mOPAW8VfbT/ZgrFbXlDNiiaxQnAtgVCZ6jv30EA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-logical-assignment-operators": {
+      "version": "7.10.4",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-logical-assignment-operators/-/plugin-syntax-logical-assignment-operators-7.10.4.tgz",
+      "integrity": "sha512-d8waShlpFDinQ5MtvGU9xDAOzKH47+FFoney2baFIoMr952hKOLp1HR7VszoZvOsV/4+RRszNY7D17ba0te0ig==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.10.4"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-nullish-coalescing-operator": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-nullish-coalescing-operator/-/plugin-syntax-nullish-coalescing-operator-7.8.3.tgz",
+      "integrity": "sha512-aSff4zPII1u2QD7y+F8oDsz19ew4IGEJg9SVW+bqwpwtfFleiQDMdzA/R+UlWDzfnHFCxxleFT0PMIrR36XLNQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-numeric-separator": {
+      "version": "7.10.4",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-numeric-separator/-/plugin-syntax-numeric-separator-7.10.4.tgz",
+      "integrity": "sha512-9H6YdfkcK/uOnY/K7/aA2xpzaAgkQn37yzWUMRK7OaPOqOpGS1+n0H5hxT9AUw9EsSjPW8SVyMJwYRtWs3X3ug==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.10.4"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-object-rest-spread": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-object-rest-spread/-/plugin-syntax-object-rest-spread-7.8.3.tgz",
+      "integrity": "sha512-XoqMijGZb9y3y2XskN+P1wUGiVwWZ5JmoDRwx5+3GmEplNyVM2s2Dg8ILFQm8rWM48orGy5YpI5Bl8U1y7ydlA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-optional-catch-binding": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-catch-binding/-/plugin-syntax-optional-catch-binding-7.8.3.tgz",
+      "integrity": "sha512-6VPD0Pc1lpTqw0aKoeRTMiB+kWhAoT24PA+ksWSBrFtl5SIRVpZlwN3NNPQjehA2E/91FV3RjLWoVTglWcSV3Q==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-optional-chaining": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-chaining/-/plugin-syntax-optional-chaining-7.8.3.tgz",
+      "integrity": "sha512-KoK9ErH1MBlCPxV0VANkXW2/dw4vlbGDrFgz8bmUsBGYkFRcbRwMh6cIJubdPrkxRwuGdtCk0v/wPTKbQgBjkg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-syntax-private-property-in-object": {
+      "version": "7.14.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-private-property-in-object/-/plugin-syntax-private-property-in-object-7.14.5.tgz",
+      "integrity": "sha512-0wVnp9dxJ72ZUJDV27ZfbSj6iHLoytYZmh3rFcxNnvsJF3ktkzLDZPy/mA17HGsaQT3/DQsWYX1f1QGWkCoVUg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.14.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-arrow-functions": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-arrow-functions/-/plugin-transform-arrow-functions-7.18.6.tgz",
+      "integrity": "sha512-9S9X9RUefzrsHZmKMbDXxweEH+YlE8JJEuat9FdvW9Qh1cw7W64jELCtWNkPBPX5En45uy28KGvA/AySqUh8CQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-async-to-generator": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-to-generator/-/plugin-transform-async-to-generator-7.18.6.tgz",
+      "integrity": "sha512-ARE5wZLKnTgPW7/1ftQmSi1CmkqqHo2DNmtztFhvgtOWSDfq0Cq9/9L+KnZNYSNrydBekhW3rwShduf59RoXag==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-module-imports": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/helper-remap-async-to-generator": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-block-scoped-functions": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoped-functions/-/plugin-transform-block-scoped-functions-7.18.6.tgz",
+      "integrity": "sha512-ExUcOqpPWnliRcPqves5HJcJOvHvIIWfuS4sroBUenPuMdmW+SMHDakmtS7qOo13sVppmUijqeTv7qqGsvURpQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-block-scoping": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoping/-/plugin-transform-block-scoping-7.20.5.tgz",
+      "integrity": "sha512-WvpEIW9Cbj9ApF3yJCjIEEf1EiNJLtXagOrL5LNWEZOo3jv8pmPoYTSNJQvqej8OavVlgOoOPw6/htGZro6IkA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.20.2"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-classes": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-classes/-/plugin-transform-classes-7.20.2.tgz",
+      "integrity": "sha512-9rbPp0lCVVoagvtEyQKSo5L8oo0nQS/iif+lwlAz29MccX2642vWDlSZK+2T2buxbopotId2ld7zZAzRfz9j1g==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-annotate-as-pure": "^7.18.6",
+        "@babel/helper-compilation-targets": "^7.20.0",
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-function-name": "^7.19.0",
+        "@babel/helper-optimise-call-expression": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.20.2",
+        "@babel/helper-replace-supers": "^7.19.1",
+        "@babel/helper-split-export-declaration": "^7.18.6",
+        "globals": "^11.1.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-computed-properties": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-computed-properties/-/plugin-transform-computed-properties-7.18.9.tgz",
+      "integrity": "sha512-+i0ZU1bCDymKakLxn5srGHrsAPRELC2WIbzwjLhHW9SIE1cPYkLCL0NlnXMZaM1vhfgA2+M7hySk42VBvrkBRw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-destructuring": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-destructuring/-/plugin-transform-destructuring-7.20.2.tgz",
+      "integrity": "sha512-mENM+ZHrvEgxLTBXUiQ621rRXZes3KWUv6NdQlrnr1TkWVw+hUjQBZuP2X32qKlrlG2BzgR95gkuCRSkJl8vIw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.20.2"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-dotall-regex": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dotall-regex/-/plugin-transform-dotall-regex-7.18.6.tgz",
+      "integrity": "sha512-6S3jpun1eEbAxq7TdjLotAsl4WpQI9DxfkycRcKrjhQYzU87qpXdknpBg/e+TdcMehqGnLFi7tnFUBR02Vq6wg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-create-regexp-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-duplicate-keys": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-keys/-/plugin-transform-duplicate-keys-7.18.9.tgz",
+      "integrity": "sha512-d2bmXCtZXYc59/0SanQKbiWINadaJXqtvIQIzd4+hNwkWBgyCd5F/2t1kXoUdvPMrxzPvhK6EMQRROxsue+mfw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-exponentiation-operator": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-exponentiation-operator/-/plugin-transform-exponentiation-operator-7.18.6.tgz",
+      "integrity": "sha512-wzEtc0+2c88FVR34aQmiz56dxEkxr2g8DQb/KfaFa1JYXOFVsbhvAonFN6PwVWj++fKmku8NP80plJ5Et4wqHw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-builder-binary-assignment-operator-visitor": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-for-of": {
+      "version": "7.18.8",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-for-of/-/plugin-transform-for-of-7.18.8.tgz",
+      "integrity": "sha512-yEfTRnjuskWYo0k1mHUqrVWaZwrdq8AYbfrpqULOJOaucGSp4mNMVps+YtA8byoevxS/urwU75vyhQIxcCgiBQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-function-name": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-function-name/-/plugin-transform-function-name-7.18.9.tgz",
+      "integrity": "sha512-WvIBoRPaJQ5yVHzcnJFor7oS5Ls0PYixlTYE63lCj2RtdQEl15M68FXQlxnG6wdraJIXRdR7KI+hQ7q/9QjrCQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-compilation-targets": "^7.18.9",
+        "@babel/helper-function-name": "^7.18.9",
+        "@babel/helper-plugin-utils": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-literals": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-literals/-/plugin-transform-literals-7.18.9.tgz",
+      "integrity": "sha512-IFQDSRoTPnrAIrI5zoZv73IFeZu2dhu6irxQjY9rNjTT53VmKg9fenjvoiOWOkJ6mm4jKVPtdMzBY98Fp4Z4cg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-member-expression-literals": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-member-expression-literals/-/plugin-transform-member-expression-literals-7.18.6.tgz",
+      "integrity": "sha512-qSF1ihLGO3q+/g48k85tUjD033C29TNTVB2paCwZPVmOsjn9pClvYYrM2VeJpBY2bcNkuny0YUyTNRyRxJ54KA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-modules-amd": {
+      "version": "7.19.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-amd/-/plugin-transform-modules-amd-7.19.6.tgz",
+      "integrity": "sha512-uG3od2mXvAtIFQIh0xrpLH6r5fpSQN04gIVovl+ODLdUMANokxQLZnPBHcjmv3GxRjnqwLuHvppjjcelqUFZvg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-module-transforms": "^7.19.6",
+        "@babel/helper-plugin-utils": "^7.19.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-modules-commonjs": {
+      "version": "7.19.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-commonjs/-/plugin-transform-modules-commonjs-7.19.6.tgz",
+      "integrity": "sha512-8PIa1ym4XRTKuSsOUXqDG0YaOlEuTVvHMe5JCfgBMOtHvJKw/4NGovEGN33viISshG/rZNVrACiBmPQLvWN8xQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-module-transforms": "^7.19.6",
+        "@babel/helper-plugin-utils": "^7.19.0",
+        "@babel/helper-simple-access": "^7.19.4"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-modules-systemjs": {
+      "version": "7.19.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-systemjs/-/plugin-transform-modules-systemjs-7.19.6.tgz",
+      "integrity": "sha512-fqGLBepcc3kErfR9R3DnVpURmckXP7gj7bAlrTQyBxrigFqszZCkFkcoxzCp2v32XmwXLvbw+8Yq9/b+QqksjQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-hoist-variables": "^7.18.6",
+        "@babel/helper-module-transforms": "^7.19.6",
+        "@babel/helper-plugin-utils": "^7.19.0",
+        "@babel/helper-validator-identifier": "^7.19.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-modules-umd": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-umd/-/plugin-transform-modules-umd-7.18.6.tgz",
+      "integrity": "sha512-dcegErExVeXcRqNtkRU/z8WlBLnvD4MRnHgNs3MytRO1Mn1sHRyhbcpYbVMGclAqOjdW+9cfkdZno9dFdfKLfQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-module-transforms": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-named-capturing-groups-regex": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-named-capturing-groups-regex/-/plugin-transform-named-capturing-groups-regex-7.20.5.tgz",
+      "integrity": "sha512-mOW4tTzi5iTLnw+78iEq3gr8Aoq4WNRGpmSlrogqaiCBoR1HFhpU4JkpQFOHfeYx3ReVIFWOQJS4aZBRvuZ6mA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-create-regexp-features-plugin": "^7.20.5",
+        "@babel/helper-plugin-utils": "^7.20.2"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-new-target": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-new-target/-/plugin-transform-new-target-7.18.6.tgz",
+      "integrity": "sha512-DjwFA/9Iu3Z+vrAn+8pBUGcjhxKguSMlsFqeCKbhb9BAV756v0krzVK04CRDi/4aqmk8BsHb4a/gFcaA5joXRw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-object-super": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-super/-/plugin-transform-object-super-7.18.6.tgz",
+      "integrity": "sha512-uvGz6zk+pZoS1aTZrOvrbj6Pp/kK2mp45t2B+bTDre2UgsZZ8EZLSJtUg7m/no0zOJUWgFONpB7Zv9W2tSaFlA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/helper-replace-supers": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-parameters": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-parameters/-/plugin-transform-parameters-7.20.5.tgz",
+      "integrity": "sha512-h7plkOmcndIUWXZFLgpbrh2+fXAi47zcUX7IrOQuZdLD0I0KvjJ6cvo3BEcAOsDOcZhVKGJqv07mkSqK0y2isQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.20.2"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-property-literals": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-property-literals/-/plugin-transform-property-literals-7.18.6.tgz",
+      "integrity": "sha512-cYcs6qlgafTud3PAzrrRNbQtfpQ8+y/+M5tKmksS9+M1ckbH6kzY8MrexEM9mcA6JDsukE19iIRvAyYl463sMg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-regenerator": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-regenerator/-/plugin-transform-regenerator-7.20.5.tgz",
+      "integrity": "sha512-kW/oO7HPBtntbsahzQ0qSE3tFvkFwnbozz3NWFhLGqH75vLEg+sCGngLlhVkePlCs3Jv0dBBHDzCHxNiFAQKCQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.20.2",
+        "regenerator-transform": "^0.15.1"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-reserved-words": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-reserved-words/-/plugin-transform-reserved-words-7.18.6.tgz",
+      "integrity": "sha512-oX/4MyMoypzHjFrT1CdivfKZ+XvIPMFXwwxHp/r0Ddy2Vuomt4HDFGmft1TAY2yiTKiNSsh3kjBAzcM8kSdsjA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-shorthand-properties": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-shorthand-properties/-/plugin-transform-shorthand-properties-7.18.6.tgz",
+      "integrity": "sha512-eCLXXJqv8okzg86ywZJbRn19YJHU4XUa55oz2wbHhaQVn/MM+XhukiT7SYqp/7o00dg52Rj51Ny+Ecw4oyoygw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-spread": {
+      "version": "7.19.0",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-spread/-/plugin-transform-spread-7.19.0.tgz",
+      "integrity": "sha512-RsuMk7j6n+r752EtzyScnWkQyuJdli6LdO5Klv8Yx0OfPVTcQkIUfS8clx5e9yHXzlnhOZF3CbQ8C2uP5j074w==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.19.0",
+        "@babel/helper-skip-transparent-expression-wrappers": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-sticky-regex": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-sticky-regex/-/plugin-transform-sticky-regex-7.18.6.tgz",
+      "integrity": "sha512-kfiDrDQ+PBsQDO85yj1icueWMfGfJFKN1KCkndygtu/C9+XUfydLC8Iv5UYJqRwy4zk8EcplRxEOeLyjq1gm6Q==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-template-literals": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-template-literals/-/plugin-transform-template-literals-7.18.9.tgz",
+      "integrity": "sha512-S8cOWfT82gTezpYOiVaGHrCbhlHgKhQt8XH5ES46P2XWmX92yisoZywf5km75wv5sYcXDUCLMmMxOLCtthDgMA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-typeof-symbol": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-typeof-symbol/-/plugin-transform-typeof-symbol-7.18.9.tgz",
+      "integrity": "sha512-SRfwTtF11G2aemAZWivL7PD+C9z52v9EvMqH9BuYbabyPuKUvSWks3oCg6041pT925L4zVFqaVBeECwsmlguEw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-unicode-escapes": {
+      "version": "7.18.10",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-escapes/-/plugin-transform-unicode-escapes-7.18.10.tgz",
+      "integrity": "sha512-kKAdAI+YzPgGY/ftStBFXTI1LZFju38rYThnfMykS+IXy8BVx+res7s2fxf1l8I35DV2T97ezo6+SGrXz6B3iQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/plugin-transform-unicode-regex": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-regex/-/plugin-transform-unicode-regex-7.18.6.tgz",
+      "integrity": "sha512-gE7A6Lt7YLnNOL3Pb9BNeZvi+d8l7tcRrG4+pwJjK9hD2xX4mEvjlQW60G9EEmfXVYRPv9VRQcyegIVHCql/AA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-create-regexp-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/preset-env": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/preset-env/-/preset-env-7.20.2.tgz",
+      "integrity": "sha512-1G0efQEWR1EHkKvKHqbG+IN/QdgwfByUpM5V5QroDzGV2t3S/WXNQd693cHiHTlCFMpr9B6FkPFXDA2lQcKoDg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/compat-data": "^7.20.1",
+        "@babel/helper-compilation-targets": "^7.20.0",
+        "@babel/helper-plugin-utils": "^7.20.2",
+        "@babel/helper-validator-option": "^7.18.6",
+        "@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": "^7.18.6",
+        "@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": "^7.18.9",
+        "@babel/plugin-proposal-async-generator-functions": "^7.20.1",
+        "@babel/plugin-proposal-class-properties": "^7.18.6",
+        "@babel/plugin-proposal-class-static-block": "^7.18.6",
+        "@babel/plugin-proposal-dynamic-import": "^7.18.6",
+        "@babel/plugin-proposal-export-namespace-from": "^7.18.9",
+        "@babel/plugin-proposal-json-strings": "^7.18.6",
+        "@babel/plugin-proposal-logical-assignment-operators": "^7.18.9",
+        "@babel/plugin-proposal-nullish-coalescing-operator": "^7.18.6",
+        "@babel/plugin-proposal-numeric-separator": "^7.18.6",
+        "@babel/plugin-proposal-object-rest-spread": "^7.20.2",
+        "@babel/plugin-proposal-optional-catch-binding": "^7.18.6",
+        "@babel/plugin-proposal-optional-chaining": "^7.18.9",
+        "@babel/plugin-proposal-private-methods": "^7.18.6",
+        "@babel/plugin-proposal-private-property-in-object": "^7.18.6",
+        "@babel/plugin-proposal-unicode-property-regex": "^7.18.6",
+        "@babel/plugin-syntax-async-generators": "^7.8.4",
+        "@babel/plugin-syntax-class-properties": "^7.12.13",
+        "@babel/plugin-syntax-class-static-block": "^7.14.5",
+        "@babel/plugin-syntax-dynamic-import": "^7.8.3",
+        "@babel/plugin-syntax-export-namespace-from": "^7.8.3",
+        "@babel/plugin-syntax-import-assertions": "^7.20.0",
+        "@babel/plugin-syntax-json-strings": "^7.8.3",
+        "@babel/plugin-syntax-logical-assignment-operators": "^7.10.4",
+        "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3",
+        "@babel/plugin-syntax-numeric-separator": "^7.10.4",
+        "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
+        "@babel/plugin-syntax-optional-catch-binding": "^7.8.3",
+        "@babel/plugin-syntax-optional-chaining": "^7.8.3",
+        "@babel/plugin-syntax-private-property-in-object": "^7.14.5",
+        "@babel/plugin-syntax-top-level-await": "^7.14.5",
+        "@babel/plugin-transform-arrow-functions": "^7.18.6",
+        "@babel/plugin-transform-async-to-generator": "^7.18.6",
+        "@babel/plugin-transform-block-scoped-functions": "^7.18.6",
+        "@babel/plugin-transform-block-scoping": "^7.20.2",
+        "@babel/plugin-transform-classes": "^7.20.2",
+        "@babel/plugin-transform-computed-properties": "^7.18.9",
+        "@babel/plugin-transform-destructuring": "^7.20.2",
+        "@babel/plugin-transform-dotall-regex": "^7.18.6",
+        "@babel/plugin-transform-duplicate-keys": "^7.18.9",
+        "@babel/plugin-transform-exponentiation-operator": "^7.18.6",
+        "@babel/plugin-transform-for-of": "^7.18.8",
+        "@babel/plugin-transform-function-name": "^7.18.9",
+        "@babel/plugin-transform-literals": "^7.18.9",
+        "@babel/plugin-transform-member-expression-literals": "^7.18.6",
+        "@babel/plugin-transform-modules-amd": "^7.19.6",
+        "@babel/plugin-transform-modules-commonjs": "^7.19.6",
+        "@babel/plugin-transform-modules-systemjs": "^7.19.6",
+        "@babel/plugin-transform-modules-umd": "^7.18.6",
+        "@babel/plugin-transform-named-capturing-groups-regex": "^7.19.1",
+        "@babel/plugin-transform-new-target": "^7.18.6",
+        "@babel/plugin-transform-object-super": "^7.18.6",
+        "@babel/plugin-transform-parameters": "^7.20.1",
+        "@babel/plugin-transform-property-literals": "^7.18.6",
+        "@babel/plugin-transform-regenerator": "^7.18.6",
+        "@babel/plugin-transform-reserved-words": "^7.18.6",
+        "@babel/plugin-transform-shorthand-properties": "^7.18.6",
+        "@babel/plugin-transform-spread": "^7.19.0",
+        "@babel/plugin-transform-sticky-regex": "^7.18.6",
+        "@babel/plugin-transform-template-literals": "^7.18.9",
+        "@babel/plugin-transform-typeof-symbol": "^7.18.9",
+        "@babel/plugin-transform-unicode-escapes": "^7.18.10",
+        "@babel/plugin-transform-unicode-regex": "^7.18.6",
+        "@babel/preset-modules": "^0.1.5",
+        "@babel/types": "^7.20.2",
+        "babel-plugin-polyfill-corejs2": "^0.3.3",
+        "babel-plugin-polyfill-corejs3": "^0.6.0",
+        "babel-plugin-polyfill-regenerator": "^0.4.1",
+        "core-js-compat": "^3.25.1",
+        "semver": "^6.3.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/preset-env/node_modules/@babel/plugin-syntax-top-level-await": {
+      "version": "7.14.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-top-level-await/-/plugin-syntax-top-level-await-7.14.5.tgz",
+      "integrity": "sha512-hx++upLv5U1rgYfwe1xBQUhRmU41NEvpUvrp8jkrSCdvGSnM5/qdRMtylJ6PG5OFkBaHkbTAKTnd3/YyESRHFw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.14.5"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/preset-env/node_modules/@babel/preset-modules": {
+      "version": "0.1.5",
+      "resolved": "https://registry.npmjs.org/@babel/preset-modules/-/preset-modules-0.1.5.tgz",
+      "integrity": "sha512-A57th6YRG7oR3cq/yt/Y84MvGgE0eJG2F1JLhKuyG+jFxEgrd/HAMJatiFtmOiZurz+0DkrvbheCLaV5f2JfjA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-plugin-utils": "^7.0.0",
+        "@babel/plugin-proposal-unicode-property-regex": "^7.4.4",
+        "@babel/plugin-transform-dotall-regex": "^7.4.4",
+        "@babel/types": "^7.4.4",
+        "esutils": "^2.0.2"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/@babel/preset-env/node_modules/semver": {
+      "version": "6.3.0",
+      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
+      "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
+      "dev": true,
+      "bin": {
+        "semver": "bin/semver.js"
+      }
+    },
+    "node_modules/@babel/runtime": {
+      "version": "7.20.6",
+      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.20.6.tgz",
+      "integrity": "sha512-Q+8MqP7TiHMWzSfwiJwXCjyf4GYA4Dgw3emg/7xmwsdLJOZUp+nMqcOwOzzYheuM1rhDu8FSj2l0aoMygEuXuA==",
+      "dev": true,
+      "dependencies": {
+        "regenerator-runtime": "^0.13.11"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/template": {
+      "version": "7.18.10",
+      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.18.10.tgz",
+      "integrity": "sha512-TI+rCtooWHr3QJ27kJxfjutghu44DLnasDMwpDqCXVTal9RLp3RSYNh4NdBrRP2cQAoG9A8juOQl6P6oZG4JxA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/code-frame": "^7.18.6",
+        "@babel/parser": "^7.18.10",
+        "@babel/types": "^7.18.10"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/traverse": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.20.5.tgz",
+      "integrity": "sha512-WM5ZNN3JITQIq9tFZaw1ojLU3WgWdtkxnhM1AegMS+PvHjkM5IXjmYEGY7yukz5XS4sJyEf2VzWjI8uAavhxBQ==",
+      "dev": true,
+      "dependencies": {
+        "@babel/code-frame": "^7.18.6",
+        "@babel/generator": "^7.20.5",
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-function-name": "^7.19.0",
+        "@babel/helper-hoist-variables": "^7.18.6",
+        "@babel/helper-split-export-declaration": "^7.18.6",
+        "@babel/parser": "^7.20.5",
+        "@babel/types": "^7.20.5",
+        "debug": "^4.1.0",
+        "globals": "^11.1.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@babel/types": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.20.5.tgz",
+      "integrity": "sha512-c9fst/h2/dcF7H+MJKZ2T0KjEQ8hY/BNnDk/H3XY8C4Aw/eWQXWn/lWntHF9ooUBnGmEvbfGrTgLWc+um0YDUg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-string-parser": "^7.19.4",
+        "@babel/helper-validator-identifier": "^7.19.1",
+        "to-fast-properties": "^2.0.0"
+      },
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/@eslint-community/eslint-utils": {
+      "version": "4.4.0",
+      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.4.0.tgz",
+      "integrity": "sha512-1/sA4dwrzBAyeUoQ6oxahHKmrZvsnLCg4RfxW3ZFGGmQkSNQPFNLV9CUEFQP1x9EYXHTo5p6xdhZM1Ne9p/AfA==",
+      "dev": true,
+      "dependencies": {
+        "eslint-visitor-keys": "^3.3.0"
+      },
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "peerDependencies": {
+        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
+      }
+    },
+    "node_modules/@eslint-community/regexpp": {
+      "version": "4.5.1",
+      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.5.1.tgz",
+      "integrity": "sha512-Z5ba73P98O1KUYCCJTUeVpja9RcGoMdncZ6T49FCUl2lN38JtCJ+3WgIDBv0AuY4WChU5PmtJmOCTlN6FZTFKQ==",
+      "dev": true,
+      "engines": {
+        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
+      }
+    },
+    "node_modules/@eslint/eslintrc": {
+      "version": "2.0.3",
+      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-2.0.3.tgz",
+      "integrity": "sha512-+5gy6OQfk+xx3q0d6jGZZC3f3KzAkXc/IanVxd1is/VIIziRqqt3ongQz0FiTUXqTk0c7aDB3OaFuKnuSoJicQ==",
+      "dev": true,
+      "dependencies": {
+        "ajv": "^6.12.4",
+        "debug": "^4.3.2",
+        "espree": "^9.5.2",
+        "globals": "^13.19.0",
+        "ignore": "^5.2.0",
+        "import-fresh": "^3.2.1",
+        "js-yaml": "^4.1.0",
+        "minimatch": "^3.1.2",
+        "strip-json-comments": "^3.1.1"
+      },
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint"
+      }
+    },
+    "node_modules/@eslint/eslintrc/node_modules/globals": {
+      "version": "13.20.0",
+      "resolved": "https://registry.npmjs.org/globals/-/globals-13.20.0.tgz",
+      "integrity": "sha512-Qg5QtVkCy/kv3FUSlu4ukeZDVf9ee0iXLAUYX13gbR17bnejFTzr4iS9bY7kwCf1NztRNm1t91fjOiyx4CSwPQ==",
+      "dev": true,
+      "dependencies": {
+        "type-fest": "^0.20.2"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/@eslint/js": {
+      "version": "8.40.0",
+      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-8.40.0.tgz",
+      "integrity": "sha512-ElyB54bJIhXQYVKjDSvCkPO1iU1tSAeVQJbllWJq1XQSmmA4dgFk8CbiBGpiOPxleE48vDogxCtmMYku4HSVLA==",
+      "dev": true,
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      }
+    },
+    "node_modules/@humanwhocodes/config-array": {
+      "version": "0.11.8",
+      "resolved": "https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.11.8.tgz",
+      "integrity": "sha512-UybHIJzJnR5Qc/MsD9Kr+RpO2h+/P1GhOwdiLPXK5TWk5sgTdu88bTD9UP+CKbPPh5Rni1u0GjAdYQLemG8g+g==",
+      "dev": true,
+      "dependencies": {
+        "@humanwhocodes/object-schema": "^1.2.1",
+        "debug": "^4.1.1",
+        "minimatch": "^3.0.5"
+      },
+      "engines": {
+        "node": ">=10.10.0"
+      }
+    },
+    "node_modules/@humanwhocodes/module-importer": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
+      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
+      "dev": true,
+      "engines": {
+        "node": ">=12.22"
+      },
+      "funding": {
+        "type": "github",
+        "url": "https://github.com/sponsors/nzakas"
+      }
+    },
+    "node_modules/@humanwhocodes/object-schema": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.1.tgz",
+      "integrity": "sha512-ZnQMnLV4e7hDlUvw8H+U8ASL02SS2Gn6+9Ac3wGGLIe7+je2AeAOxPY+izIPJDfFDb7eDjev0Us8MO1iFRN8hA==",
+      "dev": true
+    },
+    "node_modules/@jridgewell/gen-mapping": {
+      "version": "0.1.1",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.1.1.tgz",
+      "integrity": "sha512-sQXCasFk+U8lWYEe66WxRDOE9PjVz4vSM51fTu3Hw+ClTpUSQb718772vH3pyS5pShp6lvQM7SxgIDXXXmOX7w==",
+      "dev": true,
+      "dependencies": {
+        "@jridgewell/set-array": "^1.0.0",
+        "@jridgewell/sourcemap-codec": "^1.4.10"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@jridgewell/resolve-uri": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.0.tgz",
+      "integrity": "sha512-F2msla3tad+Mfht5cJq7LSXcdudKTWCVYUgw6pLFOOHSTtZlj6SWNYAp+AhuqLmWdBO2X5hPrLcu8cVP8fy28w==",
+      "dev": true,
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@jridgewell/set-array": {
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/set-array/-/set-array-1.1.2.tgz",
+      "integrity": "sha512-xnkseuNADM0gt2bs+BvhO0p78Mk762YnZdsuzFV018NoG1Sj1SCQvpSqa7XUaTam5vAGasABV9qXASMKnFMwMw==",
+      "dev": true,
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/@jridgewell/sourcemap-codec": {
+      "version": "1.4.14",
+      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.4.14.tgz",
+      "integrity": "sha512-XPSJHWmi394fuUuzDnGz1wiKqWfo1yXecHQMRf2l6hztTO+nPru658AyDngaBe7isIxEkRsPR3FZh+s7iVa4Uw==",
+      "dev": true
+    },
+    "node_modules/@jridgewell/trace-mapping": {
+      "version": "0.3.17",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.17.tgz",
+      "integrity": "sha512-MCNzAp77qzKca9+W/+I0+sEpaUnZoeasnghNeVc41VZCEKaCH73Vq3BZZ/SzWIgrqE4H4ceI+p+b6C0mHf9T4g==",
+      "dev": true,
+      "dependencies": {
+        "@jridgewell/resolve-uri": "3.1.0",
+        "@jridgewell/sourcemap-codec": "1.4.14"
+      }
+    },
+    "node_modules/@nodelib/fs.scandir": {
+      "version": "2.1.5",
+      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
+      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
+      "dev": true,
+      "dependencies": {
+        "@nodelib/fs.stat": "2.0.5",
+        "run-parallel": "^1.1.9"
+      },
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/@nodelib/fs.stat": {
+      "version": "2.0.5",
+      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
+      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
+      "dev": true,
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/@nodelib/fs.walk": {
+      "version": "1.2.8",
+      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
+      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
+      "dev": true,
+      "dependencies": {
+        "@nodelib/fs.scandir": "2.1.5",
+        "fastq": "^1.6.0"
+      },
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/@types/babel-types": {
+      "version": "7.0.11",
+      "resolved": "https://registry.npmjs.org/@types/babel-types/-/babel-types-7.0.11.tgz",
+      "integrity": "sha512-pkPtJUUY+Vwv6B1inAz55rQvivClHJxc9aVEPPmaq2cbyeMLCiDpbKpcKyX4LAwpNGi+SHBv0tHv6+0gXv0P2A==",
+      "dev": true
+    },
+    "node_modules/@types/babylon": {
+      "version": "6.16.6",
+      "resolved": "https://registry.npmjs.org/@types/babylon/-/babylon-6.16.6.tgz",
+      "integrity": "sha512-G4yqdVlhr6YhzLXFKy5F7HtRBU8Y23+iWy7UKthMq/OSQnL1hbsoeXESQ2LY8zEDlknipDG3nRGhUC9tkwvy/w==",
+      "dev": true,
+      "dependencies": {
+        "@types/babel-types": "*"
+      }
+    },
+    "node_modules/@types/esprima": {
+      "version": "4.0.3",
+      "resolved": "https://registry.npmjs.org/@types/esprima/-/esprima-4.0.3.tgz",
+      "integrity": "sha512-jo14dIWVVtF0iMsKkYek6++4cWJjwpvog+rchLulwgFJGTXqIeTdCOvY0B3yMLTaIwMcKCdJ6mQbSR6wYHy98A==",
+      "dev": true,
+      "dependencies": {
+        "@types/estree": "*"
+      }
+    },
+    "node_modules/@types/estree": {
+      "version": "0.0.45",
+      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-0.0.45.tgz",
+      "integrity": "sha512-jnqIUKDUqJbDIUxm0Uj7bnlMnRm1T/eZ9N+AVMqhPgzrba2GhGG5o/jCTwmdPK709nEZsGoMzXEDUjcXHa3W0g==",
+      "dev": true
+    },
+    "node_modules/@types/glob": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/@types/glob/-/glob-8.0.0.tgz",
+      "integrity": "sha512-l6NQsDDyQUVeoTynNpC9uRvCUint/gSUXQA2euwmTuWGvPY5LSDUu6tkCtJB2SvGQlJQzLaKqcGZP4//7EDveA==",
+      "dev": true,
+      "dependencies": {
+        "@types/minimatch": "*",
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/minimatch": {
+      "version": "3.0.3",
+      "resolved": "https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz",
+      "integrity": "sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA==",
+      "dev": true
+    },
+    "node_modules/@types/mocha": {
+      "version": "10.0.1",
+      "resolved": "https://registry.npmjs.org/@types/mocha/-/mocha-10.0.1.tgz",
+      "integrity": "sha512-/fvYntiO1GeICvqbQ3doGDIP97vWmvFt83GKguJ6prmQM2iXZfFcq6YE8KteFyRtX2/h5Hf91BYvPodJKFYv5Q==",
+      "dev": true
+    },
+    "node_modules/@types/node": {
+      "version": "18.11.15",
+      "resolved": "https://registry.npmjs.org/@types/node/-/node-18.11.15.tgz",
+      "integrity": "sha512-VkhBbVo2+2oozlkdHXLrb3zjsRkpdnaU2bXmX8Wgle3PUi569eLRaHGlgETQHR7lLL1w7GiG3h9SnePhxNDecw==",
+      "dev": true
+    },
+    "node_modules/@typescript-eslint/parser": {
+      "version": "5.47.1",
+      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-5.47.1.tgz",
+      "integrity": "sha512-9Vb+KIv29r6GPu4EboWOnQM7T+UjpjXvjCPhNORlgm40a9Ia9bvaPJswvtae1gip2QEeVeGh6YquqAzEgoRAlw==",
+      "dev": true,
+      "dependencies": {
+        "@typescript-eslint/scope-manager": "5.47.1",
+        "@typescript-eslint/types": "5.47.1",
+        "@typescript-eslint/typescript-estree": "5.47.1",
+        "debug": "^4.3.4"
+      },
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/typescript-eslint"
+      },
+      "peerDependencies": {
+        "eslint": "^6.0.0 || ^7.0.0 || ^8.0.0"
+      },
+      "peerDependenciesMeta": {
+        "typescript": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/@typescript-eslint/scope-manager": {
+      "version": "5.47.1",
+      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-5.47.1.tgz",
+      "integrity": "sha512-9hsFDsgUwrdOoW1D97Ewog7DYSHaq4WKuNs0LHF9RiCmqB0Z+XRR4Pf7u7u9z/8CciHuJ6yxNws1XznI3ddjEw==",
+      "dev": true,
+      "dependencies": {
+        "@typescript-eslint/types": "5.47.1",
+        "@typescript-eslint/visitor-keys": "5.47.1"
+      },
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/typescript-eslint"
+      }
+    },
+    "node_modules/@typescript-eslint/types": {
+      "version": "5.47.1",
+      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-5.47.1.tgz",
+      "integrity": "sha512-CmALY9YWXEpwuu6377ybJBZdtSAnzXLSQcxLSqSQSbC7VfpMu/HLVdrnVJj7ycI138EHqocW02LPJErE35cE9A==",
+      "dev": true,
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/typescript-eslint"
+      }
+    },
+    "node_modules/@typescript-eslint/typescript-estree": {
+      "version": "5.47.1",
+      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-5.47.1.tgz",
+      "integrity": "sha512-4+ZhFSuISAvRi2xUszEj0xXbNTHceV9GbH9S8oAD2a/F9SW57aJNQVOCxG8GPfSWH/X4eOPdMEU2jYVuWKEpWA==",
+      "dev": true,
+      "dependencies": {
+        "@typescript-eslint/types": "5.47.1",
+        "@typescript-eslint/visitor-keys": "5.47.1",
+        "debug": "^4.3.4",
+        "globby": "^11.1.0",
+        "is-glob": "^4.0.3",
+        "semver": "^7.3.7",
+        "tsutils": "^3.21.0"
+      },
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/typescript-eslint"
+      },
+      "peerDependenciesMeta": {
+        "typescript": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/@typescript-eslint/typescript-estree/node_modules/semver": {
+      "version": "7.3.8",
+      "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.8.tgz",
+      "integrity": "sha512-NB1ctGL5rlHrPJtFDVIVzTyQylMLu9N9VICA6HSFJo8MCGVTMW6gfpicwKmmK/dAjTOrqu5l63JJOpDSrAis3A==",
+      "dev": true,
+      "dependencies": {
+        "lru-cache": "^6.0.0"
+      },
+      "bin": {
+        "semver": "bin/semver.js"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/@typescript-eslint/visitor-keys": {
+      "version": "5.47.1",
+      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-5.47.1.tgz",
+      "integrity": "sha512-rF3pmut2JCCjh6BLRhNKdYjULMb1brvoaiWDlHfLNVgmnZ0sBVJrs3SyaKE1XoDDnJuAx/hDQryHYmPUuNq0ig==",
+      "dev": true,
+      "dependencies": {
+        "@typescript-eslint/types": "5.47.1",
+        "eslint-visitor-keys": "^3.3.0"
+      },
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/typescript-eslint"
+      }
+    },
+    "node_modules/acorn": {
+      "version": "6.4.2",
+      "resolved": "https://registry.npmjs.org/acorn/-/acorn-6.4.2.tgz",
+      "integrity": "sha512-XtGIhXwF8YM8bJhGxG5kXgjkEuNGLTkoYqVE+KMR+aspr4KGYmKYg7yUe3KghyQ9yheNwLnjmzh/7+gfDBmHCQ==",
+      "dev": true,
+      "bin": {
+        "acorn": "bin/acorn"
+      },
+      "engines": {
+        "node": ">=0.4.0"
+      }
+    },
+    "node_modules/acorn-dynamic-import": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/acorn-dynamic-import/-/acorn-dynamic-import-4.0.0.tgz",
+      "integrity": "sha512-d3OEjQV4ROpoflsnUA8HozoIR504TFxNivYEUi6uwz0IYhBkTDXGuWlNdMtybRt3nqVx/L6XqMt0FxkXuWKZhw==",
+      "dev": true,
+      "peerDependencies": {
+        "acorn": "^6.0.0"
+      }
+    },
+    "node_modules/acorn-jsx": {
+      "version": "5.3.2",
+      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
+      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
+      "dev": true,
+      "peerDependencies": {
+        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
+      }
+    },
+    "node_modules/aggregate-error": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/aggregate-error/-/aggregate-error-3.1.0.tgz",
+      "integrity": "sha512-4I7Td01quW/RpocfNayFdFVk1qSuoh0E7JrbRJ16nH01HhKFQ88INq9Sd+nd72zqRySlr9BmDA8xlEJ6vJMrYA==",
+      "dev": true,
+      "dependencies": {
+        "clean-stack": "^2.0.0",
+        "indent-string": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/ajv": {
+      "version": "6.12.6",
+      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
+      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
+      "dev": true,
+      "dependencies": {
+        "fast-deep-equal": "^3.1.1",
+        "fast-json-stable-stringify": "^2.0.0",
+        "json-schema-traverse": "^0.4.1",
+        "uri-js": "^4.2.2"
+      },
+      "funding": {
+        "type": "github",
+        "url": "https://github.com/sponsors/epoberezkin"
+      }
+    },
+    "node_modules/ansi-colors": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.1.tgz",
+      "integrity": "sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA==",
+      "dev": true,
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/ansi-escapes": {
+      "version": "4.3.2",
+      "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-4.3.2.tgz",
+      "integrity": "sha512-gKXj5ALrKWQLsYG9jlTRmR/xKluxHV+Z9QEwNIgCfM1/uwPMCuzVVnh5mwTd+OuBZcwSIMbqssNWRm1lE51QaQ==",
+      "dev": true,
+      "dependencies": {
+        "type-fest": "^0.21.3"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/ansi-escapes/node_modules/type-fest": {
+      "version": "0.21.3",
+      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.21.3.tgz",
+      "integrity": "sha512-t0rzBq87m3fVcduHDUFhKmyyX+9eo6WQjZvf51Ea/M0Q7+T374Jp1aUiyUl0GKxp8M/OETVHSDvmkyPgvX+X2w==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/ansi-regex": {
+      "version": "5.0.1",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
+      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/ansi-styles": {
+      "version": "3.2.1",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
+      "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
+      "dev": true,
+      "dependencies": {
+        "color-convert": "^1.9.0"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/anymatch": {
+      "version": "3.1.3",
+      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
+      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
+      "dev": true,
+      "dependencies": {
+        "normalize-path": "^3.0.0",
+        "picomatch": "^2.0.4"
+      },
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/argparse": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
+      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
+      "dev": true
+    },
+    "node_modules/array-union": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz",
+      "integrity": "sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/assert": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/assert/-/assert-2.0.0.tgz",
+      "integrity": "sha512-se5Cd+js9dXJnu6Ag2JFc00t+HmHOen+8Q+L7O9zI0PqQXr20uk2J0XQqMxZEeo5U50o8Nvmmx7dZrl+Ufr35A==",
+      "dependencies": {
+        "es6-object-assign": "^1.1.0",
+        "is-nan": "^1.2.1",
+        "object-is": "^1.0.1",
+        "util": "^0.12.0"
+      }
+    },
+    "node_modules/ast-types": {
+      "version": "0.16.1",
+      "resolved": "https://registry.npmjs.org/ast-types/-/ast-types-0.16.1.tgz",
+      "integrity": "sha512-6t10qk83GOG8p0vKmaCr8eiilZwO171AvbROMtvvNiwrTly62t+7XkA8RdIIVbpMhCASAsxgAzdRSwh6nw/5Dg==",
+      "dependencies": {
+        "tslib": "^2.0.1"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/astral-regex": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/astral-regex/-/astral-regex-2.0.0.tgz",
+      "integrity": "sha512-Z7tMw1ytTXt5jqMcOP+OQteU1VuNK9Y02uuJtKQ1Sv69jXQKKg5cibLwGJow8yzZP+eAc18EmLGPal0bp36rvQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/available-typed-arrays": {
+      "version": "1.0.5",
+      "resolved": "https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.5.tgz",
+      "integrity": "sha512-DMD0KiN46eipeziST1LPP/STfDU0sufISXmjSgvVsoU2tqxctQeASejWcfNtxYKqETM1UxQ8sp2OrSBWpHY6sw==",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/babel-plugin-polyfill-corejs2": {
+      "version": "0.3.3",
+      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs2/-/babel-plugin-polyfill-corejs2-0.3.3.tgz",
+      "integrity": "sha512-8hOdmFYFSZhqg2C/JgLUQ+t52o5nirNwaWM2B9LWteozwIvM14VSwdsCAUET10qT+kmySAlseadmfeeSWFCy+Q==",
+      "dev": true,
+      "dependencies": {
+        "@babel/compat-data": "^7.17.7",
+        "@babel/helper-define-polyfill-provider": "^0.3.3",
+        "semver": "^6.1.1"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/babel-plugin-polyfill-corejs2/node_modules/semver": {
+      "version": "6.3.0",
+      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
+      "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
+      "dev": true,
+      "bin": {
+        "semver": "bin/semver.js"
+      }
+    },
+    "node_modules/babel-plugin-polyfill-corejs3": {
+      "version": "0.6.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs3/-/babel-plugin-polyfill-corejs3-0.6.0.tgz",
+      "integrity": "sha512-+eHqR6OPcBhJOGgsIar7xoAB1GcSwVUA3XjAd7HJNzOXT4wv6/H7KIdA/Nc60cvUlDbKApmqNvD1B1bzOt4nyA==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-define-polyfill-provider": "^0.3.3",
+        "core-js-compat": "^3.25.1"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/babel-plugin-polyfill-regenerator": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-regenerator/-/babel-plugin-polyfill-regenerator-0.4.1.tgz",
+      "integrity": "sha512-NtQGmyQDXjQqQ+IzRkBVwEOz9lQ4zxAQZgoAYEtU9dJjnl1Oc98qnN7jcp+bE7O7aYzVpavXE3/VKXNzUbh7aw==",
+      "dev": true,
+      "dependencies": {
+        "@babel/helper-define-polyfill-provider": "^0.3.3"
+      },
+      "peerDependencies": {
+        "@babel/core": "^7.0.0-0"
+      }
+    },
+    "node_modules/babylon": {
+      "version": "6.18.0",
+      "resolved": "https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz",
+      "integrity": "sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ==",
+      "dev": true,
+      "bin": {
+        "babylon": "bin/babylon.js"
+      }
+    },
+    "node_modules/balanced-match": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz",
+      "integrity": "sha1-ibTRmasr7kneFk6gK4nORi1xt2c=",
+      "dev": true
+    },
+    "node_modules/binary-extensions": {
+      "version": "2.2.0",
+      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.2.0.tgz",
+      "integrity": "sha512-jDctJ/IVQbZoJykoeHbhXpOlNBqGNcwXJKJog42E5HDPUwQTSdjCHdihjj0DlnheQ7blbT6dHOafNAiS8ooQKA==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/brace-expansion": {
+      "version": "1.1.11",
+      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
+      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
+      "dev": true,
+      "dependencies": {
+        "balanced-match": "^1.0.0",
+        "concat-map": "0.0.1"
+      }
+    },
+    "node_modules/braces": {
+      "version": "3.0.2",
+      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
+      "integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
+      "dev": true,
+      "dependencies": {
+        "fill-range": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/browser-stdout": {
+      "version": "1.3.1",
+      "resolved": "https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz",
+      "integrity": "sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==",
+      "dev": true
+    },
+    "node_modules/browserslist": {
+      "version": "4.21.4",
+      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.21.4.tgz",
+      "integrity": "sha512-CBHJJdDmgjl3daYjN5Cp5kbTf1mUhZoS+beLklHIvkOWscs83YAhLlF3Wsh/lciQYAcbBJgTOD44VtG31ZM4Hw==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/browserslist"
+        },
+        {
+          "type": "tidelift",
+          "url": "https://tidelift.com/funding/github/npm/browserslist"
+        }
+      ],
+      "dependencies": {
+        "caniuse-lite": "^1.0.30001400",
+        "electron-to-chromium": "^1.4.251",
+        "node-releases": "^2.0.6",
+        "update-browserslist-db": "^1.0.9"
+      },
+      "bin": {
+        "browserslist": "cli.js"
+      },
+      "engines": {
+        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
+      }
+    },
+    "node_modules/call-bind": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.2.tgz",
+      "integrity": "sha512-7O+FbCihrB5WGbFYesctwmTKae6rOiIzmz1icreWJ+0aA7LJfuqhEso2T9ncpcFtzMQtzXf2QGGueWJGTYsqrA==",
+      "dependencies": {
+        "function-bind": "^1.1.1",
+        "get-intrinsic": "^1.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/callsites": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
+      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/camelcase": {
+      "version": "6.2.0",
+      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-6.2.0.tgz",
+      "integrity": "sha512-c7wVvbw3f37nuobQNtgsgG9POC9qMbNuMQmTCqZv23b6MIz0fcYpBiOlv9gEN/hdLdnZTDQhg6e9Dq5M1vKvfg==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/caniuse-lite": {
+      "version": "1.0.30001439",
+      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001439.tgz",
+      "integrity": "sha512-1MgUzEkoMO6gKfXflStpYgZDlFM7M/ck/bgfVCACO5vnAf0fXoNVHdWtqGU+MYca+4bL9Z5bpOVmR33cWW9G2A==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/browserslist"
+        },
+        {
+          "type": "tidelift",
+          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
+        }
+      ]
+    },
+    "node_modules/chalk": {
+      "version": "2.4.2",
+      "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
+      "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
+      "dev": true,
+      "dependencies": {
+        "ansi-styles": "^3.2.1",
+        "escape-string-regexp": "^1.0.5",
+        "supports-color": "^5.3.0"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/chokidar": {
+      "version": "3.5.3",
+      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.5.3.tgz",
+      "integrity": "sha512-Dr3sfKRP6oTcjf2JmUmFJfeVMvXBdegxB0iVQ5eb2V10uFJUCAS8OByZdVAyVb8xXNz3GjjTgj9kLWsZTqE6kw==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "individual",
+          "url": "https://paulmillr.com/funding/"
+        }
+      ],
+      "dependencies": {
+        "anymatch": "~3.1.2",
+        "braces": "~3.0.2",
+        "glob-parent": "~5.1.2",
+        "is-binary-path": "~2.1.0",
+        "is-glob": "~4.0.1",
+        "normalize-path": "~3.0.0",
+        "readdirp": "~3.6.0"
+      },
+      "engines": {
+        "node": ">= 8.10.0"
+      },
+      "optionalDependencies": {
+        "fsevents": "~2.3.2"
+      }
+    },
+    "node_modules/clean-stack": {
+      "version": "2.2.0",
+      "resolved": "https://registry.npmjs.org/clean-stack/-/clean-stack-2.2.0.tgz",
+      "integrity": "sha512-4diC9HaTE+KRAMWhDhrGOECgWZxoevMc5TlkObMqNSsVU62PYzXZ/SMTjzyGAFF1YusgxGcSWTEXBhp0CPwQ1A==",
+      "dev": true,
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/cli-cursor": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-3.1.0.tgz",
+      "integrity": "sha512-I/zHAwsKf9FqGoXM4WWRACob9+SNukZTd94DWF57E4toouRulbCxcUh6RKUEOQlYTHJnzkPMySvPNaaSLNfLZw==",
+      "dev": true,
+      "dependencies": {
+        "restore-cursor": "^3.1.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/cli-truncate": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/cli-truncate/-/cli-truncate-3.1.0.tgz",
+      "integrity": "sha512-wfOBkjXteqSnI59oPcJkcPl/ZmwvMMOj340qUIY1SKZCv0B9Cf4D4fAucRkIKQmsIuYK3x1rrgU7MeGRruiuiA==",
+      "dev": true,
+      "dependencies": {
+        "slice-ansi": "^5.0.0",
+        "string-width": "^5.0.0"
+      },
+      "engines": {
+        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/cli-truncate/node_modules/ansi-regex": {
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.0.1.tgz",
+      "integrity": "sha512-n5M855fKb2SsfMIiFFoVrABHJC8QtHwVx+mHWP3QcEqBHYienj5dHSgjbxtC0WEZXYt4wcD6zrQElDPhFuZgfA==",
+      "dev": true,
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
+      }
+    },
+    "node_modules/cli-truncate/node_modules/ansi-styles": {
+      "version": "6.1.0",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.1.0.tgz",
+      "integrity": "sha512-VbqNsoz55SYGczauuup0MFUyXNQviSpFTj1RQtFzmQLk18qbVSpTFFGMT293rmDaQuKCT6InmbuEyUne4mTuxQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/cli-truncate/node_modules/emoji-regex": {
+      "version": "9.2.2",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+      "dev": true
+    },
+    "node_modules/cli-truncate/node_modules/is-fullwidth-code-point": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-4.0.0.tgz",
+      "integrity": "sha512-O4L094N2/dZ7xqVdrXhh9r1KODPJpFms8B5sGdJLPy664AgvXsreZUyCQQNItZRDlYug4xStLjNp/sz3HvBowQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/cli-truncate/node_modules/slice-ansi": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-5.0.0.tgz",
+      "integrity": "sha512-FC+lgizVPfie0kkhqUScwRu1O/lF6NOgJmlCgK+/LYxDCTk8sGelYaHDhFcDN+Sn3Cv+3VSa4Byeo+IMCzpMgQ==",
+      "dev": true,
+      "dependencies": {
+        "ansi-styles": "^6.0.0",
+        "is-fullwidth-code-point": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/slice-ansi?sponsor=1"
+      }
+    },
+    "node_modules/cli-truncate/node_modules/string-width": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+      "dev": true,
+      "dependencies": {
+        "eastasianwidth": "^0.2.0",
+        "emoji-regex": "^9.2.2",
+        "strip-ansi": "^7.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/cli-truncate/node_modules/strip-ansi": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.0.1.tgz",
+      "integrity": "sha512-cXNxvT8dFNRVfhVME3JAe98mkXDYN2O1l7jmcwMnOslDeESg1rF/OZMtK0nRAhiari1unG5cD4jG3rapUAkLbw==",
+      "dev": true,
+      "dependencies": {
+        "ansi-regex": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
+      }
+    },
+    "node_modules/cliui": {
+      "version": "7.0.4",
+      "resolved": "https://registry.npmjs.org/cliui/-/cliui-7.0.4.tgz",
+      "integrity": "sha512-OcRE68cOsVMXp1Yvonl/fzkQOyjLSu/8bhPDfQt0e0/Eb283TKP20Fs2MqoPsr9SwA595rRCA+QMzYc9nBP+JQ==",
+      "dev": true,
+      "dependencies": {
+        "string-width": "^4.2.0",
+        "strip-ansi": "^6.0.0",
+        "wrap-ansi": "^7.0.0"
+      }
+    },
+    "node_modules/color-convert": {
+      "version": "1.9.3",
+      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
+      "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
+      "dev": true,
+      "dependencies": {
+        "color-name": "1.1.3"
+      }
+    },
+    "node_modules/color-name": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
+      "integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
+      "dev": true
+    },
+    "node_modules/colorette": {
+      "version": "2.0.20",
+      "resolved": "https://registry.npmjs.org/colorette/-/colorette-2.0.20.tgz",
+      "integrity": "sha512-IfEDxwoWIjkeXL1eXcDiow4UbKjhLdq6/EuSVR9GMN7KVH3r9gQ83e73hsz1Nd1T3ijd5xv1wcWRYO+D6kCI2w==",
+      "dev": true
+    },
+    "node_modules/commander": {
+      "version": "10.0.1",
+      "resolved": "https://registry.npmjs.org/commander/-/commander-10.0.1.tgz",
+      "integrity": "sha512-y4Mg2tXshplEbSGzx7amzPwKKOCGuoSRP/CjEdwwk0FOGlUbq6lKuoyDZTNZkmxHdJtp54hdfY/JUrdL7Xfdug==",
+      "dev": true,
+      "engines": {
+        "node": ">=14"
+      }
+    },
+    "node_modules/concat-map": {
+      "version": "0.0.1",
+      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
+      "integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=",
+      "dev": true
+    },
+    "node_modules/convert-source-map": {
+      "version": "1.8.0",
+      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-1.8.0.tgz",
+      "integrity": "sha512-+OQdjP49zViI/6i7nIJpA8rAl4sV/JdPfU9nZs3VqOwGIgizICvuN2ru6fMd+4llL0tar18UYJXfZ/TWtmhUjA==",
+      "dev": true,
+      "dependencies": {
+        "safe-buffer": "~5.1.1"
+      }
+    },
+    "node_modules/core-js-compat": {
+      "version": "3.26.1",
+      "resolved": "https://registry.npmjs.org/core-js-compat/-/core-js-compat-3.26.1.tgz",
+      "integrity": "sha512-622/KzTudvXCDLRw70iHW4KKs1aGpcRcowGWyYJr2DEBfRrd6hNJybxSWJFuZYD4ma86xhrwDDHxmDaIq4EA8A==",
+      "dev": true,
+      "dependencies": {
+        "browserslist": "^4.21.4"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/core-js"
+      }
+    },
+    "node_modules/cross-spawn": {
+      "version": "7.0.3",
+      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
+      "integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
+      "dev": true,
+      "dependencies": {
+        "path-key": "^3.1.0",
+        "shebang-command": "^2.0.0",
+        "which": "^2.0.1"
+      },
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/debug": {
+      "version": "4.3.4",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.4.tgz",
+      "integrity": "sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==",
+      "dev": true,
+      "dependencies": {
+        "ms": "2.1.2"
+      },
+      "engines": {
+        "node": ">=6.0"
+      },
+      "peerDependenciesMeta": {
+        "supports-color": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/decamelize": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/decamelize/-/decamelize-4.0.0.tgz",
+      "integrity": "sha512-9iE1PgSik9HeIIw2JO94IidnE3eBoQrFJ3w7sFuzSX4DpmZ3v5sZpUiV5Swcf6mQEF+Y0ru8Neo+p+nyh2J+hQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/deep-is": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.3.tgz",
+      "integrity": "sha1-s2nW+128E+7PUk+RsHD+7cNXzzQ=",
+      "dev": true
+    },
+    "node_modules/define-properties": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/define-properties/-/define-properties-1.1.3.tgz",
+      "integrity": "sha512-3MqfYKj2lLzdMSf8ZIZE/V+Zuy+BgD6f164e8K2w7dgnpKArBDerGYpM46IYYcjnkdPNMjPk9A6VFB8+3SKlXQ==",
+      "dependencies": {
+        "object-keys": "^1.0.12"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/diff": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/diff/-/diff-5.0.0.tgz",
+      "integrity": "sha512-/VTCrvm5Z0JGty/BWHljh+BAiw3IK+2j87NGMu8Nwc/f48WoDAC395uomO9ZD117ZOBaHmkX1oyLvkVM/aIT3w==",
+      "dev": true,
+      "engines": {
+        "node": ">=0.3.1"
+      }
+    },
+    "node_modules/dir-glob": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz",
+      "integrity": "sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==",
+      "dev": true,
+      "dependencies": {
+        "path-type": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/doctrine": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
+      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
+      "dev": true,
+      "dependencies": {
+        "esutils": "^2.0.2"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
+    "node_modules/eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true
+    },
+    "node_modules/electron-to-chromium": {
+      "version": "1.4.284",
+      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.4.284.tgz",
+      "integrity": "sha512-M8WEXFuKXMYMVr45fo8mq0wUrrJHheiKZf6BArTKk9ZBYCKJEOU5H8cdWgDT+qCVZf7Na4lVUaZsA+h6uA9+PA==",
+      "dev": true
+    },
+    "node_modules/emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true
+    },
+    "node_modules/es6-object-assign": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/es6-object-assign/-/es6-object-assign-1.1.0.tgz",
+      "integrity": "sha512-MEl9uirslVwqQU369iHNWZXsI8yaZYGg/D65aOgZkeyFJwHYSxilf7rQzXKI7DdDuBPrBXbfk3sl9hJhmd5AUw=="
+    },
+    "node_modules/escalade": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.1.1.tgz",
+      "integrity": "sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==",
+      "dev": true,
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/escape-string-regexp": {
+      "version": "1.0.5",
+      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
+      "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
+      "dev": true,
+      "engines": {
+        "node": ">=0.8.0"
+      }
+    },
+    "node_modules/eslint": {
+      "version": "8.40.0",
+      "resolved": "https://registry.npmjs.org/eslint/-/eslint-8.40.0.tgz",
+      "integrity": "sha512-bvR+TsP9EHL3TqNtj9sCNJVAFK3fBN8Q7g5waghxyRsPLIMwL73XSKnZFK0hk/O2ANC+iAoq6PWMQ+IfBAJIiQ==",
+      "dev": true,
+      "dependencies": {
+        "@eslint-community/eslint-utils": "^4.2.0",
+        "@eslint-community/regexpp": "^4.4.0",
+        "@eslint/eslintrc": "^2.0.3",
+        "@eslint/js": "8.40.0",
+        "@humanwhocodes/config-array": "^0.11.8",
+        "@humanwhocodes/module-importer": "^1.0.1",
+        "@nodelib/fs.walk": "^1.2.8",
+        "ajv": "^6.10.0",
+        "chalk": "^4.0.0",
+        "cross-spawn": "^7.0.2",
+        "debug": "^4.3.2",
+        "doctrine": "^3.0.0",
+        "escape-string-regexp": "^4.0.0",
+        "eslint-scope": "^7.2.0",
+        "eslint-visitor-keys": "^3.4.1",
+        "espree": "^9.5.2",
+        "esquery": "^1.4.2",
+        "esutils": "^2.0.2",
+        "fast-deep-equal": "^3.1.3",
+        "file-entry-cache": "^6.0.1",
+        "find-up": "^5.0.0",
+        "glob-parent": "^6.0.2",
+        "globals": "^13.19.0",
+        "grapheme-splitter": "^1.0.4",
+        "ignore": "^5.2.0",
+        "import-fresh": "^3.0.0",
+        "imurmurhash": "^0.1.4",
+        "is-glob": "^4.0.0",
+        "is-path-inside": "^3.0.3",
+        "js-sdsl": "^4.1.4",
+        "js-yaml": "^4.1.0",
+        "json-stable-stringify-without-jsonify": "^1.0.1",
+        "levn": "^0.4.1",
+        "lodash.merge": "^4.6.2",
+        "minimatch": "^3.1.2",
+        "natural-compare": "^1.4.0",
+        "optionator": "^0.9.1",
+        "strip-ansi": "^6.0.1",
+        "strip-json-comments": "^3.1.0",
+        "text-table": "^0.2.0"
+      },
+      "bin": {
+        "eslint": "bin/eslint.js"
+      },
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint"
+      }
+    },
+    "node_modules/eslint-scope": {
+      "version": "7.2.0",
+      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-7.2.0.tgz",
+      "integrity": "sha512-DYj5deGlHBfMt15J7rdtyKNq/Nqlv5KfU4iodrQ019XESsRnwXH9KAE0y3cwtUHDo2ob7CypAnCqefh6vioWRw==",
+      "dev": true,
+      "dependencies": {
+        "esrecurse": "^4.3.0",
+        "estraverse": "^5.2.0"
+      },
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint"
+      }
+    },
+    "node_modules/eslint-visitor-keys": {
+      "version": "3.4.1",
+      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.1.tgz",
+      "integrity": "sha512-pZnmmLwYzf+kWaM/Qgrvpen51upAktaaiI01nsJD/Yr3lMOdNtq0cxkrrg16w64VtisN6okbs7Q8AfGqj4c9fA==",
+      "dev": true,
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint"
+      }
+    },
+    "node_modules/eslint/node_modules/ansi-styles": {
+      "version": "4.3.0",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+      "dev": true,
+      "dependencies": {
+        "color-convert": "^2.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/eslint/node_modules/chalk": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.1.tgz",
+      "integrity": "sha512-diHzdDKxcU+bAsUboHLPEDQiw0qEe0qd7SYUn3HgcFlWgbDcfLGswOHYeGrHKzG9z6UYf01d9VFMfZxPM1xZSg==",
+      "dev": true,
+      "dependencies": {
+        "ansi-styles": "^4.1.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/chalk?sponsor=1"
+      }
+    },
+    "node_modules/eslint/node_modules/color-convert": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+      "dev": true,
+      "dependencies": {
+        "color-name": "~1.1.4"
+      },
+      "engines": {
+        "node": ">=7.0.0"
+      }
+    },
+    "node_modules/eslint/node_modules/color-name": {
+      "version": "1.1.4",
+      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+      "dev": true
+    },
+    "node_modules/eslint/node_modules/escape-string-regexp": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
+      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/eslint/node_modules/glob-parent": {
+      "version": "6.0.2",
+      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
+      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
+      "dev": true,
+      "dependencies": {
+        "is-glob": "^4.0.3"
+      },
+      "engines": {
+        "node": ">=10.13.0"
+      }
+    },
+    "node_modules/eslint/node_modules/globals": {
+      "version": "13.20.0",
+      "resolved": "https://registry.npmjs.org/globals/-/globals-13.20.0.tgz",
+      "integrity": "sha512-Qg5QtVkCy/kv3FUSlu4ukeZDVf9ee0iXLAUYX13gbR17bnejFTzr4iS9bY7kwCf1NztRNm1t91fjOiyx4CSwPQ==",
+      "dev": true,
+      "dependencies": {
+        "type-fest": "^0.20.2"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/eslint/node_modules/has-flag": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
+      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/eslint/node_modules/supports-color": {
+      "version": "7.2.0",
+      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
+      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
+      "dev": true,
+      "dependencies": {
+        "has-flag": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/espree": {
+      "version": "9.5.2",
+      "resolved": "https://registry.npmjs.org/espree/-/espree-9.5.2.tgz",
+      "integrity": "sha512-7OASN1Wma5fum5SrNhFMAMJxOUAbhyfQ8dQ//PJaJbNw0URTPWqIghHWt1MmAANKhHZIYOHruW4Kw4ruUWOdGw==",
+      "dev": true,
+      "dependencies": {
+        "acorn": "^8.8.0",
+        "acorn-jsx": "^5.3.2",
+        "eslint-visitor-keys": "^3.4.1"
+      },
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint"
+      }
+    },
+    "node_modules/espree/node_modules/acorn": {
+      "version": "8.8.2",
+      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.8.2.tgz",
+      "integrity": "sha512-xjIYgE8HBrkpd/sJqOGNspf8uHG+NOHGOw6a/Urj8taM2EXfdNAH2oFcPeIFfsv3+kz/mJrS5VuMqbNLjCa2vw==",
+      "dev": true,
+      "bin": {
+        "acorn": "bin/acorn"
+      },
+      "engines": {
+        "node": ">=0.4.0"
+      }
+    },
+    "node_modules/esprima": {
+      "version": "4.0.1",
+      "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
+      "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==",
+      "bin": {
+        "esparse": "bin/esparse.js",
+        "esvalidate": "bin/esvalidate.js"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/esprima-fb": {
+      "version": "15001.1001.0-dev-harmony-fb",
+      "resolved": "https://registry.npmjs.org/esprima-fb/-/esprima-fb-15001.1001.0-dev-harmony-fb.tgz",
+      "integrity": "sha1-Q761fsJujPI3092LM+QlM1d/Jlk=",
+      "dev": true,
+      "bin": {
+        "esparse": "bin/esparse.js",
+        "esvalidate": "bin/esvalidate.js"
+      },
+      "engines": {
+        "node": ">=0.4.0"
+      }
+    },
+    "node_modules/esquery": {
+      "version": "1.5.0",
+      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.5.0.tgz",
+      "integrity": "sha512-YQLXUplAwJgCydQ78IMJywZCceoqk1oH01OERdSAJc/7U2AylwjhSCLDEtqwg811idIS/9fIU5GjG73IgjKMVg==",
+      "dev": true,
+      "dependencies": {
+        "estraverse": "^5.1.0"
+      },
+      "engines": {
+        "node": ">=0.10"
+      }
+    },
+    "node_modules/esrecurse": {
+      "version": "4.3.0",
+      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
+      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
+      "dev": true,
+      "dependencies": {
+        "estraverse": "^5.2.0"
+      },
+      "engines": {
+        "node": ">=4.0"
+      }
+    },
+    "node_modules/estraverse": {
+      "version": "5.3.0",
+      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
+      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
+      "dev": true,
+      "engines": {
+        "node": ">=4.0"
+      }
+    },
+    "node_modules/esutils": {
+      "version": "2.0.3",
+      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
+      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
+      "dev": true,
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/execa": {
+      "version": "7.1.1",
+      "resolved": "https://registry.npmjs.org/execa/-/execa-7.1.1.tgz",
+      "integrity": "sha512-wH0eMf/UXckdUYnO21+HDztteVv05rq2GXksxT4fCGeHkBhw1DROXh40wcjMcRqDOWE7iPJ4n3M7e2+YFP+76Q==",
+      "dev": true,
+      "dependencies": {
+        "cross-spawn": "^7.0.3",
+        "get-stream": "^6.0.1",
+        "human-signals": "^4.3.0",
+        "is-stream": "^3.0.0",
+        "merge-stream": "^2.0.0",
+        "npm-run-path": "^5.1.0",
+        "onetime": "^6.0.0",
+        "signal-exit": "^3.0.7",
+        "strip-final-newline": "^3.0.0"
+      },
+      "engines": {
+        "node": "^14.18.0 || ^16.14.0 || >=18.0.0"
+      },
+      "funding": {
+        "url": "https://github.com/sindresorhus/execa?sponsor=1"
+      }
+    },
+    "node_modules/fast-deep-equal": {
+      "version": "3.1.3",
+      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
+      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
+      "dev": true
+    },
+    "node_modules/fast-glob": {
+      "version": "3.2.12",
+      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.2.12.tgz",
+      "integrity": "sha512-DVj4CQIYYow0BlaelwK1pHl5n5cRSJfM60UA0zK891sVInoPri2Ekj7+e1CT3/3qxXenpI+nBBmQAcJPJgaj4w==",
+      "dev": true,
+      "dependencies": {
+        "@nodelib/fs.stat": "^2.0.2",
+        "@nodelib/fs.walk": "^1.2.3",
+        "glob-parent": "^5.1.2",
+        "merge2": "^1.3.0",
+        "micromatch": "^4.0.4"
+      },
+      "engines": {
+        "node": ">=8.6.0"
+      }
+    },
+    "node_modules/fast-json-stable-stringify": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
+      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
+      "dev": true
+    },
+    "node_modules/fast-levenshtein": {
+      "version": "2.0.6",
+      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
+      "integrity": "sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=",
+      "dev": true
+    },
+    "node_modules/fastq": {
+      "version": "1.14.0",
+      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.14.0.tgz",
+      "integrity": "sha512-eR2D+V9/ExcbF9ls441yIuN6TI2ED1Y2ZcA5BmMtJsOkWOFRJQ0Jt0g1UwqXJJVAb+V+umH5Dfr8oh4EVP7VVg==",
+      "dev": true,
+      "dependencies": {
+        "reusify": "^1.0.4"
+      }
+    },
+    "node_modules/file-entry-cache": {
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz",
+      "integrity": "sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==",
+      "dev": true,
+      "dependencies": {
+        "flat-cache": "^3.0.4"
+      },
+      "engines": {
+        "node": "^10.12.0 || >=12.0.0"
+      }
+    },
+    "node_modules/fill-range": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
+      "integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
+      "dev": true,
+      "dependencies": {
+        "to-regex-range": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/find-up": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
+      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
+      "dev": true,
+      "dependencies": {
+        "locate-path": "^6.0.0",
+        "path-exists": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/flat": {
+      "version": "5.0.2",
+      "resolved": "https://registry.npmjs.org/flat/-/flat-5.0.2.tgz",
+      "integrity": "sha512-b6suED+5/3rTpUBdG1gupIl8MPFCAMA0QXwmljLhvCUKcUvdE4gWky9zpuGCcXHOsz4J9wPGNWq6OKpmIzz3hQ==",
+      "dev": true,
+      "bin": {
+        "flat": "cli.js"
+      }
+    },
+    "node_modules/flat-cache": {
+      "version": "3.0.4",
+      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-3.0.4.tgz",
+      "integrity": "sha512-dm9s5Pw7Jc0GvMYbshN6zchCA9RgQlzzEZX3vylR9IqFfS8XciblUXOKfW6SiuJ0e13eDYZoZV5wdrev7P3Nwg==",
+      "dev": true,
+      "dependencies": {
+        "flatted": "^3.1.0",
+        "rimraf": "^3.0.2"
+      },
+      "engines": {
+        "node": "^10.12.0 || >=12.0.0"
+      }
+    },
+    "node_modules/flatted": {
+      "version": "3.2.1",
+      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.2.1.tgz",
+      "integrity": "sha512-OMQjaErSFHmHqZe+PSidH5n8j3O0F2DdnVh8JB4j4eUQ2k6KvB0qGfrKIhapvez5JerBbmWkaLYUYWISaESoXg==",
+      "dev": true
+    },
+    "node_modules/flow-parser": {
+      "version": "0.195.0",
+      "resolved": "https://registry.npmjs.org/flow-parser/-/flow-parser-0.195.0.tgz",
+      "integrity": "sha512-vO9b3GJQHHsRgwe2wB7lkKLhB+2Nw3QcpVKt/yYpoGVTJo51HS7GAvLE47XJ1u/5ILNQ41A+q+SZdyq+uRvkKQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=0.4.0"
+      }
+    },
+    "node_modules/for-each": {
+      "version": "0.3.3",
+      "resolved": "https://registry.npmjs.org/for-each/-/for-each-0.3.3.tgz",
+      "integrity": "sha512-jqYfLp7mo9vIyQf8ykW2v7A+2N4QjeCeI5+Dz9XraiO1ign81wjiH7Fb9vSOWvQfNtmSa4H2RoQTrrXivdUZmw==",
+      "dependencies": {
+        "is-callable": "^1.1.3"
+      }
+    },
+    "node_modules/fs.realpath": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
+      "integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8=",
+      "dev": true
+    },
+    "node_modules/fsevents": {
+      "version": "2.3.2",
+      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
+      "integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
+      "dev": true,
+      "hasInstallScript": true,
+      "optional": true,
+      "os": [
+        "darwin"
+      ],
+      "engines": {
+        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
+      }
+    },
+    "node_modules/function-bind": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
+      "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A=="
+    },
+    "node_modules/gensync": {
+      "version": "1.0.0-beta.2",
+      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
+      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
+      "dev": true,
+      "engines": {
+        "node": ">=6.9.0"
+      }
+    },
+    "node_modules/get-caller-file": {
+      "version": "2.0.5",
+      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
+      "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
+      "dev": true,
+      "engines": {
+        "node": "6.* || 8.* || >= 10.*"
+      }
+    },
+    "node_modules/get-intrinsic": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.1.3.tgz",
+      "integrity": "sha512-QJVz1Tj7MS099PevUG5jvnt9tSkXN8K14dxQlikJuPt4uD9hHAHjLyLBiLR5zELelBdD9QNRAXZzsJx0WaDL9A==",
+      "dependencies": {
+        "function-bind": "^1.1.1",
+        "has": "^1.0.3",
+        "has-symbols": "^1.0.3"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/get-stream": {
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-6.0.1.tgz",
+      "integrity": "sha512-ts6Wi+2j3jQjqi70w5AlN8DFnkSwC+MqmxEzdEALB2qXZYV3X/b1CTfgPLGJNMeAWxdPfU8FO1ms3NUfaHCPYg==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/glob": {
+      "version": "8.0.3",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-8.0.3.tgz",
+      "integrity": "sha512-ull455NHSHI/Y1FqGaaYFaLGkNMMJbavMrEGFXG/PGrg6y7sutWHUHrz6gy6WEBH6akM1M414dWKCNs+IhKdiQ==",
+      "dev": true,
+      "dependencies": {
+        "fs.realpath": "^1.0.0",
+        "inflight": "^1.0.4",
+        "inherits": "2",
+        "minimatch": "^5.0.1",
+        "once": "^1.3.0"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
+    "node_modules/glob-parent": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
+      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
+      "dev": true,
+      "dependencies": {
+        "is-glob": "^4.0.1"
+      },
+      "engines": {
+        "node": ">= 6"
+      }
+    },
+    "node_modules/glob/node_modules/brace-expansion": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz",
+      "integrity": "sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==",
+      "dev": true,
+      "dependencies": {
+        "balanced-match": "^1.0.0"
+      }
+    },
+    "node_modules/glob/node_modules/minimatch": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-5.1.2.tgz",
+      "integrity": "sha512-bNH9mmM9qsJ2X4r2Nat1B//1dJVcn3+iBLa3IgqJ7EbGaDNepL9QSHOxN4ng33s52VMMhhIfgCYDk3C4ZmlDAg==",
+      "dev": true,
+      "dependencies": {
+        "brace-expansion": "^2.0.1"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/globals": {
+      "version": "11.12.0",
+      "resolved": "https://registry.npmjs.org/globals/-/globals-11.12.0.tgz",
+      "integrity": "sha512-WOBp/EEGUiIsJSp7wcv/y6MO+lV9UoncWqxuFfm8eBwzWNgyfBd6Gz+IeKQ9jCmyhoH99g15M3T+QaVHFjizVA==",
+      "dev": true,
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/globby": {
+      "version": "11.1.0",
+      "resolved": "https://registry.npmjs.org/globby/-/globby-11.1.0.tgz",
+      "integrity": "sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==",
+      "dev": true,
+      "dependencies": {
+        "array-union": "^2.1.0",
+        "dir-glob": "^3.0.1",
+        "fast-glob": "^3.2.9",
+        "ignore": "^5.2.0",
+        "merge2": "^1.4.1",
+        "slash": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/gopd": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.0.1.tgz",
+      "integrity": "sha512-d65bNlIadxvpb/A2abVdlqKqV563juRnZ1Wtk6s1sIR8uNsXR70xqIzVqxVf1eTqDunwT2MkczEeaezCKTZhwA==",
+      "dependencies": {
+        "get-intrinsic": "^1.1.3"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/grapheme-splitter": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/grapheme-splitter/-/grapheme-splitter-1.0.4.tgz",
+      "integrity": "sha512-bzh50DW9kTPM00T8y4o8vQg89Di9oLJVLW/KaOGIXJWP/iqCN6WKYkbNOF04vFLJhwcpYUh9ydh/+5vpOqV4YQ==",
+      "dev": true
+    },
+    "node_modules/has": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/has/-/has-1.0.3.tgz",
+      "integrity": "sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==",
+      "dependencies": {
+        "function-bind": "^1.1.1"
+      },
+      "engines": {
+        "node": ">= 0.4.0"
+      }
+    },
+    "node_modules/has-flag": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
+      "integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
+      "dev": true,
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/has-symbols": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz",
+      "integrity": "sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/has-tostringtag": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.0.tgz",
+      "integrity": "sha512-kFjcSNhnlGV1kyoGk7OXKSawH5JOb/LzUc5w9B02hOTO0dfFRjbHQKvg1d6cf3HbeUmtU9VbbV3qzZ2Teh97WQ==",
+      "dependencies": {
+        "has-symbols": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/he": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/he/-/he-1.2.0.tgz",
+      "integrity": "sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw==",
+      "dev": true,
+      "bin": {
+        "he": "bin/he"
+      }
+    },
+    "node_modules/human-signals": {
+      "version": "4.3.1",
+      "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-4.3.1.tgz",
+      "integrity": "sha512-nZXjEF2nbo7lIw3mgYjItAfgQXog3OjJogSbKa2CQIIvSGWcKgeJnQlNXip6NglNzYH45nSRiEVimMvYL8DDqQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=14.18.0"
+      }
+    },
+    "node_modules/ignore": {
+      "version": "5.2.4",
+      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.2.4.tgz",
+      "integrity": "sha512-MAb38BcSbH0eHNBxn7ql2NH/kX33OkB3lZ1BNdh7ENeRChHTYsTvWrMubiIAMNS2llXEEgZ1MUOBtXChP3kaFQ==",
+      "dev": true,
+      "engines": {
+        "node": ">= 4"
+      }
+    },
+    "node_modules/import-fresh": {
+      "version": "3.3.0",
+      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz",
+      "integrity": "sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==",
+      "dev": true,
+      "dependencies": {
+        "parent-module": "^1.0.0",
+        "resolve-from": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=6"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/imurmurhash": {
+      "version": "0.1.4",
+      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
+      "integrity": "sha1-khi5srkoojixPcT7a21XbyMUU+o=",
+      "dev": true,
+      "engines": {
+        "node": ">=0.8.19"
+      }
+    },
+    "node_modules/indent-string": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/indent-string/-/indent-string-4.0.0.tgz",
+      "integrity": "sha512-EdDDZu4A2OyIK7Lr/2zG+w5jmbuk1DVBnEwREQvBzspBJkCEbRa8GxU1lghYcaGJCnRWibjDXlq779X1/y5xwg==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/inflight": {
+      "version": "1.0.6",
+      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
+      "integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
+      "dev": true,
+      "dependencies": {
+        "once": "^1.3.0",
+        "wrappy": "1"
+      }
+    },
+    "node_modules/inherits": {
+      "version": "2.0.4",
+      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
+      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
+    },
+    "node_modules/is-arguments": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/is-arguments/-/is-arguments-1.1.1.tgz",
+      "integrity": "sha512-8Q7EARjzEnKpt/PCD7e1cgUS0a6X8u5tdSiMqXhojOdoV9TsMsiO+9VLC5vAmO8N7/GmXn7yjR8qnA6bVAEzfA==",
+      "dependencies": {
+        "call-bind": "^1.0.2",
+        "has-tostringtag": "^1.0.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-binary-path": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
+      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
+      "dev": true,
+      "dependencies": {
+        "binary-extensions": "^2.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/is-callable": {
+      "version": "1.2.7",
+      "resolved": "https://registry.npmjs.org/is-callable/-/is-callable-1.2.7.tgz",
+      "integrity": "sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA==",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-core-module": {
+      "version": "2.11.0",
+      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.11.0.tgz",
+      "integrity": "sha512-RRjxlvLDkD1YJwDbroBHMb+cukurkDWNyHx7D3oNB5x9rb5ogcksMC5wHCadcXoo67gVr/+3GFySh3134zi6rw==",
+      "dev": true,
+      "dependencies": {
+        "has": "^1.0.3"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-extglob": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
+      "integrity": "sha1-qIwCU1eR8C7TfHahueqXc8gz+MI=",
+      "dev": true,
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/is-generator-function": {
+      "version": "1.0.10",
+      "resolved": "https://registry.npmjs.org/is-generator-function/-/is-generator-function-1.0.10.tgz",
+      "integrity": "sha512-jsEjy9l3yiXEQ+PsXdmBwEPcOxaXWLspKdplFUVI9vq1iZgIekeC0L167qeu86czQaxed3q/Uzuw0swL0irL8A==",
+      "dependencies": {
+        "has-tostringtag": "^1.0.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-glob": {
+      "version": "4.0.3",
+      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
+      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
+      "dev": true,
+      "dependencies": {
+        "is-extglob": "^2.1.1"
+      },
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/is-nan": {
+      "version": "1.3.2",
+      "resolved": "https://registry.npmjs.org/is-nan/-/is-nan-1.3.2.tgz",
+      "integrity": "sha512-E+zBKpQ2t6MEo1VsonYmluk9NxGrbzpeeLC2xIViuO2EjU2xsXsBPwTr3Ykv9l08UYEVEdWeRZNouaZqF6RN0w==",
+      "dependencies": {
+        "call-bind": "^1.0.0",
+        "define-properties": "^1.1.3"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-number": {
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
+      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
+      "dev": true,
+      "engines": {
+        "node": ">=0.12.0"
+      }
+    },
+    "node_modules/is-path-inside": {
+      "version": "3.0.3",
+      "resolved": "https://registry.npmjs.org/is-path-inside/-/is-path-inside-3.0.3.tgz",
+      "integrity": "sha512-Fd4gABb+ycGAmKou8eMftCupSir5lRxqf4aD/vd0cD2qc4HL07OjCeuHMr8Ro4CoMaeCKDB0/ECBOVWjTwUvPQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/is-plain-obj": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/is-plain-obj/-/is-plain-obj-2.1.0.tgz",
+      "integrity": "sha512-YWnfyRwxL/+SsrWYfOpUtz5b3YD+nyfkHvjbcanzk8zgyO4ASD67uVMRt8k5bM4lLMDnXfriRhOpemw+NfT1eA==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/is-stream": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-3.0.0.tgz",
+      "integrity": "sha512-LnQR4bZ9IADDRSkvpqMGvt/tEJWclzklNgSw48V5EAaAeDd6qGvN8ei6k5p0tvxSR171VmGyHuTiAOfxAbr8kA==",
+      "dev": true,
+      "engines": {
+        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/is-typed-array": {
+      "version": "1.1.10",
+      "resolved": "https://registry.npmjs.org/is-typed-array/-/is-typed-array-1.1.10.tgz",
+      "integrity": "sha512-PJqgEHiWZvMpaFZ3uTc8kHPM4+4ADTlDniuQL7cU/UDA0Ql7F70yGfHph3cLNe+c9toaigv+DFzTJKhc2CtO6A==",
+      "dependencies": {
+        "available-typed-arrays": "^1.0.5",
+        "call-bind": "^1.0.2",
+        "for-each": "^0.3.3",
+        "gopd": "^1.0.1",
+        "has-tostringtag": "^1.0.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-unicode-supported": {
+      "version": "0.1.0",
+      "resolved": "https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz",
+      "integrity": "sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/isexe": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
+      "integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=",
+      "dev": true
+    },
+    "node_modules/js-sdsl": {
+      "version": "4.4.0",
+      "resolved": "https://registry.npmjs.org/js-sdsl/-/js-sdsl-4.4.0.tgz",
+      "integrity": "sha512-FfVSdx6pJ41Oa+CF7RDaFmTnCaFhua+SNYQX74riGOpl96x+2jQCqEfQ2bnXu/5DPCqlRuiqyvTJM0Qjz26IVg==",
+      "dev": true,
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/js-sdsl"
+      }
+    },
+    "node_modules/js-tokens": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
+      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
+      "dev": true
+    },
+    "node_modules/js-yaml": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
+      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
+      "dev": true,
+      "dependencies": {
+        "argparse": "^2.0.1"
+      },
+      "bin": {
+        "js-yaml": "bin/js-yaml.js"
+      }
+    },
+    "node_modules/jsesc": {
+      "version": "2.5.2",
+      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-2.5.2.tgz",
+      "integrity": "sha512-OYu7XEzjkCQ3C5Ps3QIZsQfNpqoJyZZA99wd9aWd05NCtC5pWOkShK2mkL6HXQR6/Cy2lbNdPlZBpuQHXE63gA==",
+      "dev": true,
+      "bin": {
+        "jsesc": "bin/jsesc"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/json-schema-traverse": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
+      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
+      "dev": true
+    },
+    "node_modules/json-stable-stringify-without-jsonify": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
+      "integrity": "sha1-nbe1lJatPzz+8wp1FC0tkwrXJlE=",
+      "dev": true
+    },
+    "node_modules/json5": {
+      "version": "2.2.3",
+      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
+      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
+      "dev": true,
+      "bin": {
+        "json5": "lib/cli.js"
+      },
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/levn": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
+      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
+      "dev": true,
+      "dependencies": {
+        "prelude-ls": "^1.2.1",
+        "type-check": "~0.4.0"
+      },
+      "engines": {
+        "node": ">= 0.8.0"
+      }
+    },
+    "node_modules/lilconfig": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/lilconfig/-/lilconfig-2.1.0.tgz",
+      "integrity": "sha512-utWOt/GHzuUxnLKxB6dk81RoOeoNeHgbrXiuGk4yyF5qlRz+iIVWu56E2fqGHFrXz0QNUhLB/8nKqvRH66JKGQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/lint-staged": {
+      "version": "13.2.2",
+      "resolved": "https://registry.npmjs.org/lint-staged/-/lint-staged-13.2.2.tgz",
+      "integrity": "sha512-71gSwXKy649VrSU09s10uAT0rWCcY3aewhMaHyl2N84oBk4Xs9HgxvUp3AYu+bNsK4NrOYYxvSgg7FyGJ+jGcA==",
+      "dev": true,
+      "dependencies": {
+        "chalk": "5.2.0",
+        "cli-truncate": "^3.1.0",
+        "commander": "^10.0.0",
+        "debug": "^4.3.4",
+        "execa": "^7.0.0",
+        "lilconfig": "2.1.0",
+        "listr2": "^5.0.7",
+        "micromatch": "^4.0.5",
+        "normalize-path": "^3.0.0",
+        "object-inspect": "^1.12.3",
+        "pidtree": "^0.6.0",
+        "string-argv": "^0.3.1",
+        "yaml": "^2.2.2"
+      },
+      "bin": {
+        "lint-staged": "bin/lint-staged.js"
+      },
+      "engines": {
+        "node": "^14.13.1 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/lint-staged"
+      }
+    },
+    "node_modules/lint-staged/node_modules/chalk": {
+      "version": "5.2.0",
+      "resolved": "https://registry.npmjs.org/chalk/-/chalk-5.2.0.tgz",
+      "integrity": "sha512-ree3Gqw/nazQAPuJJEy+avdl7QfZMcUvmHIKgEZkGL+xOBzRvup5Hxo6LHuMceSxOabuJLJm5Yp/92R9eMmMvA==",
+      "dev": true,
+      "engines": {
+        "node": "^12.17.0 || ^14.13 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/chalk?sponsor=1"
+      }
+    },
+    "node_modules/listr2": {
+      "version": "5.0.8",
+      "resolved": "https://registry.npmjs.org/listr2/-/listr2-5.0.8.tgz",
+      "integrity": "sha512-mC73LitKHj9w6v30nLNGPetZIlfpUniNSsxxrbaPcWOjDb92SHPzJPi/t+v1YC/lxKz/AJ9egOjww0qUuFxBpA==",
+      "dev": true,
+      "dependencies": {
+        "cli-truncate": "^2.1.0",
+        "colorette": "^2.0.19",
+        "log-update": "^4.0.0",
+        "p-map": "^4.0.0",
+        "rfdc": "^1.3.0",
+        "rxjs": "^7.8.0",
+        "through": "^2.3.8",
+        "wrap-ansi": "^7.0.0"
+      },
+      "engines": {
+        "node": "^14.13.1 || >=16.0.0"
+      },
+      "peerDependencies": {
+        "enquirer": ">= 2.3.0 < 3"
+      },
+      "peerDependenciesMeta": {
+        "enquirer": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/listr2/node_modules/ansi-styles": {
+      "version": "4.3.0",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+      "dev": true,
+      "dependencies": {
+        "color-convert": "^2.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/listr2/node_modules/cli-truncate": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/cli-truncate/-/cli-truncate-2.1.0.tgz",
+      "integrity": "sha512-n8fOixwDD6b/ObinzTrp1ZKFzbgvKZvuz/TvejnLn1aQfC6r52XEx85FmuC+3HI+JM7coBRXUvNqEU2PHVrHpg==",
+      "dev": true,
+      "dependencies": {
+        "slice-ansi": "^3.0.0",
+        "string-width": "^4.2.0"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/listr2/node_modules/color-convert": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+      "dev": true,
+      "dependencies": {
+        "color-name": "~1.1.4"
+      },
+      "engines": {
+        "node": ">=7.0.0"
+      }
+    },
+    "node_modules/listr2/node_modules/color-name": {
+      "version": "1.1.4",
+      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+      "dev": true
+    },
+    "node_modules/listr2/node_modules/slice-ansi": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-3.0.0.tgz",
+      "integrity": "sha512-pSyv7bSTC7ig9Dcgbw9AuRNUb5k5V6oDudjZoMBSr13qpLBG7tB+zgCkARjq7xIUgdz5P1Qe8u+rSGdouOOIyQ==",
+      "dev": true,
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "astral-regex": "^2.0.0",
+        "is-fullwidth-code-point": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/locate-path": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
+      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
+      "dev": true,
+      "dependencies": {
+        "p-locate": "^5.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/lodash.debounce": {
+      "version": "4.0.8",
+      "resolved": "https://registry.npmjs.org/lodash.debounce/-/lodash.debounce-4.0.8.tgz",
+      "integrity": "sha512-FT1yDzDYEoYWhnSGnpE/4Kj1fLZkDFyqRb7fNt6FdYOSxlUWAtp42Eh6Wb0rGIv/m9Bgo7x4GhQbm5Ys4SG5ow==",
+      "dev": true
+    },
+    "node_modules/lodash.merge": {
+      "version": "4.6.2",
+      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
+      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
+      "dev": true
+    },
+    "node_modules/log-update": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/log-update/-/log-update-4.0.0.tgz",
+      "integrity": "sha512-9fkkDevMefjg0mmzWFBW8YkFP91OrizzkW3diF7CpG+S2EYdy4+TVfGwz1zeF8x7hCx1ovSPTOE9Ngib74qqUg==",
+      "dev": true,
+      "dependencies": {
+        "ansi-escapes": "^4.3.0",
+        "cli-cursor": "^3.1.0",
+        "slice-ansi": "^4.0.0",
+        "wrap-ansi": "^6.2.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/log-update/node_modules/ansi-styles": {
+      "version": "4.3.0",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+      "dev": true,
+      "dependencies": {
+        "color-convert": "^2.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/log-update/node_modules/color-convert": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+      "dev": true,
+      "dependencies": {
+        "color-name": "~1.1.4"
+      },
+      "engines": {
+        "node": ">=7.0.0"
+      }
+    },
+    "node_modules/log-update/node_modules/color-name": {
+      "version": "1.1.4",
+      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+      "dev": true
+    },
+    "node_modules/log-update/node_modules/wrap-ansi": {
+      "version": "6.2.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-6.2.0.tgz",
+      "integrity": "sha512-r6lPcBGxZXlIcymEu7InxDMhdW0KDxpLgoFLcguasxCaJ/SOIZwINatK9KY/tf+ZrlywOKU0UDj3ATXUBfxJXA==",
+      "dev": true,
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/lru-cache": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
+      "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
+      "dev": true,
+      "dependencies": {
+        "yallist": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/magic-string": {
+      "version": "0.25.7",
+      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.25.7.tgz",
+      "integrity": "sha512-4CrMT5DOHTDk4HYDlzmwu4FVCcIYI8gauveasrdCu2IKIFOJ3f0v/8MDGJCDL9oD2ppz/Av1b0Nj345H9M+XIA==",
+      "dev": true,
+      "dependencies": {
+        "sourcemap-codec": "^1.4.4"
+      }
+    },
+    "node_modules/merge-stream": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
+      "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==",
+      "dev": true
+    },
+    "node_modules/merge2": {
+      "version": "1.4.1",
+      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
+      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
+      "dev": true,
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/micromatch": {
+      "version": "4.0.5",
+      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.5.tgz",
+      "integrity": "sha512-DMy+ERcEW2q8Z2Po+WNXuw3c5YaUSFjAO5GsJqfEl7UjvtIuFKO6ZrKvcItdy98dwFI2N1tg3zNIdKaQT+aNdA==",
+      "dev": true,
+      "dependencies": {
+        "braces": "^3.0.2",
+        "picomatch": "^2.3.1"
+      },
+      "engines": {
+        "node": ">=8.6"
+      }
+    },
+    "node_modules/mimic-fn": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-4.0.0.tgz",
+      "integrity": "sha512-vqiC06CuhBTUdZH+RYl8sFrL096vA45Ok5ISO6sE/Mr1jRbGH4Csnhi8f3wKVl7x8mO4Au7Ir9D3Oyv1VYMFJw==",
+      "dev": true,
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/minimatch": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
+      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
+      "dev": true,
+      "dependencies": {
+        "brace-expansion": "^1.1.7"
+      },
+      "engines": {
+        "node": "*"
+      }
+    },
+    "node_modules/mocha": {
+      "version": "10.2.0",
+      "resolved": "https://registry.npmjs.org/mocha/-/mocha-10.2.0.tgz",
+      "integrity": "sha512-IDY7fl/BecMwFHzoqF2sg/SHHANeBoMMXFlS9r0OXKDssYE1M5O43wUY/9BVPeIvfH2zmEbBfseqN9gBQZzXkg==",
+      "dev": true,
+      "dependencies": {
+        "ansi-colors": "4.1.1",
+        "browser-stdout": "1.3.1",
+        "chokidar": "3.5.3",
+        "debug": "4.3.4",
+        "diff": "5.0.0",
+        "escape-string-regexp": "4.0.0",
+        "find-up": "5.0.0",
+        "glob": "7.2.0",
+        "he": "1.2.0",
+        "js-yaml": "4.1.0",
+        "log-symbols": "4.1.0",
+        "minimatch": "5.0.1",
+        "ms": "2.1.3",
+        "nanoid": "3.3.3",
+        "serialize-javascript": "6.0.0",
+        "strip-json-comments": "3.1.1",
+        "supports-color": "8.1.1",
+        "workerpool": "6.2.1",
+        "yargs": "16.2.0",
+        "yargs-parser": "20.2.4",
+        "yargs-unparser": "2.0.0"
+      },
+      "bin": {
+        "_mocha": "bin/_mocha",
+        "mocha": "bin/mocha.js"
+      },
+      "engines": {
+        "node": ">= 14.0.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/mochajs"
+      }
+    },
+    "node_modules/mocha/node_modules/ansi-styles": {
+      "version": "4.3.0",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+      "dev": true,
+      "dependencies": {
+        "color-convert": "^2.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/mocha/node_modules/chalk": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.1.tgz",
+      "integrity": "sha512-diHzdDKxcU+bAsUboHLPEDQiw0qEe0qd7SYUn3HgcFlWgbDcfLGswOHYeGrHKzG9z6UYf01d9VFMfZxPM1xZSg==",
+      "dev": true,
+      "dependencies": {
+        "ansi-styles": "^4.1.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/chalk?sponsor=1"
+      }
+    },
+    "node_modules/mocha/node_modules/chalk/node_modules/supports-color": {
+      "version": "7.2.0",
+      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
+      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
+      "dev": true,
+      "dependencies": {
+        "has-flag": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/mocha/node_modules/color-convert": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+      "dev": true,
+      "dependencies": {
+        "color-name": "~1.1.4"
+      },
+      "engines": {
+        "node": ">=7.0.0"
+      }
+    },
+    "node_modules/mocha/node_modules/color-name": {
+      "version": "1.1.4",
+      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+      "dev": true
+    },
+    "node_modules/mocha/node_modules/escape-string-regexp": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
+      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/mocha/node_modules/glob": {
+      "version": "7.2.0",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.0.tgz",
+      "integrity": "sha512-lmLf6gtyrPq8tTjSmrO94wBeQbFR3HbLHbuyD69wuyQkImp2hWqMGB47OX65FBkPffO641IP9jWa1z4ivqG26Q==",
+      "dev": true,
+      "dependencies": {
+        "fs.realpath": "^1.0.0",
+        "inflight": "^1.0.4",
+        "inherits": "2",
+        "minimatch": "^3.0.4",
+        "once": "^1.3.0",
+        "path-is-absolute": "^1.0.0"
+      },
+      "engines": {
+        "node": "*"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
+    "node_modules/mocha/node_modules/glob/node_modules/minimatch": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
+      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
+      "dev": true,
+      "dependencies": {
+        "brace-expansion": "^1.1.7"
+      },
+      "engines": {
+        "node": "*"
+      }
+    },
+    "node_modules/mocha/node_modules/has-flag": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
+      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/mocha/node_modules/log-symbols": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-4.1.0.tgz",
+      "integrity": "sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==",
+      "dev": true,
+      "dependencies": {
+        "chalk": "^4.1.0",
+        "is-unicode-supported": "^0.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/mocha/node_modules/minimatch": {
+      "version": "5.0.1",
+      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-5.0.1.tgz",
+      "integrity": "sha512-nLDxIFRyhDblz3qMuq+SoRZED4+miJ/G+tdDrjkkkRnjAsBexeGpgjLEQ0blJy7rHhR2b93rhQY4SvyWu9v03g==",
+      "dev": true,
+      "dependencies": {
+        "brace-expansion": "^2.0.1"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/mocha/node_modules/minimatch/node_modules/brace-expansion": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz",
+      "integrity": "sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==",
+      "dev": true,
+      "dependencies": {
+        "balanced-match": "^1.0.0"
+      }
+    },
+    "node_modules/mocha/node_modules/ms": {
+      "version": "2.1.3",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+      "dev": true
+    },
+    "node_modules/mocha/node_modules/supports-color": {
+      "version": "8.1.1",
+      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz",
+      "integrity": "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==",
+      "dev": true,
+      "dependencies": {
+        "has-flag": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/supports-color?sponsor=1"
+      }
+    },
+    "node_modules/ms": {
+      "version": "2.1.2",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
+      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
+      "dev": true
+    },
+    "node_modules/nanoid": {
+      "version": "3.3.3",
+      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.3.tgz",
+      "integrity": "sha512-p1sjXuopFs0xg+fPASzQ28agW1oHD7xDsd9Xkf3T15H3c/cifrFHVwrh74PdoklAPi+i7MdRsE47vm2r6JoB+w==",
+      "dev": true,
+      "bin": {
+        "nanoid": "bin/nanoid.cjs"
+      },
+      "engines": {
+        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
+      }
+    },
+    "node_modules/natural-compare": {
+      "version": "1.4.0",
+      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
+      "integrity": "sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=",
+      "dev": true
+    },
+    "node_modules/node-releases": {
+      "version": "2.0.6",
+      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.6.tgz",
+      "integrity": "sha512-PiVXnNuFm5+iYkLBNeq5211hvO38y63T0i2KKh2KnUs3RpzJ+JtODFjkD8yjLwnDkTYF1eKXheUwdssR+NRZdg==",
+      "dev": true
+    },
+    "node_modules/normalize-path": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
+      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
+      "dev": true,
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/npm-run-path": {
+      "version": "5.1.0",
+      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-5.1.0.tgz",
+      "integrity": "sha512-sJOdmRGrY2sjNTRMbSvluQqg+8X7ZK61yvzBEIDhz4f8z1TZFYABsqjjCBd/0PUNE9M6QDgHJXQkGUEm7Q+l9Q==",
+      "dev": true,
+      "dependencies": {
+        "path-key": "^4.0.0"
+      },
+      "engines": {
+        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/npm-run-path/node_modules/path-key": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/path-key/-/path-key-4.0.0.tgz",
+      "integrity": "sha512-haREypq7xkM7ErfgIyA0z+Bj4AGKlMSdlQE2jvJo6huWD1EdkKYV+G/T4nq0YEF2vgTT8kqMFKo1uHn950r4SQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/object-inspect": {
+      "version": "1.12.3",
+      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.12.3.tgz",
+      "integrity": "sha512-geUvdk7c+eizMNUDkRpW1wJwgfOiOeHbxBR/hLXK1aT6zmVSO0jsQcs7fj6MGw89jC/cjGfLcNOrtMYtGqm81g==",
+      "dev": true,
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/object-is": {
+      "version": "1.1.5",
+      "resolved": "https://registry.npmjs.org/object-is/-/object-is-1.1.5.tgz",
+      "integrity": "sha512-3cyDsyHgtmi7I7DfSSI2LDp6SK2lwvtbg0p0R1e0RvTqF5ceGx+K2dfSjm1bKDMVCFEDAQvy+o8c6a7VujOddw==",
+      "dependencies": {
+        "call-bind": "^1.0.2",
+        "define-properties": "^1.1.3"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/object-keys": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz",
+      "integrity": "sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/once": {
+      "version": "1.4.0",
+      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
+      "integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
+      "dev": true,
+      "dependencies": {
+        "wrappy": "1"
+      }
+    },
+    "node_modules/onetime": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/onetime/-/onetime-6.0.0.tgz",
+      "integrity": "sha512-1FlR+gjXK7X+AsAHso35MnyN5KqGwJRi/31ft6x0M194ht7S+rWAvd7PHss9xSKMzE0asv1pyIHaJYq+BbacAQ==",
+      "dev": true,
+      "dependencies": {
+        "mimic-fn": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/optionator": {
+      "version": "0.9.1",
+      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz",
+      "integrity": "sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==",
+      "dev": true,
+      "dependencies": {
+        "deep-is": "^0.1.3",
+        "fast-levenshtein": "^2.0.6",
+        "levn": "^0.4.1",
+        "prelude-ls": "^1.2.1",
+        "type-check": "^0.4.0",
+        "word-wrap": "^1.2.3"
+      },
+      "engines": {
+        "node": ">= 0.8.0"
+      }
+    },
+    "node_modules/p-limit": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
+      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
+      "dev": true,
+      "dependencies": {
+        "yocto-queue": "^0.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/p-locate": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
+      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
+      "dev": true,
+      "dependencies": {
+        "p-limit": "^3.0.2"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/p-map": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/p-map/-/p-map-4.0.0.tgz",
+      "integrity": "sha512-/bjOqmgETBYB5BoEeGVea8dmvHb2m9GLy1E9W43yeyfP6QQCZGFNa+XRceJEuDB6zqr+gKpIAmlLebMpykw/MQ==",
+      "dev": true,
+      "dependencies": {
+        "aggregate-error": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/parent-module": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
+      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
+      "dev": true,
+      "dependencies": {
+        "callsites": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/path-exists": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
+      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/path-is-absolute": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
+      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
+      "dev": true,
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/path-key": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
+      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/path-parse": {
+      "version": "1.0.7",
+      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
+      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
+      "dev": true
+    },
+    "node_modules/path-type": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
+      "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/picocolors": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.0.0.tgz",
+      "integrity": "sha512-1fygroTLlHu66zi26VoTDv8yRgm0Fccecssto+MhsZ0D/DGW2sm8E8AjW7NU5VVTRt5GxbeZ5qBuJr+HyLYkjQ==",
+      "dev": true
+    },
+    "node_modules/picomatch": {
+      "version": "2.3.1",
+      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
+      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
+      "dev": true,
+      "engines": {
+        "node": ">=8.6"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/jonschlinkert"
+      }
+    },
+    "node_modules/pidtree": {
+      "version": "0.6.0",
+      "resolved": "https://registry.npmjs.org/pidtree/-/pidtree-0.6.0.tgz",
+      "integrity": "sha512-eG2dWTVw5bzqGRztnHExczNxt5VGsE6OwTeCG3fdUf9KBsZzO3R5OIIIzWR+iZA0NtZ+RDVdaoE2dK1cn6jH4g==",
+      "dev": true,
+      "bin": {
+        "pidtree": "bin/pidtree.js"
+      },
+      "engines": {
+        "node": ">=0.10"
+      }
+    },
+    "node_modules/prelude-ls": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
+      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
+      "dev": true,
+      "engines": {
+        "node": ">= 0.8.0"
+      }
+    },
+    "node_modules/prettier": {
+      "version": "2.6.2",
+      "resolved": "https://registry.npmjs.org/prettier/-/prettier-2.6.2.tgz",
+      "integrity": "sha512-PkUpF+qoXTqhOeWL9fu7As8LXsIUZ1WYaJiY/a7McAQzxjk82OF0tibkFXVCDImZtWxbvojFjerkiLb0/q8mew==",
+      "dev": true,
+      "bin": {
+        "prettier": "bin-prettier.js"
+      },
+      "engines": {
+        "node": ">=10.13.0"
+      },
+      "funding": {
+        "url": "https://github.com/prettier/prettier?sponsor=1"
+      }
+    },
+    "node_modules/punycode": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.0.tgz",
+      "integrity": "sha512-rRV+zQD8tVFys26lAGR9WUuS4iUAngJScM+ZRSKtvl5tKeZ2t5bvdNFdNHBW9FWR4guGHlgmsZ1G7BSm2wTbuA==",
+      "dev": true,
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/queue-microtask": {
+      "version": "1.2.3",
+      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
+      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/feross"
+        },
+        {
+          "type": "patreon",
+          "url": "https://www.patreon.com/feross"
+        },
+        {
+          "type": "consulting",
+          "url": "https://feross.org/support"
+        }
+      ]
+    },
+    "node_modules/randombytes": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
+      "integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
+      "dev": true,
+      "dependencies": {
+        "safe-buffer": "^5.1.0"
+      }
+    },
+    "node_modules/readdirp": {
+      "version": "3.6.0",
+      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
+      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
+      "dev": true,
+      "dependencies": {
+        "picomatch": "^2.2.1"
+      },
+      "engines": {
+        "node": ">=8.10.0"
+      }
+    },
+    "node_modules/regenerate": {
+      "version": "1.4.2",
+      "resolved": "https://registry.npmjs.org/regenerate/-/regenerate-1.4.2.tgz",
+      "integrity": "sha512-zrceR/XhGYU/d/opr2EKO7aRHUeiBI8qjtfHqADTwZd6Szfy16la6kqD0MIUs5z5hx6AaKa+PixpPrR289+I0A==",
+      "dev": true
+    },
+    "node_modules/regenerate-unicode-properties": {
+      "version": "10.1.0",
+      "resolved": "https://registry.npmjs.org/regenerate-unicode-properties/-/regenerate-unicode-properties-10.1.0.tgz",
+      "integrity": "sha512-d1VudCLoIGitcU/hEg2QqvyGZQmdC0Lf8BqdOMXGFSvJP4bNV1+XqbPQeHHLD51Jh4QJJ225dlIFvY4Ly6MXmQ==",
+      "dev": true,
+      "dependencies": {
+        "regenerate": "^1.4.2"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/regenerator-runtime": {
+      "version": "0.13.11",
+      "resolved": "https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.13.11.tgz",
+      "integrity": "sha512-kY1AZVr2Ra+t+piVaJ4gxaFaReZVH40AKNo7UCX6W+dEwBo/2oZJzqfuN1qLq1oL45o56cPaTXELwrTh8Fpggg==",
+      "dev": true
+    },
+    "node_modules/regenerator-transform": {
+      "version": "0.15.1",
+      "resolved": "https://registry.npmjs.org/regenerator-transform/-/regenerator-transform-0.15.1.tgz",
+      "integrity": "sha512-knzmNAcuyxV+gQCufkYcvOqX/qIIfHLv0u5x79kRxuGojfYVky1f15TzZEu2Avte8QGepvUNTnLskf8E6X6Vyg==",
+      "dev": true,
+      "dependencies": {
+        "@babel/runtime": "^7.8.4"
+      }
+    },
+    "node_modules/regexpu-core": {
+      "version": "5.2.2",
+      "resolved": "https://registry.npmjs.org/regexpu-core/-/regexpu-core-5.2.2.tgz",
+      "integrity": "sha512-T0+1Zp2wjF/juXMrMxHxidqGYn8U4R+zleSJhX9tQ1PUsS8a9UtYfbsF9LdiVgNX3kiX8RNaKM42nfSgvFJjmw==",
+      "dev": true,
+      "dependencies": {
+        "regenerate": "^1.4.2",
+        "regenerate-unicode-properties": "^10.1.0",
+        "regjsgen": "^0.7.1",
+        "regjsparser": "^0.9.1",
+        "unicode-match-property-ecmascript": "^2.0.0",
+        "unicode-match-property-value-ecmascript": "^2.1.0"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/regjsgen": {
+      "version": "0.7.1",
+      "resolved": "https://registry.npmjs.org/regjsgen/-/regjsgen-0.7.1.tgz",
+      "integrity": "sha512-RAt+8H2ZEzHeYWxZ3H2z6tF18zyyOnlcdaafLrm21Bguj7uZy6ULibiAFdXEtKQY4Sy7wDTwDiOazasMLc4KPA==",
+      "dev": true
+    },
+    "node_modules/regjsparser": {
+      "version": "0.9.1",
+      "resolved": "https://registry.npmjs.org/regjsparser/-/regjsparser-0.9.1.tgz",
+      "integrity": "sha512-dQUtn90WanSNl+7mQKcXAgZxvUe7Z0SqXlgzv0za4LwiUhyzBC58yQO3liFoUgu8GiJVInAhJjkj1N0EtQ5nkQ==",
+      "dev": true,
+      "dependencies": {
+        "jsesc": "~0.5.0"
+      },
+      "bin": {
+        "regjsparser": "bin/parser"
+      }
+    },
+    "node_modules/regjsparser/node_modules/jsesc": {
+      "version": "0.5.0",
+      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-0.5.0.tgz",
+      "integrity": "sha512-uZz5UnB7u4T9LvwmFqXii7pZSouaRPorGs5who1Ip7VO0wxanFvBL7GkM6dTHlgX+jhBApRetaWpnDabOeTcnA==",
+      "dev": true,
+      "bin": {
+        "jsesc": "bin/jsesc"
+      }
+    },
+    "node_modules/reify": {
+      "version": "0.20.12",
+      "resolved": "https://registry.npmjs.org/reify/-/reify-0.20.12.tgz",
+      "integrity": "sha512-4BzKwDWyJJbukwI6xIJRh+BDTitoGzxdgYPiQQ1zbcTZW6I8xgHPw1DnVuEs/mEZQlYm1e09DcFSApb4UaR5bQ==",
+      "dev": true,
+      "dependencies": {
+        "acorn": "^6.1.1",
+        "acorn-dynamic-import": "^4.0.0",
+        "magic-string": "^0.25.3",
+        "semver": "^5.4.1"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/require-directory": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
+      "integrity": "sha1-jGStX9MNqxyXbiNE/+f3kqam30I=",
+      "dev": true,
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/resolve": {
+      "version": "1.22.1",
+      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.1.tgz",
+      "integrity": "sha512-nBpuuYuY5jFsli/JIs1oldw6fOQCBioohqWZg/2hiaOybXOft4lonv85uDOKXdf8rhyK159cxU5cDcK/NKk8zw==",
+      "dev": true,
+      "dependencies": {
+        "is-core-module": "^2.9.0",
+        "path-parse": "^1.0.7",
+        "supports-preserve-symlinks-flag": "^1.0.0"
+      },
+      "bin": {
+        "resolve": "bin/resolve"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/resolve-from": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
+      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
+      "dev": true,
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/restore-cursor": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-3.1.0.tgz",
+      "integrity": "sha512-l+sSefzHpj5qimhFSE5a8nufZYAM3sBSVMAPtYkmC+4EH2anSGaEMXSD0izRQbu9nfyQ9y5JrVmp7E8oZrUjvA==",
+      "dev": true,
+      "dependencies": {
+        "onetime": "^5.1.0",
+        "signal-exit": "^3.0.2"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/restore-cursor/node_modules/mimic-fn": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
+      "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==",
+      "dev": true,
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/restore-cursor/node_modules/onetime": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz",
+      "integrity": "sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==",
+      "dev": true,
+      "dependencies": {
+        "mimic-fn": "^2.1.0"
+      },
+      "engines": {
+        "node": ">=6"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/reusify": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz",
+      "integrity": "sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==",
+      "dev": true,
+      "engines": {
+        "iojs": ">=1.0.0",
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/rfdc": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/rfdc/-/rfdc-1.3.0.tgz",
+      "integrity": "sha512-V2hovdzFbOi77/WajaSMXk2OLm+xNIeQdMMuB7icj7bk6zi2F8GGAxigcnDFpJHbNyNcgyJDiP+8nOrY5cZGrA==",
+      "dev": true
+    },
+    "node_modules/rimraf": {
+      "version": "3.0.2",
+      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
+      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
+      "dev": true,
+      "dependencies": {
+        "glob": "^7.1.3"
+      },
+      "bin": {
+        "rimraf": "bin.js"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
+    "node_modules/rimraf/node_modules/glob": {
+      "version": "7.2.3",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
+      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
+      "dev": true,
+      "dependencies": {
+        "fs.realpath": "^1.0.0",
+        "inflight": "^1.0.4",
+        "inherits": "2",
+        "minimatch": "^3.1.1",
+        "once": "^1.3.0",
+        "path-is-absolute": "^1.0.0"
+      },
+      "engines": {
+        "node": "*"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
+    "node_modules/run-parallel": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
+      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/feross"
+        },
+        {
+          "type": "patreon",
+          "url": "https://www.patreon.com/feross"
+        },
+        {
+          "type": "consulting",
+          "url": "https://feross.org/support"
+        }
+      ],
+      "dependencies": {
+        "queue-microtask": "^1.2.2"
+      }
+    },
+    "node_modules/rxjs": {
+      "version": "7.8.1",
+      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.8.1.tgz",
+      "integrity": "sha512-AA3TVj+0A2iuIoQkWEK/tqFjBq2j+6PO6Y0zJcvzLAFhEFIO3HL0vls9hWLncZbAAbK0mar7oZ4V079I/qPMxg==",
+      "dev": true,
+      "dependencies": {
+        "tslib": "^2.1.0"
+      }
+    },
+    "node_modules/safe-buffer": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
+      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
+      "dev": true
+    },
+    "node_modules/semver": {
+      "version": "5.7.1",
+      "resolved": "https://registry.npmjs.org/semver/-/semver-5.7.1.tgz",
+      "integrity": "sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ==",
+      "dev": true,
+      "bin": {
+        "semver": "bin/semver"
+      }
+    },
+    "node_modules/serialize-javascript": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-6.0.0.tgz",
+      "integrity": "sha512-Qr3TosvguFt8ePWqsvRfrKyQXIiW+nGbYpy8XK24NQHE83caxWt+mIymTT19DGFbNWNLfEwsrkSmN64lVWB9ag==",
+      "dev": true,
+      "dependencies": {
+        "randombytes": "^2.1.0"
+      }
+    },
+    "node_modules/shebang-command": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
+      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
+      "dev": true,
+      "dependencies": {
+        "shebang-regex": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/shebang-regex": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
+      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/signal-exit": {
+      "version": "3.0.7",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
+      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==",
+      "dev": true
+    },
+    "node_modules/slash": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
+      "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/slice-ansi": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-4.0.0.tgz",
+      "integrity": "sha512-qMCMfhY040cVHT43K9BFygqYbUPFZKHOg7K73mtTWJRb8pyP3fzf4Ixd5SzdEJQ6MRUg/WBnOLxghZtKKurENQ==",
+      "dev": true,
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "astral-regex": "^2.0.0",
+        "is-fullwidth-code-point": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/slice-ansi?sponsor=1"
+      }
+    },
+    "node_modules/slice-ansi/node_modules/ansi-styles": {
+      "version": "4.3.0",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+      "dev": true,
+      "dependencies": {
+        "color-convert": "^2.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/slice-ansi/node_modules/color-convert": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+      "dev": true,
+      "dependencies": {
+        "color-name": "~1.1.4"
+      },
+      "engines": {
+        "node": ">=7.0.0"
+      }
+    },
+    "node_modules/slice-ansi/node_modules/color-name": {
+      "version": "1.1.4",
+      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+      "dev": true
+    },
+    "node_modules/source-map": {
+      "version": "0.6.1",
+      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
+      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/sourcemap-codec": {
+      "version": "1.4.8",
+      "resolved": "https://registry.npmjs.org/sourcemap-codec/-/sourcemap-codec-1.4.8.tgz",
+      "integrity": "sha512-9NykojV5Uih4lgo5So5dtw+f0JgJX30KCNI8gwhz2J9A15wD0Ml6tjHKwf6fTSa6fAdVBdZeNOs9eJ71qCk8vA==",
+      "dev": true
+    },
+    "node_modules/string-argv": {
+      "version": "0.3.1",
+      "resolved": "https://registry.npmjs.org/string-argv/-/string-argv-0.3.1.tgz",
+      "integrity": "sha512-a1uQGz7IyVy9YwhqjZIZu1c8JO8dNIe20xBmSS6qu9kv++k3JGzCVmprbNN5Kn+BgzD5E7YYwg1CcjuJMRNsvg==",
+      "dev": true,
+      "engines": {
+        "node": ">=0.6.19"
+      }
+    },
+    "node_modules/string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "dependencies": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/strip-ansi": {
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "dependencies": {
+        "ansi-regex": "^5.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/strip-final-newline": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-3.0.0.tgz",
+      "integrity": "sha512-dOESqjYr96iWYylGObzd39EuNTa5VJxyvVAEm5Jnh7KGo75V43Hk1odPQkNDyXNmUR6k+gEiDVXnjB8HJ3crXw==",
+      "dev": true,
+      "engines": {
+        "node": ">=12"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/strip-json-comments": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
+      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
+      "dev": true,
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/supports-color": {
+      "version": "5.5.0",
+      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
+      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
+      "dev": true,
+      "dependencies": {
+        "has-flag": "^3.0.0"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/supports-preserve-symlinks-flag": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
+      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
+      "dev": true,
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/text-table": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
+      "integrity": "sha1-f17oI66AUgfACvLfSoTsP8+lcLQ=",
+      "dev": true
+    },
+    "node_modules/through": {
+      "version": "2.3.8",
+      "resolved": "https://registry.npmjs.org/through/-/through-2.3.8.tgz",
+      "integrity": "sha512-w89qg7PI8wAdvX60bMDP+bFoD5Dvhm9oLheFp5O4a2QF0cSBGsBX4qZmadPMvVqlLJBBci+WqGGOAPvcDeNSVg==",
+      "dev": true
+    },
+    "node_modules/to-fast-properties": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/to-fast-properties/-/to-fast-properties-2.0.0.tgz",
+      "integrity": "sha1-3F5pjL0HkmW8c+A3doGk5Og/YW4=",
+      "dev": true,
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/to-regex-range": {
+      "version": "5.0.1",
+      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
+      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
+      "dev": true,
+      "dependencies": {
+        "is-number": "^7.0.0"
+      },
+      "engines": {
+        "node": ">=8.0"
+      }
+    },
+    "node_modules/tslib": {
+      "version": "2.5.0",
+      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.5.0.tgz",
+      "integrity": "sha512-336iVw3rtn2BUK7ORdIAHTyxHGRIHVReokCR3XjbckJMK7ms8FysBfhLR8IXnAgy7T0PTPNBWKiH514FOW/WSg=="
+    },
+    "node_modules/tsutils": {
+      "version": "3.21.0",
+      "resolved": "https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz",
+      "integrity": "sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==",
+      "dev": true,
+      "dependencies": {
+        "tslib": "^1.8.1"
+      },
+      "engines": {
+        "node": ">= 6"
+      },
+      "peerDependencies": {
+        "typescript": ">=2.8.0 || >= 3.2.0-dev || >= 3.3.0-dev || >= 3.4.0-dev || >= 3.5.0-dev || >= 3.6.0-dev || >= 3.6.0-beta || >= 3.7.0-dev || >= 3.7.0-beta"
+      }
+    },
+    "node_modules/tsutils/node_modules/tslib": {
+      "version": "1.14.1",
+      "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz",
+      "integrity": "sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==",
+      "dev": true
+    },
+    "node_modules/type-check": {
+      "version": "0.4.0",
+      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
+      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
+      "dev": true,
+      "dependencies": {
+        "prelude-ls": "^1.2.1"
+      },
+      "engines": {
+        "node": ">= 0.8.0"
+      }
+    },
+    "node_modules/type-fest": {
+      "version": "0.20.2",
+      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz",
+      "integrity": "sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
+    "node_modules/typescript": {
+      "version": "4.9.4",
+      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.9.4.tgz",
+      "integrity": "sha512-Uz+dTXYzxXXbsFpM86Wh3dKCxrQqUcVMxwU54orwlJjOpO3ao8L7j5lH+dWfTwgCwIuM9GQ2kvVotzYJMXTBZg==",
+      "dev": true,
+      "bin": {
+        "tsc": "bin/tsc",
+        "tsserver": "bin/tsserver"
+      },
+      "engines": {
+        "node": ">=4.2.0"
+      }
+    },
+    "node_modules/unicode-canonical-property-names-ecmascript": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/unicode-canonical-property-names-ecmascript/-/unicode-canonical-property-names-ecmascript-2.0.0.tgz",
+      "integrity": "sha512-yY5PpDlfVIU5+y/BSCxAJRBIS1Zc2dDG3Ujq+sR0U+JjUevW2JhocOF+soROYDSaAezOzOKuyyixhD6mBknSmQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/unicode-match-property-ecmascript": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/unicode-match-property-ecmascript/-/unicode-match-property-ecmascript-2.0.0.tgz",
+      "integrity": "sha512-5kaZCrbp5mmbz5ulBkDkbY0SsPOjKqVS35VpL9ulMPfSl0J0Xsm+9Evphv9CoIZFwre7aJoa94AY6seMKGVN5Q==",
+      "dev": true,
+      "dependencies": {
+        "unicode-canonical-property-names-ecmascript": "^2.0.0",
+        "unicode-property-aliases-ecmascript": "^2.0.0"
+      },
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/unicode-match-property-value-ecmascript": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/unicode-match-property-value-ecmascript/-/unicode-match-property-value-ecmascript-2.1.0.tgz",
+      "integrity": "sha512-qxkjQt6qjg/mYscYMC0XKRn3Rh0wFPlfxB0xkt9CfyTvpX1Ra0+rAmdX2QyAobptSEvuy4RtpPRui6XkV+8wjA==",
+      "dev": true,
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/unicode-property-aliases-ecmascript": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/unicode-property-aliases-ecmascript/-/unicode-property-aliases-ecmascript-2.1.0.tgz",
+      "integrity": "sha512-6t3foTQI9qne+OZoVQB/8x8rk2k1eVy1gRXhV3oFQ5T6R1dqQ1xtin3XqSlx3+ATBkliTaR/hHyJBm+LVPNM8w==",
+      "dev": true,
+      "engines": {
+        "node": ">=4"
+      }
+    },
+    "node_modules/update-browserslist-db": {
+      "version": "1.0.10",
+      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.0.10.tgz",
+      "integrity": "sha512-OztqDenkfFkbSG+tRxBeAnCVPckDBcvibKd35yDONx6OU8N7sqgwc7rCbkJ/WcYtVRZ4ba68d6byhC21GFh7sQ==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/browserslist"
+        },
+        {
+          "type": "tidelift",
+          "url": "https://tidelift.com/funding/github/npm/browserslist"
+        }
+      ],
+      "dependencies": {
+        "escalade": "^3.1.1",
+        "picocolors": "^1.0.0"
+      },
+      "bin": {
+        "browserslist-lint": "cli.js"
+      },
+      "peerDependencies": {
+        "browserslist": ">= 4.21.0"
+      }
+    },
+    "node_modules/uri-js": {
+      "version": "4.4.1",
+      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
+      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
+      "dev": true,
+      "dependencies": {
+        "punycode": "^2.1.0"
+      }
+    },
+    "node_modules/util": {
+      "version": "0.12.5",
+      "resolved": "https://registry.npmjs.org/util/-/util-0.12.5.tgz",
+      "integrity": "sha512-kZf/K6hEIrWHI6XqOFUiiMa+79wE/D8Q+NCNAWclkyg3b4d2k7s0QGepNjiABc+aR3N1PAyHL7p6UcLY6LmrnA==",
+      "dependencies": {
+        "inherits": "^2.0.3",
+        "is-arguments": "^1.0.4",
+        "is-generator-function": "^1.0.7",
+        "is-typed-array": "^1.1.3",
+        "which-typed-array": "^1.1.2"
+      }
+    },
+    "node_modules/which": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
+      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
+      "dev": true,
+      "dependencies": {
+        "isexe": "^2.0.0"
+      },
+      "bin": {
+        "node-which": "bin/node-which"
+      },
+      "engines": {
+        "node": ">= 8"
+      }
+    },
+    "node_modules/which-typed-array": {
+      "version": "1.1.9",
+      "resolved": "https://registry.npmjs.org/which-typed-array/-/which-typed-array-1.1.9.tgz",
+      "integrity": "sha512-w9c4xkx6mPidwp7180ckYWfMmvxpjlZuIudNtDf4N/tTAUB8VJbX25qZoAsrtGuYNnGw3pa0AXgbGKRB8/EceA==",
+      "dependencies": {
+        "available-typed-arrays": "^1.0.5",
+        "call-bind": "^1.0.2",
+        "for-each": "^0.3.3",
+        "gopd": "^1.0.1",
+        "has-tostringtag": "^1.0.0",
+        "is-typed-array": "^1.1.10"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/word-wrap": {
+      "version": "1.2.3",
+      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz",
+      "integrity": "sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==",
+      "dev": true,
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
+    "node_modules/workerpool": {
+      "version": "6.2.1",
+      "resolved": "https://registry.npmjs.org/workerpool/-/workerpool-6.2.1.tgz",
+      "integrity": "sha512-ILEIE97kDZvF9Wb9f6h5aXK4swSlKGUcOEGiIYb2OOu/IrDU9iwj0fD//SsA6E5ibwJxpEvhullJY4Sl4GcpAw==",
+      "dev": true
+    },
+    "node_modules/wrap-ansi": {
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "dependencies": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/ansi-styles": {
+      "version": "4.3.0",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+      "dev": true,
+      "dependencies": {
+        "color-convert": "^2.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/color-convert": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+      "dev": true,
+      "dependencies": {
+        "color-name": "~1.1.4"
+      },
+      "engines": {
+        "node": ">=7.0.0"
+      }
+    },
+    "node_modules/wrap-ansi/node_modules/color-name": {
+      "version": "1.1.4",
+      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+      "dev": true
+    },
+    "node_modules/wrappy": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
+      "integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=",
+      "dev": true
+    },
+    "node_modules/y18n": {
+      "version": "5.0.8",
+      "resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
+      "integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/yallist": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
+      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
+      "dev": true
+    },
+    "node_modules/yaml": {
+      "version": "2.2.2",
+      "resolved": "https://registry.npmjs.org/yaml/-/yaml-2.2.2.tgz",
+      "integrity": "sha512-CBKFWExMn46Foo4cldiChEzn7S7SRV+wqiluAb6xmueD/fGyRHIhX8m14vVGgeFWjN540nKCNVj6P21eQjgTuA==",
+      "dev": true,
+      "engines": {
+        "node": ">= 14"
+      }
+    },
+    "node_modules/yargs": {
+      "version": "16.2.0",
+      "resolved": "https://registry.npmjs.org/yargs/-/yargs-16.2.0.tgz",
+      "integrity": "sha512-D1mvvtDG0L5ft/jGWkLpG1+m0eQxOfaBvTNELraWj22wSVUMWxZUvYgJYcKh6jGGIkJFhH4IZPQhR4TKpc8mBw==",
+      "dev": true,
+      "dependencies": {
+        "cliui": "^7.0.2",
+        "escalade": "^3.1.1",
+        "get-caller-file": "^2.0.5",
+        "require-directory": "^2.1.1",
+        "string-width": "^4.2.0",
+        "y18n": "^5.0.5",
+        "yargs-parser": "^20.2.2"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/yargs-parser": {
+      "version": "20.2.4",
+      "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-20.2.4.tgz",
+      "integrity": "sha512-WOkpgNhPTlE73h4VFAFsOnomJVaovO8VqLDzy5saChRBFQFBoMYirowyW+Q9HB4HFF4Z7VZTiG3iSzJJA29yRA==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/yargs-unparser": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/yargs-unparser/-/yargs-unparser-2.0.0.tgz",
+      "integrity": "sha512-7pRTIA9Qc1caZ0bZ6RYRGbHJthJWuakf+WmHK0rVeLkNrrGhfoabBNdue6kdINI6r4if7ocq9aD/n7xwKOdzOA==",
+      "dev": true,
+      "dependencies": {
+        "camelcase": "^6.0.0",
+        "decamelize": "^4.0.0",
+        "flat": "^5.0.2",
+        "is-plain-obj": "^2.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
+    "node_modules/yocto-queue": {
+      "version": "0.1.0",
+      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
+      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
+      "dev": true,
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    }
+  },
+  "dependencies": {
+    "@ampproject/remapping": {
+      "version": "2.2.0",
+      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.2.0.tgz",
+      "integrity": "sha512-qRmjj8nj9qmLTQXXmaR1cck3UXSRMPrbsLJAasZpF+t3riI71BXed5ebIOYwQntykeZuhjsdweEc9BxH5Jc26w==",
+      "dev": true,
+      "requires": {
+        "@jridgewell/gen-mapping": "^0.1.0",
+        "@jridgewell/trace-mapping": "^0.3.9"
+      }
+    },
+    "@babel/code-frame": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.18.6.tgz",
+      "integrity": "sha512-TDCmlK5eOvH+eH7cdAFlNXeVJqWIQ7gW9tY1GJIpUtFb6CmjVyq2VM3u71bOyR8CRihcCgMUYoDNyLXao3+70Q==",
+      "dev": true,
+      "requires": {
+        "@babel/highlight": "^7.18.6"
+      }
+    },
+    "@babel/compat-data": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.20.5.tgz",
+      "integrity": "sha512-KZXo2t10+/jxmkhNXc7pZTqRvSOIvVv/+lJwHS+B2rErwOyjuVRh60yVpb7liQ1U5t7lLJ1bz+t8tSypUZdm0g==",
+      "dev": true
+    },
+    "@babel/core": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.20.5.tgz",
+      "integrity": "sha512-UdOWmk4pNWTm/4DlPUl/Pt4Gz4rcEMb7CY0Y3eJl5Yz1vI8ZJGmHWaVE55LoxRjdpx0z259GE9U5STA9atUinQ==",
+      "dev": true,
+      "requires": {
+        "@ampproject/remapping": "^2.1.0",
+        "@babel/code-frame": "^7.18.6",
+        "@babel/generator": "^7.20.5",
+        "@babel/helper-compilation-targets": "^7.20.0",
+        "@babel/helper-module-transforms": "^7.20.2",
+        "@babel/helpers": "^7.20.5",
+        "@babel/parser": "^7.20.5",
+        "@babel/template": "^7.18.10",
+        "@babel/traverse": "^7.20.5",
+        "@babel/types": "^7.20.5",
+        "convert-source-map": "^1.7.0",
+        "debug": "^4.1.0",
+        "gensync": "^1.0.0-beta.2",
+        "json5": "^2.2.1",
+        "semver": "^6.3.0"
+      },
+      "dependencies": {
+        "semver": {
+          "version": "6.3.0",
+          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
+          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
+          "dev": true
+        }
+      }
+    },
+    "@babel/generator": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.20.5.tgz",
+      "integrity": "sha512-jl7JY2Ykn9S0yj4DQP82sYvPU+T3g0HFcWTqDLqiuA9tGRNIj9VfbtXGAYTTkyNEnQk1jkMGOdYka8aG/lulCA==",
+      "dev": true,
+      "requires": {
+        "@babel/types": "^7.20.5",
+        "@jridgewell/gen-mapping": "^0.3.2",
+        "jsesc": "^2.5.1"
+      },
+      "dependencies": {
+        "@jridgewell/gen-mapping": {
+          "version": "0.3.2",
+          "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.2.tgz",
+          "integrity": "sha512-mh65xKQAzI6iBcFzwv28KVWSmCkdRBWoOh+bYQGW3+6OZvbbN3TqMGo5hqYxQniRcH9F2VZIoJCm4pa3BPDK/A==",
+          "dev": true,
+          "requires": {
+            "@jridgewell/set-array": "^1.0.1",
+            "@jridgewell/sourcemap-codec": "^1.4.10",
+            "@jridgewell/trace-mapping": "^0.3.9"
+          }
+        }
+      }
+    },
+    "@babel/helper-annotate-as-pure": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-annotate-as-pure/-/helper-annotate-as-pure-7.18.6.tgz",
+      "integrity": "sha512-duORpUiYrEpzKIop6iNbjnwKLAKnJ47csTyRACyEmWj0QdUrm5aqNJGHSSEQSUAvNW0ojX0dOmK9dZduvkfeXA==",
+      "dev": true,
+      "requires": {
+        "@babel/types": "^7.18.6"
+      }
+    },
+    "@babel/helper-builder-binary-assignment-operator-visitor": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-builder-binary-assignment-operator-visitor/-/helper-builder-binary-assignment-operator-visitor-7.18.9.tgz",
+      "integrity": "sha512-yFQ0YCHoIqarl8BCRwBL8ulYUaZpz3bNsA7oFepAzee+8/+ImtADXNOmO5vJvsPff3qi+hvpkY/NYBTrBQgdNw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-explode-assignable-expression": "^7.18.6",
+        "@babel/types": "^7.18.9"
+      }
+    },
+    "@babel/helper-compilation-targets": {
+      "version": "7.20.0",
+      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.20.0.tgz",
+      "integrity": "sha512-0jp//vDGp9e8hZzBc6N/KwA5ZK3Wsm/pfm4CrY7vzegkVxc65SgSn6wYOnwHe9Js9HRQ1YTCKLGPzDtaS3RoLQ==",
+      "dev": true,
+      "requires": {
+        "@babel/compat-data": "^7.20.0",
+        "@babel/helper-validator-option": "^7.18.6",
+        "browserslist": "^4.21.3",
+        "semver": "^6.3.0"
+      },
+      "dependencies": {
+        "semver": {
+          "version": "6.3.0",
+          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
+          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
+          "dev": true
+        }
+      }
+    },
+    "@babel/helper-create-class-features-plugin": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-create-class-features-plugin/-/helper-create-class-features-plugin-7.20.5.tgz",
+      "integrity": "sha512-3RCdA/EmEaikrhayahwToF0fpweU/8o2p8vhc1c/1kftHOdTKuC65kik/TLc+qfbS8JKw4qqJbne4ovICDhmww==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-annotate-as-pure": "^7.18.6",
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-function-name": "^7.19.0",
+        "@babel/helper-member-expression-to-functions": "^7.18.9",
+        "@babel/helper-optimise-call-expression": "^7.18.6",
+        "@babel/helper-replace-supers": "^7.19.1",
+        "@babel/helper-split-export-declaration": "^7.18.6"
+      }
+    },
+    "@babel/helper-create-regexp-features-plugin": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-create-regexp-features-plugin/-/helper-create-regexp-features-plugin-7.20.5.tgz",
+      "integrity": "sha512-m68B1lkg3XDGX5yCvGO0kPx3v9WIYLnzjKfPcQiwntEQa5ZeRkPmo2X/ISJc8qxWGfwUr+kvZAeEzAwLec2r2w==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-annotate-as-pure": "^7.18.6",
+        "regexpu-core": "^5.2.1"
+      }
+    },
+    "@babel/helper-define-polyfill-provider": {
+      "version": "0.3.3",
+      "resolved": "https://registry.npmjs.org/@babel/helper-define-polyfill-provider/-/helper-define-polyfill-provider-0.3.3.tgz",
+      "integrity": "sha512-z5aQKU4IzbqCC1XH0nAqfsFLMVSo22SBKUc0BxGrLkolTdPTructy0ToNnlO2zA4j9Q/7pjMZf0DSY+DSTYzww==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-compilation-targets": "^7.17.7",
+        "@babel/helper-plugin-utils": "^7.16.7",
+        "debug": "^4.1.1",
+        "lodash.debounce": "^4.0.8",
+        "resolve": "^1.14.2",
+        "semver": "^6.1.2"
+      },
+      "dependencies": {
+        "semver": {
+          "version": "6.3.0",
+          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
+          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
+          "dev": true
+        }
+      }
+    },
+    "@babel/helper-environment-visitor": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-environment-visitor/-/helper-environment-visitor-7.18.9.tgz",
+      "integrity": "sha512-3r/aACDJ3fhQ/EVgFy0hpj8oHyHpQc+LPtJoY9SzTThAsStm4Ptegq92vqKoE3vD706ZVFWITnMnxucw+S9Ipg==",
+      "dev": true
+    },
+    "@babel/helper-explode-assignable-expression": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-explode-assignable-expression/-/helper-explode-assignable-expression-7.18.6.tgz",
+      "integrity": "sha512-eyAYAsQmB80jNfg4baAtLeWAQHfHFiR483rzFK+BhETlGZaQC9bsfrugfXDCbRHLQbIA7U5NxhhOxN7p/dWIcg==",
+      "dev": true,
+      "requires": {
+        "@babel/types": "^7.18.6"
+      }
+    },
+    "@babel/helper-function-name": {
+      "version": "7.19.0",
+      "resolved": "https://registry.npmjs.org/@babel/helper-function-name/-/helper-function-name-7.19.0.tgz",
+      "integrity": "sha512-WAwHBINyrpqywkUH0nTnNgI5ina5TFn85HKS0pbPDfxFfhyR/aNQEn4hGi1P1JyT//I0t4OgXUlofzWILRvS5w==",
+      "dev": true,
+      "requires": {
+        "@babel/template": "^7.18.10",
+        "@babel/types": "^7.19.0"
+      }
+    },
+    "@babel/helper-hoist-variables": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-hoist-variables/-/helper-hoist-variables-7.18.6.tgz",
+      "integrity": "sha512-UlJQPkFqFULIcyW5sbzgbkxn2FKRgwWiRexcuaR8RNJRy8+LLveqPjwZV/bwrLZCN0eUHD/x8D0heK1ozuoo6Q==",
+      "dev": true,
+      "requires": {
+        "@babel/types": "^7.18.6"
+      }
+    },
+    "@babel/helper-member-expression-to-functions": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-member-expression-to-functions/-/helper-member-expression-to-functions-7.18.9.tgz",
+      "integrity": "sha512-RxifAh2ZoVU67PyKIO4AMi1wTenGfMR/O/ae0CCRqwgBAt5v7xjdtRw7UoSbsreKrQn5t7r89eruK/9JjYHuDg==",
+      "dev": true,
+      "requires": {
+        "@babel/types": "^7.18.9"
+      }
+    },
+    "@babel/helper-module-imports": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.18.6.tgz",
+      "integrity": "sha512-0NFvs3VkuSYbFi1x2Vd6tKrywq+z/cLeYC/RJNFrIX/30Bf5aiGYbtvGXolEktzJH8o5E5KJ3tT+nkxuuZFVlA==",
+      "dev": true,
+      "requires": {
+        "@babel/types": "^7.18.6"
+      }
+    },
+    "@babel/helper-module-transforms": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.20.2.tgz",
+      "integrity": "sha512-zvBKyJXRbmK07XhMuujYoJ48B5yvvmM6+wcpv6Ivj4Yg6qO7NOZOSnvZN9CRl1zz1Z4cKf8YejmCMh8clOoOeA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-module-imports": "^7.18.6",
+        "@babel/helper-simple-access": "^7.20.2",
+        "@babel/helper-split-export-declaration": "^7.18.6",
+        "@babel/helper-validator-identifier": "^7.19.1",
+        "@babel/template": "^7.18.10",
+        "@babel/traverse": "^7.20.1",
+        "@babel/types": "^7.20.2"
+      }
+    },
+    "@babel/helper-optimise-call-expression": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-optimise-call-expression/-/helper-optimise-call-expression-7.18.6.tgz",
+      "integrity": "sha512-HP59oD9/fEHQkdcbgFCnbmgH5vIQTJbxh2yf+CdM89/glUNnuzr87Q8GIjGEnOktTROemO0Pe0iPAYbqZuOUiA==",
+      "dev": true,
+      "requires": {
+        "@babel/types": "^7.18.6"
+      }
+    },
+    "@babel/helper-plugin-utils": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.20.2.tgz",
+      "integrity": "sha512-8RvlJG2mj4huQ4pZ+rU9lqKi9ZKiRmuvGuM2HlWmkmgOhbs6zEAw6IEiJ5cQqGbDzGZOhwuOQNtZMi/ENLjZoQ==",
+      "dev": true
+    },
+    "@babel/helper-remap-async-to-generator": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-remap-async-to-generator/-/helper-remap-async-to-generator-7.18.9.tgz",
+      "integrity": "sha512-dI7q50YKd8BAv3VEfgg7PS7yD3Rtbi2J1XMXaalXO0W0164hYLnh8zpjRS0mte9MfVp/tltvr/cfdXPvJr1opA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-annotate-as-pure": "^7.18.6",
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-wrap-function": "^7.18.9",
+        "@babel/types": "^7.18.9"
+      }
+    },
+    "@babel/helper-replace-supers": {
+      "version": "7.19.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-replace-supers/-/helper-replace-supers-7.19.1.tgz",
+      "integrity": "sha512-T7ahH7wV0Hfs46SFh5Jz3s0B6+o8g3c+7TMxu7xKfmHikg7EAZ3I2Qk9LFhjxXq8sL7UkP5JflezNwoZa8WvWw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-member-expression-to-functions": "^7.18.9",
+        "@babel/helper-optimise-call-expression": "^7.18.6",
+        "@babel/traverse": "^7.19.1",
+        "@babel/types": "^7.19.0"
+      }
+    },
+    "@babel/helper-simple-access": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/helper-simple-access/-/helper-simple-access-7.20.2.tgz",
+      "integrity": "sha512-+0woI/WPq59IrqDYbVGfshjT5Dmk/nnbdpcF8SnMhhXObpTq2KNBdLFRFrkVdbDOyUmHBCxzm5FHV1rACIkIbA==",
+      "dev": true,
+      "requires": {
+        "@babel/types": "^7.20.2"
+      }
+    },
+    "@babel/helper-skip-transparent-expression-wrappers": {
+      "version": "7.20.0",
+      "resolved": "https://registry.npmjs.org/@babel/helper-skip-transparent-expression-wrappers/-/helper-skip-transparent-expression-wrappers-7.20.0.tgz",
+      "integrity": "sha512-5y1JYeNKfvnT8sZcK9DVRtpTbGiomYIHviSP3OQWmDPU3DeH4a1ZlT/N2lyQ5P8egjcRaT/Y9aNqUxK0WsnIIg==",
+      "dev": true,
+      "requires": {
+        "@babel/types": "^7.20.0"
+      }
+    },
+    "@babel/helper-split-export-declaration": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-split-export-declaration/-/helper-split-export-declaration-7.18.6.tgz",
+      "integrity": "sha512-bde1etTx6ZyTmobl9LLMMQsaizFVZrquTEHOqKeQESMKo4PlObf+8+JA25ZsIpZhT/WEd39+vOdLXAFG/nELpA==",
+      "dev": true,
+      "requires": {
+        "@babel/types": "^7.18.6"
+      }
+    },
+    "@babel/helper-string-parser": {
+      "version": "7.19.4",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.19.4.tgz",
+      "integrity": "sha512-nHtDoQcuqFmwYNYPz3Rah5ph2p8PFeFCsZk9A/48dPc/rGocJ5J3hAAZ7pb76VWX3fZKu+uEr/FhH5jLx7umrw==",
+      "dev": true
+    },
+    "@babel/helper-validator-identifier": {
+      "version": "7.19.1",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.19.1.tgz",
+      "integrity": "sha512-awrNfaMtnHUr653GgGEs++LlAvW6w+DcPrOliSMXWCKo597CwL5Acf/wWdNkf/tfEQE3mjkeD1YOVZOUV/od1w==",
+      "dev": true
+    },
+    "@babel/helper-validator-option": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.18.6.tgz",
+      "integrity": "sha512-XO7gESt5ouv/LRJdrVjkShckw6STTaB7l9BrpBaAHDeF5YZT+01PCwmR0SJHnkW6i8OwW/EVWRShfi4j2x+KQw==",
+      "dev": true
+    },
+    "@babel/helper-wrap-function": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/helper-wrap-function/-/helper-wrap-function-7.20.5.tgz",
+      "integrity": "sha512-bYMxIWK5mh+TgXGVqAtnu5Yn1un+v8DDZtqyzKRLUzrh70Eal2O3aZ7aPYiMADO4uKlkzOiRiZ6GX5q3qxvW9Q==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-function-name": "^7.19.0",
+        "@babel/template": "^7.18.10",
+        "@babel/traverse": "^7.20.5",
+        "@babel/types": "^7.20.5"
+      }
+    },
+    "@babel/helpers": {
+      "version": "7.20.6",
+      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.20.6.tgz",
+      "integrity": "sha512-Pf/OjgfgFRW5bApskEz5pvidpim7tEDPlFtKcNRXWmfHGn9IEI2W2flqRQXTFb7gIPTyK++N6rVHuwKut4XK6w==",
+      "dev": true,
+      "requires": {
+        "@babel/template": "^7.18.10",
+        "@babel/traverse": "^7.20.5",
+        "@babel/types": "^7.20.5"
+      }
+    },
+    "@babel/highlight": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.18.6.tgz",
+      "integrity": "sha512-u7stbOuYjaPezCuLj29hNW1v64M2Md2qupEKP1fHc7WdOA3DgLh37suiSrZYY7haUB7iBeQZ9P1uiRF359do3g==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-validator-identifier": "^7.18.6",
+        "chalk": "^2.0.0",
+        "js-tokens": "^4.0.0"
+      }
+    },
+    "@babel/parser": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.20.5.tgz",
+      "integrity": "sha512-r27t/cy/m9uKLXQNWWebeCUHgnAZq0CpG1OwKRxzJMP1vpSU4bSIK2hq+/cp0bQxetkXx38n09rNu8jVkcK/zA==",
+      "dev": true
+    },
+    "@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression/-/plugin-bugfix-safari-id-destructuring-collision-in-function-expression-7.18.6.tgz",
+      "integrity": "sha512-Dgxsyg54Fx1d4Nge8UnvTrED63vrwOdPmyvPzlNN/boaliRP54pm3pGzZD1SJUwrBA+Cs/xdG8kXX6Mn/RfISQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining/-/plugin-bugfix-v8-spread-parameters-in-optional-chaining-7.18.9.tgz",
+      "integrity": "sha512-AHrP9jadvH7qlOj6PINbgSuphjQUAK7AOT7DPjBo9EHoLhQTnnK5u45e1Hd4DbSQEO9nqPWtQ89r+XEOWFScKg==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.9",
+        "@babel/helper-skip-transparent-expression-wrappers": "^7.18.9",
+        "@babel/plugin-proposal-optional-chaining": "^7.18.9"
+      }
+    },
+    "@babel/plugin-proposal-async-generator-functions": {
+      "version": "7.20.1",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-async-generator-functions/-/plugin-proposal-async-generator-functions-7.20.1.tgz",
+      "integrity": "sha512-Gh5rchzSwE4kC+o/6T8waD0WHEQIsDmjltY8WnWRXHUdH8axZhuH86Ov9M72YhJfDrZseQwuuWaaIT/TmePp3g==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-plugin-utils": "^7.19.0",
+        "@babel/helper-remap-async-to-generator": "^7.18.9",
+        "@babel/plugin-syntax-async-generators": "^7.8.4"
+      }
+    },
+    "@babel/plugin-proposal-class-properties": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-class-properties/-/plugin-proposal-class-properties-7.18.6.tgz",
+      "integrity": "sha512-cumfXOF0+nzZrrN8Rf0t7M+tF6sZc7vhQwYQck9q1/5w2OExlD+b4v4RpMJFaV1Z7WcDRgO6FqvxqxGlwo+RHQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-create-class-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-proposal-class-static-block": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-class-static-block/-/plugin-proposal-class-static-block-7.18.6.tgz",
+      "integrity": "sha512-+I3oIiNxrCpup3Gi8n5IGMwj0gOCAjcJUSQEcotNnCCPMEnixawOQ+KeJPlgfjzx+FKQ1QSyZOWe7wmoJp7vhw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-create-class-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-class-static-block": "^7.14.5"
+      }
+    },
+    "@babel/plugin-proposal-dynamic-import": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-dynamic-import/-/plugin-proposal-dynamic-import-7.18.6.tgz",
+      "integrity": "sha512-1auuwmK+Rz13SJj36R+jqFPMJWyKEDd7lLSdOj4oJK0UTgGueSAtkrCvz9ewmgyU/P941Rv2fQwZJN8s6QruXw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-dynamic-import": "^7.8.3"
+      }
+    },
+    "@babel/plugin-proposal-export-namespace-from": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-export-namespace-from/-/plugin-proposal-export-namespace-from-7.18.9.tgz",
+      "integrity": "sha512-k1NtHyOMvlDDFeb9G5PhUXuGj8m/wiwojgQVEhJ/fsVsMCpLyOP4h0uGEjYJKrRI+EVPlb5Jk+Gt9P97lOGwtA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.9",
+        "@babel/plugin-syntax-export-namespace-from": "^7.8.3"
+      }
+    },
+    "@babel/plugin-proposal-json-strings": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-json-strings/-/plugin-proposal-json-strings-7.18.6.tgz",
+      "integrity": "sha512-lr1peyn9kOdbYc0xr0OdHTZ5FMqS6Di+H0Fz2I/JwMzGmzJETNeOFq2pBySw6X/KFL5EWDjlJuMsUGRFb8fQgQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-json-strings": "^7.8.3"
+      }
+    },
+    "@babel/plugin-proposal-logical-assignment-operators": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-logical-assignment-operators/-/plugin-proposal-logical-assignment-operators-7.18.9.tgz",
+      "integrity": "sha512-128YbMpjCrP35IOExw2Fq+x55LMP42DzhOhX2aNNIdI9avSWl2PI0yuBWarr3RYpZBSPtabfadkH2yeRiMD61Q==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.9",
+        "@babel/plugin-syntax-logical-assignment-operators": "^7.10.4"
+      }
+    },
+    "@babel/plugin-proposal-nullish-coalescing-operator": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-nullish-coalescing-operator/-/plugin-proposal-nullish-coalescing-operator-7.18.6.tgz",
+      "integrity": "sha512-wQxQzxYeJqHcfppzBDnm1yAY0jSRkUXR2z8RePZYrKwMKgMlE8+Z6LUno+bd6LvbGh8Gltvy74+9pIYkr+XkKA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3"
+      }
+    },
+    "@babel/plugin-proposal-numeric-separator": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-numeric-separator/-/plugin-proposal-numeric-separator-7.18.6.tgz",
+      "integrity": "sha512-ozlZFogPqoLm8WBr5Z8UckIoE4YQ5KESVcNudyXOR8uqIkliTEgJ3RoketfG6pmzLdeZF0H/wjE9/cCEitBl7Q==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-numeric-separator": "^7.10.4"
+      }
+    },
+    "@babel/plugin-proposal-object-rest-spread": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-object-rest-spread/-/plugin-proposal-object-rest-spread-7.20.2.tgz",
+      "integrity": "sha512-Ks6uej9WFK+fvIMesSqbAto5dD8Dz4VuuFvGJFKgIGSkJuRGcrwGECPA1fDgQK3/DbExBJpEkTeYeB8geIFCSQ==",
+      "dev": true,
+      "requires": {
+        "@babel/compat-data": "^7.20.1",
+        "@babel/helper-compilation-targets": "^7.20.0",
+        "@babel/helper-plugin-utils": "^7.20.2",
+        "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
+        "@babel/plugin-transform-parameters": "^7.20.1"
+      }
+    },
+    "@babel/plugin-proposal-optional-catch-binding": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-optional-catch-binding/-/plugin-proposal-optional-catch-binding-7.18.6.tgz",
+      "integrity": "sha512-Q40HEhs9DJQyaZfUjjn6vE8Cv4GmMHCYuMGIWUnlxH6400VGxOuwWsPt4FxXxJkC/5eOzgn0z21M9gMT4MOhbw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/plugin-syntax-optional-catch-binding": "^7.8.3"
+      }
+    },
+    "@babel/plugin-proposal-optional-chaining": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-optional-chaining/-/plugin-proposal-optional-chaining-7.18.9.tgz",
+      "integrity": "sha512-v5nwt4IqBXihxGsW2QmCWMDS3B3bzGIk/EQVZz2ei7f3NJl8NzAJVvUmpDW5q1CRNY+Beb/k58UAH1Km1N411w==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.9",
+        "@babel/helper-skip-transparent-expression-wrappers": "^7.18.9",
+        "@babel/plugin-syntax-optional-chaining": "^7.8.3"
+      }
+    },
+    "@babel/plugin-proposal-private-methods": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-private-methods/-/plugin-proposal-private-methods-7.18.6.tgz",
+      "integrity": "sha512-nutsvktDItsNn4rpGItSNV2sz1XwS+nfU0Rg8aCx3W3NOKVzdMjJRu0O5OkgDp3ZGICSTbgRpxZoWsxoKRvbeA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-create-class-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-proposal-private-property-in-object": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-private-property-in-object/-/plugin-proposal-private-property-in-object-7.20.5.tgz",
+      "integrity": "sha512-Vq7b9dUA12ByzB4EjQTPo25sFhY+08pQDBSZRtUAkj7lb7jahaHR5igera16QZ+3my1nYR4dKsNdYj5IjPHilQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-annotate-as-pure": "^7.18.6",
+        "@babel/helper-create-class-features-plugin": "^7.20.5",
+        "@babel/helper-plugin-utils": "^7.20.2",
+        "@babel/plugin-syntax-private-property-in-object": "^7.14.5"
+      }
+    },
+    "@babel/plugin-proposal-unicode-property-regex": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-unicode-property-regex/-/plugin-proposal-unicode-property-regex-7.18.6.tgz",
+      "integrity": "sha512-2BShG/d5yoZyXZfVePH91urL5wTG6ASZU9M4o03lKK8u8UW1y08OMttBSOADTcJrnPMpvDXRG3G8fyLh4ovs8w==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-create-regexp-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-syntax-async-generators": {
+      "version": "7.8.4",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-async-generators/-/plugin-syntax-async-generators-7.8.4.tgz",
+      "integrity": "sha512-tycmZxkGfZaxhMRbXlPXuVFpdWlXpir2W4AMhSJgRKzk/eDlIXOhb2LHWoLpDF7TEHylV5zNhykX6KAgHJmTNw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      }
+    },
+    "@babel/plugin-syntax-class-properties": {
+      "version": "7.12.13",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-properties/-/plugin-syntax-class-properties-7.12.13.tgz",
+      "integrity": "sha512-fm4idjKla0YahUNgFNLCB0qySdsoPiZP3iQE3rky0mBUtMZ23yDJ9SJdg6dXTSDnulOVqiF3Hgr9nbXvXTQZYA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.12.13"
+      }
+    },
+    "@babel/plugin-syntax-class-static-block": {
+      "version": "7.14.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-static-block/-/plugin-syntax-class-static-block-7.14.5.tgz",
+      "integrity": "sha512-b+YyPmr6ldyNnM6sqYeMWE+bgJcJpO6yS4QD7ymxgH34GBPNDM/THBh8iunyvKIZztiwLH4CJZ0RxTk9emgpjw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.14.5"
+      }
+    },
+    "@babel/plugin-syntax-dynamic-import": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-dynamic-import/-/plugin-syntax-dynamic-import-7.8.3.tgz",
+      "integrity": "sha512-5gdGbFon+PszYzqs83S3E5mpi7/y/8M9eC90MRTZfduQOYW76ig6SOSPNe41IG5LoP3FGBn2N0RjVDSQiS94kQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      }
+    },
+    "@babel/plugin-syntax-export-namespace-from": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-export-namespace-from/-/plugin-syntax-export-namespace-from-7.8.3.tgz",
+      "integrity": "sha512-MXf5laXo6c1IbEbegDmzGPwGNTsHZmEy6QGznu5Sh2UCWvueywb2ee+CCE4zQiZstxU9BMoQO9i6zUFSY0Kj0Q==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.8.3"
+      }
+    },
+    "@babel/plugin-syntax-import-assertions": {
+      "version": "7.20.0",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-assertions/-/plugin-syntax-import-assertions-7.20.0.tgz",
+      "integrity": "sha512-IUh1vakzNoWalR8ch/areW7qFopR2AEw03JlG7BbrDqmQ4X3q9uuipQwSGrUn7oGiemKjtSLDhNtQHzMHr1JdQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.19.0"
+      }
+    },
+    "@babel/plugin-syntax-json-strings": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-json-strings/-/plugin-syntax-json-strings-7.8.3.tgz",
+      "integrity": "sha512-lY6kdGpWHvjoe2vk4WrAapEuBR69EMxZl+RoGRhrFGNYVK8mOPAW8VfbT/ZgrFbXlDNiiaxQnAtgVCZ6jv30EA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      }
+    },
+    "@babel/plugin-syntax-logical-assignment-operators": {
+      "version": "7.10.4",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-logical-assignment-operators/-/plugin-syntax-logical-assignment-operators-7.10.4.tgz",
+      "integrity": "sha512-d8waShlpFDinQ5MtvGU9xDAOzKH47+FFoney2baFIoMr952hKOLp1HR7VszoZvOsV/4+RRszNY7D17ba0te0ig==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.10.4"
+      }
+    },
+    "@babel/plugin-syntax-nullish-coalescing-operator": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-nullish-coalescing-operator/-/plugin-syntax-nullish-coalescing-operator-7.8.3.tgz",
+      "integrity": "sha512-aSff4zPII1u2QD7y+F8oDsz19ew4IGEJg9SVW+bqwpwtfFleiQDMdzA/R+UlWDzfnHFCxxleFT0PMIrR36XLNQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      }
+    },
+    "@babel/plugin-syntax-numeric-separator": {
+      "version": "7.10.4",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-numeric-separator/-/plugin-syntax-numeric-separator-7.10.4.tgz",
+      "integrity": "sha512-9H6YdfkcK/uOnY/K7/aA2xpzaAgkQn37yzWUMRK7OaPOqOpGS1+n0H5hxT9AUw9EsSjPW8SVyMJwYRtWs3X3ug==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.10.4"
+      }
+    },
+    "@babel/plugin-syntax-object-rest-spread": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-object-rest-spread/-/plugin-syntax-object-rest-spread-7.8.3.tgz",
+      "integrity": "sha512-XoqMijGZb9y3y2XskN+P1wUGiVwWZ5JmoDRwx5+3GmEplNyVM2s2Dg8ILFQm8rWM48orGy5YpI5Bl8U1y7ydlA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      }
+    },
+    "@babel/plugin-syntax-optional-catch-binding": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-catch-binding/-/plugin-syntax-optional-catch-binding-7.8.3.tgz",
+      "integrity": "sha512-6VPD0Pc1lpTqw0aKoeRTMiB+kWhAoT24PA+ksWSBrFtl5SIRVpZlwN3NNPQjehA2E/91FV3RjLWoVTglWcSV3Q==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      }
+    },
+    "@babel/plugin-syntax-optional-chaining": {
+      "version": "7.8.3",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-chaining/-/plugin-syntax-optional-chaining-7.8.3.tgz",
+      "integrity": "sha512-KoK9ErH1MBlCPxV0VANkXW2/dw4vlbGDrFgz8bmUsBGYkFRcbRwMh6cIJubdPrkxRwuGdtCk0v/wPTKbQgBjkg==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.8.0"
+      }
+    },
+    "@babel/plugin-syntax-private-property-in-object": {
+      "version": "7.14.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-private-property-in-object/-/plugin-syntax-private-property-in-object-7.14.5.tgz",
+      "integrity": "sha512-0wVnp9dxJ72ZUJDV27ZfbSj6iHLoytYZmh3rFcxNnvsJF3ktkzLDZPy/mA17HGsaQT3/DQsWYX1f1QGWkCoVUg==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.14.5"
+      }
+    },
+    "@babel/plugin-transform-arrow-functions": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-arrow-functions/-/plugin-transform-arrow-functions-7.18.6.tgz",
+      "integrity": "sha512-9S9X9RUefzrsHZmKMbDXxweEH+YlE8JJEuat9FdvW9Qh1cw7W64jELCtWNkPBPX5En45uy28KGvA/AySqUh8CQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-async-to-generator": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-to-generator/-/plugin-transform-async-to-generator-7.18.6.tgz",
+      "integrity": "sha512-ARE5wZLKnTgPW7/1ftQmSi1CmkqqHo2DNmtztFhvgtOWSDfq0Cq9/9L+KnZNYSNrydBekhW3rwShduf59RoXag==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-module-imports": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/helper-remap-async-to-generator": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-block-scoped-functions": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoped-functions/-/plugin-transform-block-scoped-functions-7.18.6.tgz",
+      "integrity": "sha512-ExUcOqpPWnliRcPqves5HJcJOvHvIIWfuS4sroBUenPuMdmW+SMHDakmtS7qOo13sVppmUijqeTv7qqGsvURpQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-block-scoping": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoping/-/plugin-transform-block-scoping-7.20.5.tgz",
+      "integrity": "sha512-WvpEIW9Cbj9ApF3yJCjIEEf1EiNJLtXagOrL5LNWEZOo3jv8pmPoYTSNJQvqej8OavVlgOoOPw6/htGZro6IkA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.20.2"
+      }
+    },
+    "@babel/plugin-transform-classes": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-classes/-/plugin-transform-classes-7.20.2.tgz",
+      "integrity": "sha512-9rbPp0lCVVoagvtEyQKSo5L8oo0nQS/iif+lwlAz29MccX2642vWDlSZK+2T2buxbopotId2ld7zZAzRfz9j1g==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-annotate-as-pure": "^7.18.6",
+        "@babel/helper-compilation-targets": "^7.20.0",
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-function-name": "^7.19.0",
+        "@babel/helper-optimise-call-expression": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.20.2",
+        "@babel/helper-replace-supers": "^7.19.1",
+        "@babel/helper-split-export-declaration": "^7.18.6",
+        "globals": "^11.1.0"
+      }
+    },
+    "@babel/plugin-transform-computed-properties": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-computed-properties/-/plugin-transform-computed-properties-7.18.9.tgz",
+      "integrity": "sha512-+i0ZU1bCDymKakLxn5srGHrsAPRELC2WIbzwjLhHW9SIE1cPYkLCL0NlnXMZaM1vhfgA2+M7hySk42VBvrkBRw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      }
+    },
+    "@babel/plugin-transform-destructuring": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-destructuring/-/plugin-transform-destructuring-7.20.2.tgz",
+      "integrity": "sha512-mENM+ZHrvEgxLTBXUiQ621rRXZes3KWUv6NdQlrnr1TkWVw+hUjQBZuP2X32qKlrlG2BzgR95gkuCRSkJl8vIw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.20.2"
+      }
+    },
+    "@babel/plugin-transform-dotall-regex": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dotall-regex/-/plugin-transform-dotall-regex-7.18.6.tgz",
+      "integrity": "sha512-6S3jpun1eEbAxq7TdjLotAsl4WpQI9DxfkycRcKrjhQYzU87qpXdknpBg/e+TdcMehqGnLFi7tnFUBR02Vq6wg==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-create-regexp-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-duplicate-keys": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-keys/-/plugin-transform-duplicate-keys-7.18.9.tgz",
+      "integrity": "sha512-d2bmXCtZXYc59/0SanQKbiWINadaJXqtvIQIzd4+hNwkWBgyCd5F/2t1kXoUdvPMrxzPvhK6EMQRROxsue+mfw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      }
+    },
+    "@babel/plugin-transform-exponentiation-operator": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-exponentiation-operator/-/plugin-transform-exponentiation-operator-7.18.6.tgz",
+      "integrity": "sha512-wzEtc0+2c88FVR34aQmiz56dxEkxr2g8DQb/KfaFa1JYXOFVsbhvAonFN6PwVWj++fKmku8NP80plJ5Et4wqHw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-builder-binary-assignment-operator-visitor": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-for-of": {
+      "version": "7.18.8",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-for-of/-/plugin-transform-for-of-7.18.8.tgz",
+      "integrity": "sha512-yEfTRnjuskWYo0k1mHUqrVWaZwrdq8AYbfrpqULOJOaucGSp4mNMVps+YtA8byoevxS/urwU75vyhQIxcCgiBQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-function-name": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-function-name/-/plugin-transform-function-name-7.18.9.tgz",
+      "integrity": "sha512-WvIBoRPaJQ5yVHzcnJFor7oS5Ls0PYixlTYE63lCj2RtdQEl15M68FXQlxnG6wdraJIXRdR7KI+hQ7q/9QjrCQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-compilation-targets": "^7.18.9",
+        "@babel/helper-function-name": "^7.18.9",
+        "@babel/helper-plugin-utils": "^7.18.9"
+      }
+    },
+    "@babel/plugin-transform-literals": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-literals/-/plugin-transform-literals-7.18.9.tgz",
+      "integrity": "sha512-IFQDSRoTPnrAIrI5zoZv73IFeZu2dhu6irxQjY9rNjTT53VmKg9fenjvoiOWOkJ6mm4jKVPtdMzBY98Fp4Z4cg==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      }
+    },
+    "@babel/plugin-transform-member-expression-literals": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-member-expression-literals/-/plugin-transform-member-expression-literals-7.18.6.tgz",
+      "integrity": "sha512-qSF1ihLGO3q+/g48k85tUjD033C29TNTVB2paCwZPVmOsjn9pClvYYrM2VeJpBY2bcNkuny0YUyTNRyRxJ54KA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-modules-amd": {
+      "version": "7.19.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-amd/-/plugin-transform-modules-amd-7.19.6.tgz",
+      "integrity": "sha512-uG3od2mXvAtIFQIh0xrpLH6r5fpSQN04gIVovl+ODLdUMANokxQLZnPBHcjmv3GxRjnqwLuHvppjjcelqUFZvg==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-module-transforms": "^7.19.6",
+        "@babel/helper-plugin-utils": "^7.19.0"
+      }
+    },
+    "@babel/plugin-transform-modules-commonjs": {
+      "version": "7.19.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-commonjs/-/plugin-transform-modules-commonjs-7.19.6.tgz",
+      "integrity": "sha512-8PIa1ym4XRTKuSsOUXqDG0YaOlEuTVvHMe5JCfgBMOtHvJKw/4NGovEGN33viISshG/rZNVrACiBmPQLvWN8xQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-module-transforms": "^7.19.6",
+        "@babel/helper-plugin-utils": "^7.19.0",
+        "@babel/helper-simple-access": "^7.19.4"
+      }
+    },
+    "@babel/plugin-transform-modules-systemjs": {
+      "version": "7.19.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-systemjs/-/plugin-transform-modules-systemjs-7.19.6.tgz",
+      "integrity": "sha512-fqGLBepcc3kErfR9R3DnVpURmckXP7gj7bAlrTQyBxrigFqszZCkFkcoxzCp2v32XmwXLvbw+8Yq9/b+QqksjQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-hoist-variables": "^7.18.6",
+        "@babel/helper-module-transforms": "^7.19.6",
+        "@babel/helper-plugin-utils": "^7.19.0",
+        "@babel/helper-validator-identifier": "^7.19.1"
+      }
+    },
+    "@babel/plugin-transform-modules-umd": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-umd/-/plugin-transform-modules-umd-7.18.6.tgz",
+      "integrity": "sha512-dcegErExVeXcRqNtkRU/z8WlBLnvD4MRnHgNs3MytRO1Mn1sHRyhbcpYbVMGclAqOjdW+9cfkdZno9dFdfKLfQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-module-transforms": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-named-capturing-groups-regex": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-named-capturing-groups-regex/-/plugin-transform-named-capturing-groups-regex-7.20.5.tgz",
+      "integrity": "sha512-mOW4tTzi5iTLnw+78iEq3gr8Aoq4WNRGpmSlrogqaiCBoR1HFhpU4JkpQFOHfeYx3ReVIFWOQJS4aZBRvuZ6mA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-create-regexp-features-plugin": "^7.20.5",
+        "@babel/helper-plugin-utils": "^7.20.2"
+      }
+    },
+    "@babel/plugin-transform-new-target": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-new-target/-/plugin-transform-new-target-7.18.6.tgz",
+      "integrity": "sha512-DjwFA/9Iu3Z+vrAn+8pBUGcjhxKguSMlsFqeCKbhb9BAV756v0krzVK04CRDi/4aqmk8BsHb4a/gFcaA5joXRw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-object-super": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-super/-/plugin-transform-object-super-7.18.6.tgz",
+      "integrity": "sha512-uvGz6zk+pZoS1aTZrOvrbj6Pp/kK2mp45t2B+bTDre2UgsZZ8EZLSJtUg7m/no0zOJUWgFONpB7Zv9W2tSaFlA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6",
+        "@babel/helper-replace-supers": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-parameters": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-parameters/-/plugin-transform-parameters-7.20.5.tgz",
+      "integrity": "sha512-h7plkOmcndIUWXZFLgpbrh2+fXAi47zcUX7IrOQuZdLD0I0KvjJ6cvo3BEcAOsDOcZhVKGJqv07mkSqK0y2isQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.20.2"
+      }
+    },
+    "@babel/plugin-transform-property-literals": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-property-literals/-/plugin-transform-property-literals-7.18.6.tgz",
+      "integrity": "sha512-cYcs6qlgafTud3PAzrrRNbQtfpQ8+y/+M5tKmksS9+M1ckbH6kzY8MrexEM9mcA6JDsukE19iIRvAyYl463sMg==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-regenerator": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-regenerator/-/plugin-transform-regenerator-7.20.5.tgz",
+      "integrity": "sha512-kW/oO7HPBtntbsahzQ0qSE3tFvkFwnbozz3NWFhLGqH75vLEg+sCGngLlhVkePlCs3Jv0dBBHDzCHxNiFAQKCQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.20.2",
+        "regenerator-transform": "^0.15.1"
+      }
+    },
+    "@babel/plugin-transform-reserved-words": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-reserved-words/-/plugin-transform-reserved-words-7.18.6.tgz",
+      "integrity": "sha512-oX/4MyMoypzHjFrT1CdivfKZ+XvIPMFXwwxHp/r0Ddy2Vuomt4HDFGmft1TAY2yiTKiNSsh3kjBAzcM8kSdsjA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-shorthand-properties": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-shorthand-properties/-/plugin-transform-shorthand-properties-7.18.6.tgz",
+      "integrity": "sha512-eCLXXJqv8okzg86ywZJbRn19YJHU4XUa55oz2wbHhaQVn/MM+XhukiT7SYqp/7o00dg52Rj51Ny+Ecw4oyoygw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-spread": {
+      "version": "7.19.0",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-spread/-/plugin-transform-spread-7.19.0.tgz",
+      "integrity": "sha512-RsuMk7j6n+r752EtzyScnWkQyuJdli6LdO5Klv8Yx0OfPVTcQkIUfS8clx5e9yHXzlnhOZF3CbQ8C2uP5j074w==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.19.0",
+        "@babel/helper-skip-transparent-expression-wrappers": "^7.18.9"
+      }
+    },
+    "@babel/plugin-transform-sticky-regex": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-sticky-regex/-/plugin-transform-sticky-regex-7.18.6.tgz",
+      "integrity": "sha512-kfiDrDQ+PBsQDO85yj1icueWMfGfJFKN1KCkndygtu/C9+XUfydLC8Iv5UYJqRwy4zk8EcplRxEOeLyjq1gm6Q==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/plugin-transform-template-literals": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-template-literals/-/plugin-transform-template-literals-7.18.9.tgz",
+      "integrity": "sha512-S8cOWfT82gTezpYOiVaGHrCbhlHgKhQt8XH5ES46P2XWmX92yisoZywf5km75wv5sYcXDUCLMmMxOLCtthDgMA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      }
+    },
+    "@babel/plugin-transform-typeof-symbol": {
+      "version": "7.18.9",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-typeof-symbol/-/plugin-transform-typeof-symbol-7.18.9.tgz",
+      "integrity": "sha512-SRfwTtF11G2aemAZWivL7PD+C9z52v9EvMqH9BuYbabyPuKUvSWks3oCg6041pT925L4zVFqaVBeECwsmlguEw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      }
+    },
+    "@babel/plugin-transform-unicode-escapes": {
+      "version": "7.18.10",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-escapes/-/plugin-transform-unicode-escapes-7.18.10.tgz",
+      "integrity": "sha512-kKAdAI+YzPgGY/ftStBFXTI1LZFju38rYThnfMykS+IXy8BVx+res7s2fxf1l8I35DV2T97ezo6+SGrXz6B3iQ==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-plugin-utils": "^7.18.9"
+      }
+    },
+    "@babel/plugin-transform-unicode-regex": {
+      "version": "7.18.6",
+      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-regex/-/plugin-transform-unicode-regex-7.18.6.tgz",
+      "integrity": "sha512-gE7A6Lt7YLnNOL3Pb9BNeZvi+d8l7tcRrG4+pwJjK9hD2xX4mEvjlQW60G9EEmfXVYRPv9VRQcyegIVHCql/AA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-create-regexp-features-plugin": "^7.18.6",
+        "@babel/helper-plugin-utils": "^7.18.6"
+      }
+    },
+    "@babel/preset-env": {
+      "version": "7.20.2",
+      "resolved": "https://registry.npmjs.org/@babel/preset-env/-/preset-env-7.20.2.tgz",
+      "integrity": "sha512-1G0efQEWR1EHkKvKHqbG+IN/QdgwfByUpM5V5QroDzGV2t3S/WXNQd693cHiHTlCFMpr9B6FkPFXDA2lQcKoDg==",
+      "dev": true,
+      "requires": {
+        "@babel/compat-data": "^7.20.1",
+        "@babel/helper-compilation-targets": "^7.20.0",
+        "@babel/helper-plugin-utils": "^7.20.2",
+        "@babel/helper-validator-option": "^7.18.6",
+        "@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": "^7.18.6",
+        "@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining": "^7.18.9",
+        "@babel/plugin-proposal-async-generator-functions": "^7.20.1",
+        "@babel/plugin-proposal-class-properties": "^7.18.6",
+        "@babel/plugin-proposal-class-static-block": "^7.18.6",
+        "@babel/plugin-proposal-dynamic-import": "^7.18.6",
+        "@babel/plugin-proposal-export-namespace-from": "^7.18.9",
+        "@babel/plugin-proposal-json-strings": "^7.18.6",
+        "@babel/plugin-proposal-logical-assignment-operators": "^7.18.9",
+        "@babel/plugin-proposal-nullish-coalescing-operator": "^7.18.6",
+        "@babel/plugin-proposal-numeric-separator": "^7.18.6",
+        "@babel/plugin-proposal-object-rest-spread": "^7.20.2",
+        "@babel/plugin-proposal-optional-catch-binding": "^7.18.6",
+        "@babel/plugin-proposal-optional-chaining": "^7.18.9",
+        "@babel/plugin-proposal-private-methods": "^7.18.6",
+        "@babel/plugin-proposal-private-property-in-object": "^7.18.6",
+        "@babel/plugin-proposal-unicode-property-regex": "^7.18.6",
+        "@babel/plugin-syntax-async-generators": "^7.8.4",
+        "@babel/plugin-syntax-class-properties": "^7.12.13",
+        "@babel/plugin-syntax-class-static-block": "^7.14.5",
+        "@babel/plugin-syntax-dynamic-import": "^7.8.3",
+        "@babel/plugin-syntax-export-namespace-from": "^7.8.3",
+        "@babel/plugin-syntax-import-assertions": "^7.20.0",
+        "@babel/plugin-syntax-json-strings": "^7.8.3",
+        "@babel/plugin-syntax-logical-assignment-operators": "^7.10.4",
+        "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3",
+        "@babel/plugin-syntax-numeric-separator": "^7.10.4",
+        "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
+        "@babel/plugin-syntax-optional-catch-binding": "^7.8.3",
+        "@babel/plugin-syntax-optional-chaining": "^7.8.3",
+        "@babel/plugin-syntax-private-property-in-object": "^7.14.5",
+        "@babel/plugin-syntax-top-level-await": "^7.14.5",
+        "@babel/plugin-transform-arrow-functions": "^7.18.6",
+        "@babel/plugin-transform-async-to-generator": "^7.18.6",
+        "@babel/plugin-transform-block-scoped-functions": "^7.18.6",
+        "@babel/plugin-transform-block-scoping": "^7.20.2",
+        "@babel/plugin-transform-classes": "^7.20.2",
+        "@babel/plugin-transform-computed-properties": "^7.18.9",
+        "@babel/plugin-transform-destructuring": "^7.20.2",
+        "@babel/plugin-transform-dotall-regex": "^7.18.6",
+        "@babel/plugin-transform-duplicate-keys": "^7.18.9",
+        "@babel/plugin-transform-exponentiation-operator": "^7.18.6",
+        "@babel/plugin-transform-for-of": "^7.18.8",
+        "@babel/plugin-transform-function-name": "^7.18.9",
+        "@babel/plugin-transform-literals": "^7.18.9",
+        "@babel/plugin-transform-member-expression-literals": "^7.18.6",
+        "@babel/plugin-transform-modules-amd": "^7.19.6",
+        "@babel/plugin-transform-modules-commonjs": "^7.19.6",
+        "@babel/plugin-transform-modules-systemjs": "^7.19.6",
+        "@babel/plugin-transform-modules-umd": "^7.18.6",
+        "@babel/plugin-transform-named-capturing-groups-regex": "^7.19.1",
+        "@babel/plugin-transform-new-target": "^7.18.6",
+        "@babel/plugin-transform-object-super": "^7.18.6",
+        "@babel/plugin-transform-parameters": "^7.20.1",
+        "@babel/plugin-transform-property-literals": "^7.18.6",
+        "@babel/plugin-transform-regenerator": "^7.18.6",
+        "@babel/plugin-transform-reserved-words": "^7.18.6",
+        "@babel/plugin-transform-shorthand-properties": "^7.18.6",
+        "@babel/plugin-transform-spread": "^7.19.0",
+        "@babel/plugin-transform-sticky-regex": "^7.18.6",
+        "@babel/plugin-transform-template-literals": "^7.18.9",
+        "@babel/plugin-transform-typeof-symbol": "^7.18.9",
+        "@babel/plugin-transform-unicode-escapes": "^7.18.10",
+        "@babel/plugin-transform-unicode-regex": "^7.18.6",
+        "@babel/preset-modules": "^0.1.5",
+        "@babel/types": "^7.20.2",
+        "babel-plugin-polyfill-corejs2": "^0.3.3",
+        "babel-plugin-polyfill-corejs3": "^0.6.0",
+        "babel-plugin-polyfill-regenerator": "^0.4.1",
+        "core-js-compat": "^3.25.1",
+        "semver": "^6.3.0"
+      },
+      "dependencies": {
+        "@babel/plugin-syntax-top-level-await": {
+          "version": "7.14.5",
+          "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-top-level-await/-/plugin-syntax-top-level-await-7.14.5.tgz",
+          "integrity": "sha512-hx++upLv5U1rgYfwe1xBQUhRmU41NEvpUvrp8jkrSCdvGSnM5/qdRMtylJ6PG5OFkBaHkbTAKTnd3/YyESRHFw==",
+          "dev": true,
+          "requires": {
+            "@babel/helper-plugin-utils": "^7.14.5"
+          }
+        },
+        "@babel/preset-modules": {
+          "version": "0.1.5",
+          "resolved": "https://registry.npmjs.org/@babel/preset-modules/-/preset-modules-0.1.5.tgz",
+          "integrity": "sha512-A57th6YRG7oR3cq/yt/Y84MvGgE0eJG2F1JLhKuyG+jFxEgrd/HAMJatiFtmOiZurz+0DkrvbheCLaV5f2JfjA==",
+          "dev": true,
+          "requires": {
+            "@babel/helper-plugin-utils": "^7.0.0",
+            "@babel/plugin-proposal-unicode-property-regex": "^7.4.4",
+            "@babel/plugin-transform-dotall-regex": "^7.4.4",
+            "@babel/types": "^7.4.4",
+            "esutils": "^2.0.2"
+          }
+        },
+        "semver": {
+          "version": "6.3.0",
+          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
+          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
+          "dev": true
+        }
+      }
+    },
+    "@babel/runtime": {
+      "version": "7.20.6",
+      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.20.6.tgz",
+      "integrity": "sha512-Q+8MqP7TiHMWzSfwiJwXCjyf4GYA4Dgw3emg/7xmwsdLJOZUp+nMqcOwOzzYheuM1rhDu8FSj2l0aoMygEuXuA==",
+      "dev": true,
+      "requires": {
+        "regenerator-runtime": "^0.13.11"
+      }
+    },
+    "@babel/template": {
+      "version": "7.18.10",
+      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.18.10.tgz",
+      "integrity": "sha512-TI+rCtooWHr3QJ27kJxfjutghu44DLnasDMwpDqCXVTal9RLp3RSYNh4NdBrRP2cQAoG9A8juOQl6P6oZG4JxA==",
+      "dev": true,
+      "requires": {
+        "@babel/code-frame": "^7.18.6",
+        "@babel/parser": "^7.18.10",
+        "@babel/types": "^7.18.10"
+      }
+    },
+    "@babel/traverse": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.20.5.tgz",
+      "integrity": "sha512-WM5ZNN3JITQIq9tFZaw1ojLU3WgWdtkxnhM1AegMS+PvHjkM5IXjmYEGY7yukz5XS4sJyEf2VzWjI8uAavhxBQ==",
+      "dev": true,
+      "requires": {
+        "@babel/code-frame": "^7.18.6",
+        "@babel/generator": "^7.20.5",
+        "@babel/helper-environment-visitor": "^7.18.9",
+        "@babel/helper-function-name": "^7.19.0",
+        "@babel/helper-hoist-variables": "^7.18.6",
+        "@babel/helper-split-export-declaration": "^7.18.6",
+        "@babel/parser": "^7.20.5",
+        "@babel/types": "^7.20.5",
+        "debug": "^4.1.0",
+        "globals": "^11.1.0"
+      }
+    },
+    "@babel/types": {
+      "version": "7.20.5",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.20.5.tgz",
+      "integrity": "sha512-c9fst/h2/dcF7H+MJKZ2T0KjEQ8hY/BNnDk/H3XY8C4Aw/eWQXWn/lWntHF9ooUBnGmEvbfGrTgLWc+um0YDUg==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-string-parser": "^7.19.4",
+        "@babel/helper-validator-identifier": "^7.19.1",
+        "to-fast-properties": "^2.0.0"
+      }
+    },
+    "@eslint-community/eslint-utils": {
+      "version": "4.4.0",
+      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.4.0.tgz",
+      "integrity": "sha512-1/sA4dwrzBAyeUoQ6oxahHKmrZvsnLCg4RfxW3ZFGGmQkSNQPFNLV9CUEFQP1x9EYXHTo5p6xdhZM1Ne9p/AfA==",
+      "dev": true,
+      "requires": {
+        "eslint-visitor-keys": "^3.3.0"
+      }
+    },
+    "@eslint-community/regexpp": {
+      "version": "4.5.1",
+      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.5.1.tgz",
+      "integrity": "sha512-Z5ba73P98O1KUYCCJTUeVpja9RcGoMdncZ6T49FCUl2lN38JtCJ+3WgIDBv0AuY4WChU5PmtJmOCTlN6FZTFKQ==",
+      "dev": true
+    },
+    "@eslint/eslintrc": {
+      "version": "2.0.3",
+      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-2.0.3.tgz",
+      "integrity": "sha512-+5gy6OQfk+xx3q0d6jGZZC3f3KzAkXc/IanVxd1is/VIIziRqqt3ongQz0FiTUXqTk0c7aDB3OaFuKnuSoJicQ==",
+      "dev": true,
+      "requires": {
+        "ajv": "^6.12.4",
+        "debug": "^4.3.2",
+        "espree": "^9.5.2",
+        "globals": "^13.19.0",
+        "ignore": "^5.2.0",
+        "import-fresh": "^3.2.1",
+        "js-yaml": "^4.1.0",
+        "minimatch": "^3.1.2",
+        "strip-json-comments": "^3.1.1"
+      },
+      "dependencies": {
+        "globals": {
+          "version": "13.20.0",
+          "resolved": "https://registry.npmjs.org/globals/-/globals-13.20.0.tgz",
+          "integrity": "sha512-Qg5QtVkCy/kv3FUSlu4ukeZDVf9ee0iXLAUYX13gbR17bnejFTzr4iS9bY7kwCf1NztRNm1t91fjOiyx4CSwPQ==",
+          "dev": true,
+          "requires": {
+            "type-fest": "^0.20.2"
+          }
+        }
+      }
+    },
+    "@eslint/js": {
+      "version": "8.40.0",
+      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-8.40.0.tgz",
+      "integrity": "sha512-ElyB54bJIhXQYVKjDSvCkPO1iU1tSAeVQJbllWJq1XQSmmA4dgFk8CbiBGpiOPxleE48vDogxCtmMYku4HSVLA==",
+      "dev": true
+    },
+    "@humanwhocodes/config-array": {
+      "version": "0.11.8",
+      "resolved": "https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.11.8.tgz",
+      "integrity": "sha512-UybHIJzJnR5Qc/MsD9Kr+RpO2h+/P1GhOwdiLPXK5TWk5sgTdu88bTD9UP+CKbPPh5Rni1u0GjAdYQLemG8g+g==",
+      "dev": true,
+      "requires": {
+        "@humanwhocodes/object-schema": "^1.2.1",
+        "debug": "^4.1.1",
+        "minimatch": "^3.0.5"
+      }
+    },
+    "@humanwhocodes/module-importer": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
+      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
+      "dev": true
+    },
+    "@humanwhocodes/object-schema": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.1.tgz",
+      "integrity": "sha512-ZnQMnLV4e7hDlUvw8H+U8ASL02SS2Gn6+9Ac3wGGLIe7+je2AeAOxPY+izIPJDfFDb7eDjev0Us8MO1iFRN8hA==",
+      "dev": true
+    },
+    "@jridgewell/gen-mapping": {
+      "version": "0.1.1",
+      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.1.1.tgz",
+      "integrity": "sha512-sQXCasFk+U8lWYEe66WxRDOE9PjVz4vSM51fTu3Hw+ClTpUSQb718772vH3pyS5pShp6lvQM7SxgIDXXXmOX7w==",
+      "dev": true,
+      "requires": {
+        "@jridgewell/set-array": "^1.0.0",
+        "@jridgewell/sourcemap-codec": "^1.4.10"
+      }
+    },
+    "@jridgewell/resolve-uri": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.0.tgz",
+      "integrity": "sha512-F2msla3tad+Mfht5cJq7LSXcdudKTWCVYUgw6pLFOOHSTtZlj6SWNYAp+AhuqLmWdBO2X5hPrLcu8cVP8fy28w==",
+      "dev": true
+    },
+    "@jridgewell/set-array": {
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/@jridgewell/set-array/-/set-array-1.1.2.tgz",
+      "integrity": "sha512-xnkseuNADM0gt2bs+BvhO0p78Mk762YnZdsuzFV018NoG1Sj1SCQvpSqa7XUaTam5vAGasABV9qXASMKnFMwMw==",
+      "dev": true
+    },
+    "@jridgewell/sourcemap-codec": {
+      "version": "1.4.14",
+      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.4.14.tgz",
+      "integrity": "sha512-XPSJHWmi394fuUuzDnGz1wiKqWfo1yXecHQMRf2l6hztTO+nPru658AyDngaBe7isIxEkRsPR3FZh+s7iVa4Uw==",
+      "dev": true
+    },
+    "@jridgewell/trace-mapping": {
+      "version": "0.3.17",
+      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.17.tgz",
+      "integrity": "sha512-MCNzAp77qzKca9+W/+I0+sEpaUnZoeasnghNeVc41VZCEKaCH73Vq3BZZ/SzWIgrqE4H4ceI+p+b6C0mHf9T4g==",
+      "dev": true,
+      "requires": {
+        "@jridgewell/resolve-uri": "3.1.0",
+        "@jridgewell/sourcemap-codec": "1.4.14"
+      }
+    },
+    "@nodelib/fs.scandir": {
+      "version": "2.1.5",
+      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
+      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
+      "dev": true,
+      "requires": {
+        "@nodelib/fs.stat": "2.0.5",
+        "run-parallel": "^1.1.9"
+      }
+    },
+    "@nodelib/fs.stat": {
+      "version": "2.0.5",
+      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
+      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
+      "dev": true
+    },
+    "@nodelib/fs.walk": {
+      "version": "1.2.8",
+      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
+      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
+      "dev": true,
+      "requires": {
+        "@nodelib/fs.scandir": "2.1.5",
+        "fastq": "^1.6.0"
+      }
+    },
+    "@types/babel-types": {
+      "version": "7.0.11",
+      "resolved": "https://registry.npmjs.org/@types/babel-types/-/babel-types-7.0.11.tgz",
+      "integrity": "sha512-pkPtJUUY+Vwv6B1inAz55rQvivClHJxc9aVEPPmaq2cbyeMLCiDpbKpcKyX4LAwpNGi+SHBv0tHv6+0gXv0P2A==",
+      "dev": true
+    },
+    "@types/babylon": {
+      "version": "6.16.6",
+      "resolved": "https://registry.npmjs.org/@types/babylon/-/babylon-6.16.6.tgz",
+      "integrity": "sha512-G4yqdVlhr6YhzLXFKy5F7HtRBU8Y23+iWy7UKthMq/OSQnL1hbsoeXESQ2LY8zEDlknipDG3nRGhUC9tkwvy/w==",
+      "dev": true,
+      "requires": {
+        "@types/babel-types": "*"
+      }
+    },
+    "@types/esprima": {
+      "version": "4.0.3",
+      "resolved": "https://registry.npmjs.org/@types/esprima/-/esprima-4.0.3.tgz",
+      "integrity": "sha512-jo14dIWVVtF0iMsKkYek6++4cWJjwpvog+rchLulwgFJGTXqIeTdCOvY0B3yMLTaIwMcKCdJ6mQbSR6wYHy98A==",
+      "dev": true,
+      "requires": {
+        "@types/estree": "*"
+      }
+    },
+    "@types/estree": {
+      "version": "0.0.45",
+      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-0.0.45.tgz",
+      "integrity": "sha512-jnqIUKDUqJbDIUxm0Uj7bnlMnRm1T/eZ9N+AVMqhPgzrba2GhGG5o/jCTwmdPK709nEZsGoMzXEDUjcXHa3W0g==",
+      "dev": true
+    },
+    "@types/glob": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/@types/glob/-/glob-8.0.0.tgz",
+      "integrity": "sha512-l6NQsDDyQUVeoTynNpC9uRvCUint/gSUXQA2euwmTuWGvPY5LSDUu6tkCtJB2SvGQlJQzLaKqcGZP4//7EDveA==",
+      "dev": true,
+      "requires": {
+        "@types/minimatch": "*",
+        "@types/node": "*"
+      }
+    },
+    "@types/minimatch": {
+      "version": "3.0.3",
+      "resolved": "https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz",
+      "integrity": "sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA==",
+      "dev": true
+    },
+    "@types/mocha": {
+      "version": "10.0.1",
+      "resolved": "https://registry.npmjs.org/@types/mocha/-/mocha-10.0.1.tgz",
+      "integrity": "sha512-/fvYntiO1GeICvqbQ3doGDIP97vWmvFt83GKguJ6prmQM2iXZfFcq6YE8KteFyRtX2/h5Hf91BYvPodJKFYv5Q==",
+      "dev": true
+    },
+    "@types/node": {
+      "version": "18.11.15",
+      "resolved": "https://registry.npmjs.org/@types/node/-/node-18.11.15.tgz",
+      "integrity": "sha512-VkhBbVo2+2oozlkdHXLrb3zjsRkpdnaU2bXmX8Wgle3PUi569eLRaHGlgETQHR7lLL1w7GiG3h9SnePhxNDecw==",
+      "dev": true
+    },
+    "@typescript-eslint/parser": {
+      "version": "5.47.1",
+      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-5.47.1.tgz",
+      "integrity": "sha512-9Vb+KIv29r6GPu4EboWOnQM7T+UjpjXvjCPhNORlgm40a9Ia9bvaPJswvtae1gip2QEeVeGh6YquqAzEgoRAlw==",
+      "dev": true,
+      "requires": {
+        "@typescript-eslint/scope-manager": "5.47.1",
+        "@typescript-eslint/types": "5.47.1",
+        "@typescript-eslint/typescript-estree": "5.47.1",
+        "debug": "^4.3.4"
+      }
+    },
+    "@typescript-eslint/scope-manager": {
+      "version": "5.47.1",
+      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-5.47.1.tgz",
+      "integrity": "sha512-9hsFDsgUwrdOoW1D97Ewog7DYSHaq4WKuNs0LHF9RiCmqB0Z+XRR4Pf7u7u9z/8CciHuJ6yxNws1XznI3ddjEw==",
+      "dev": true,
+      "requires": {
+        "@typescript-eslint/types": "5.47.1",
+        "@typescript-eslint/visitor-keys": "5.47.1"
+      }
+    },
+    "@typescript-eslint/types": {
+      "version": "5.47.1",
+      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-5.47.1.tgz",
+      "integrity": "sha512-CmALY9YWXEpwuu6377ybJBZdtSAnzXLSQcxLSqSQSbC7VfpMu/HLVdrnVJj7ycI138EHqocW02LPJErE35cE9A==",
+      "dev": true
+    },
+    "@typescript-eslint/typescript-estree": {
+      "version": "5.47.1",
+      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-5.47.1.tgz",
+      "integrity": "sha512-4+ZhFSuISAvRi2xUszEj0xXbNTHceV9GbH9S8oAD2a/F9SW57aJNQVOCxG8GPfSWH/X4eOPdMEU2jYVuWKEpWA==",
+      "dev": true,
+      "requires": {
+        "@typescript-eslint/types": "5.47.1",
+        "@typescript-eslint/visitor-keys": "5.47.1",
+        "debug": "^4.3.4",
+        "globby": "^11.1.0",
+        "is-glob": "^4.0.3",
+        "semver": "^7.3.7",
+        "tsutils": "^3.21.0"
+      },
+      "dependencies": {
+        "semver": {
+          "version": "7.3.8",
+          "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.8.tgz",
+          "integrity": "sha512-NB1ctGL5rlHrPJtFDVIVzTyQylMLu9N9VICA6HSFJo8MCGVTMW6gfpicwKmmK/dAjTOrqu5l63JJOpDSrAis3A==",
+          "dev": true,
+          "requires": {
+            "lru-cache": "^6.0.0"
+          }
+        }
+      }
+    },
+    "@typescript-eslint/visitor-keys": {
+      "version": "5.47.1",
+      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-5.47.1.tgz",
+      "integrity": "sha512-rF3pmut2JCCjh6BLRhNKdYjULMb1brvoaiWDlHfLNVgmnZ0sBVJrs3SyaKE1XoDDnJuAx/hDQryHYmPUuNq0ig==",
+      "dev": true,
+      "requires": {
+        "@typescript-eslint/types": "5.47.1",
+        "eslint-visitor-keys": "^3.3.0"
+      }
+    },
+    "acorn": {
+      "version": "6.4.2",
+      "resolved": "https://registry.npmjs.org/acorn/-/acorn-6.4.2.tgz",
+      "integrity": "sha512-XtGIhXwF8YM8bJhGxG5kXgjkEuNGLTkoYqVE+KMR+aspr4KGYmKYg7yUe3KghyQ9yheNwLnjmzh/7+gfDBmHCQ==",
+      "dev": true
+    },
+    "acorn-dynamic-import": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/acorn-dynamic-import/-/acorn-dynamic-import-4.0.0.tgz",
+      "integrity": "sha512-d3OEjQV4ROpoflsnUA8HozoIR504TFxNivYEUi6uwz0IYhBkTDXGuWlNdMtybRt3nqVx/L6XqMt0FxkXuWKZhw==",
+      "dev": true,
+      "requires": {}
+    },
+    "acorn-jsx": {
+      "version": "5.3.2",
+      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
+      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
+      "dev": true,
+      "requires": {}
+    },
+    "aggregate-error": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/aggregate-error/-/aggregate-error-3.1.0.tgz",
+      "integrity": "sha512-4I7Td01quW/RpocfNayFdFVk1qSuoh0E7JrbRJ16nH01HhKFQ88INq9Sd+nd72zqRySlr9BmDA8xlEJ6vJMrYA==",
+      "dev": true,
+      "requires": {
+        "clean-stack": "^2.0.0",
+        "indent-string": "^4.0.0"
+      }
+    },
+    "ajv": {
+      "version": "6.12.6",
+      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
+      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
+      "dev": true,
+      "requires": {
+        "fast-deep-equal": "^3.1.1",
+        "fast-json-stable-stringify": "^2.0.0",
+        "json-schema-traverse": "^0.4.1",
+        "uri-js": "^4.2.2"
+      }
+    },
+    "ansi-colors": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.1.tgz",
+      "integrity": "sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA==",
+      "dev": true
+    },
+    "ansi-escapes": {
+      "version": "4.3.2",
+      "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-4.3.2.tgz",
+      "integrity": "sha512-gKXj5ALrKWQLsYG9jlTRmR/xKluxHV+Z9QEwNIgCfM1/uwPMCuzVVnh5mwTd+OuBZcwSIMbqssNWRm1lE51QaQ==",
+      "dev": true,
+      "requires": {
+        "type-fest": "^0.21.3"
+      },
+      "dependencies": {
+        "type-fest": {
+          "version": "0.21.3",
+          "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.21.3.tgz",
+          "integrity": "sha512-t0rzBq87m3fVcduHDUFhKmyyX+9eo6WQjZvf51Ea/M0Q7+T374Jp1aUiyUl0GKxp8M/OETVHSDvmkyPgvX+X2w==",
+          "dev": true
+        }
+      }
+    },
+    "ansi-regex": {
+      "version": "5.0.1",
+      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
+      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
+      "dev": true
+    },
+    "ansi-styles": {
+      "version": "3.2.1",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
+      "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
+      "dev": true,
+      "requires": {
+        "color-convert": "^1.9.0"
+      }
+    },
+    "anymatch": {
+      "version": "3.1.3",
+      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
+      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
+      "dev": true,
+      "requires": {
+        "normalize-path": "^3.0.0",
+        "picomatch": "^2.0.4"
+      }
+    },
+    "argparse": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
+      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
+      "dev": true
+    },
+    "array-union": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz",
+      "integrity": "sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==",
+      "dev": true
+    },
+    "assert": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/assert/-/assert-2.0.0.tgz",
+      "integrity": "sha512-se5Cd+js9dXJnu6Ag2JFc00t+HmHOen+8Q+L7O9zI0PqQXr20uk2J0XQqMxZEeo5U50o8Nvmmx7dZrl+Ufr35A==",
+      "requires": {
+        "es6-object-assign": "^1.1.0",
+        "is-nan": "^1.2.1",
+        "object-is": "^1.0.1",
+        "util": "^0.12.0"
+      }
+    },
+    "ast-types": {
+      "version": "0.16.1",
+      "resolved": "https://registry.npmjs.org/ast-types/-/ast-types-0.16.1.tgz",
+      "integrity": "sha512-6t10qk83GOG8p0vKmaCr8eiilZwO171AvbROMtvvNiwrTly62t+7XkA8RdIIVbpMhCASAsxgAzdRSwh6nw/5Dg==",
+      "requires": {
+        "tslib": "^2.0.1"
+      }
+    },
+    "astral-regex": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/astral-regex/-/astral-regex-2.0.0.tgz",
+      "integrity": "sha512-Z7tMw1ytTXt5jqMcOP+OQteU1VuNK9Y02uuJtKQ1Sv69jXQKKg5cibLwGJow8yzZP+eAc18EmLGPal0bp36rvQ==",
+      "dev": true
+    },
+    "available-typed-arrays": {
+      "version": "1.0.5",
+      "resolved": "https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.5.tgz",
+      "integrity": "sha512-DMD0KiN46eipeziST1LPP/STfDU0sufISXmjSgvVsoU2tqxctQeASejWcfNtxYKqETM1UxQ8sp2OrSBWpHY6sw=="
+    },
+    "babel-plugin-polyfill-corejs2": {
+      "version": "0.3.3",
+      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs2/-/babel-plugin-polyfill-corejs2-0.3.3.tgz",
+      "integrity": "sha512-8hOdmFYFSZhqg2C/JgLUQ+t52o5nirNwaWM2B9LWteozwIvM14VSwdsCAUET10qT+kmySAlseadmfeeSWFCy+Q==",
+      "dev": true,
+      "requires": {
+        "@babel/compat-data": "^7.17.7",
+        "@babel/helper-define-polyfill-provider": "^0.3.3",
+        "semver": "^6.1.1"
+      },
+      "dependencies": {
+        "semver": {
+          "version": "6.3.0",
+          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
+          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
+          "dev": true
+        }
+      }
+    },
+    "babel-plugin-polyfill-corejs3": {
+      "version": "0.6.0",
+      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-corejs3/-/babel-plugin-polyfill-corejs3-0.6.0.tgz",
+      "integrity": "sha512-+eHqR6OPcBhJOGgsIar7xoAB1GcSwVUA3XjAd7HJNzOXT4wv6/H7KIdA/Nc60cvUlDbKApmqNvD1B1bzOt4nyA==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-define-polyfill-provider": "^0.3.3",
+        "core-js-compat": "^3.25.1"
+      }
+    },
+    "babel-plugin-polyfill-regenerator": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/babel-plugin-polyfill-regenerator/-/babel-plugin-polyfill-regenerator-0.4.1.tgz",
+      "integrity": "sha512-NtQGmyQDXjQqQ+IzRkBVwEOz9lQ4zxAQZgoAYEtU9dJjnl1Oc98qnN7jcp+bE7O7aYzVpavXE3/VKXNzUbh7aw==",
+      "dev": true,
+      "requires": {
+        "@babel/helper-define-polyfill-provider": "^0.3.3"
+      }
+    },
+    "babylon": {
+      "version": "6.18.0",
+      "resolved": "https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz",
+      "integrity": "sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ==",
+      "dev": true
+    },
+    "balanced-match": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz",
+      "integrity": "sha1-ibTRmasr7kneFk6gK4nORi1xt2c=",
+      "dev": true
+    },
+    "binary-extensions": {
+      "version": "2.2.0",
+      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.2.0.tgz",
+      "integrity": "sha512-jDctJ/IVQbZoJykoeHbhXpOlNBqGNcwXJKJog42E5HDPUwQTSdjCHdihjj0DlnheQ7blbT6dHOafNAiS8ooQKA==",
+      "dev": true
+    },
+    "brace-expansion": {
+      "version": "1.1.11",
+      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
+      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
+      "dev": true,
+      "requires": {
+        "balanced-match": "^1.0.0",
+        "concat-map": "0.0.1"
+      }
+    },
+    "braces": {
+      "version": "3.0.2",
+      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
+      "integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
+      "dev": true,
+      "requires": {
+        "fill-range": "^7.0.1"
+      }
+    },
+    "browser-stdout": {
+      "version": "1.3.1",
+      "resolved": "https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz",
+      "integrity": "sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==",
+      "dev": true
+    },
+    "browserslist": {
+      "version": "4.21.4",
+      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.21.4.tgz",
+      "integrity": "sha512-CBHJJdDmgjl3daYjN5Cp5kbTf1mUhZoS+beLklHIvkOWscs83YAhLlF3Wsh/lciQYAcbBJgTOD44VtG31ZM4Hw==",
+      "dev": true,
+      "requires": {
+        "caniuse-lite": "^1.0.30001400",
+        "electron-to-chromium": "^1.4.251",
+        "node-releases": "^2.0.6",
+        "update-browserslist-db": "^1.0.9"
+      }
+    },
+    "call-bind": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.2.tgz",
+      "integrity": "sha512-7O+FbCihrB5WGbFYesctwmTKae6rOiIzmz1icreWJ+0aA7LJfuqhEso2T9ncpcFtzMQtzXf2QGGueWJGTYsqrA==",
+      "requires": {
+        "function-bind": "^1.1.1",
+        "get-intrinsic": "^1.0.2"
+      }
+    },
+    "callsites": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
+      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
+      "dev": true
+    },
+    "camelcase": {
+      "version": "6.2.0",
+      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-6.2.0.tgz",
+      "integrity": "sha512-c7wVvbw3f37nuobQNtgsgG9POC9qMbNuMQmTCqZv23b6MIz0fcYpBiOlv9gEN/hdLdnZTDQhg6e9Dq5M1vKvfg==",
+      "dev": true
+    },
+    "caniuse-lite": {
+      "version": "1.0.30001439",
+      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001439.tgz",
+      "integrity": "sha512-1MgUzEkoMO6gKfXflStpYgZDlFM7M/ck/bgfVCACO5vnAf0fXoNVHdWtqGU+MYca+4bL9Z5bpOVmR33cWW9G2A==",
+      "dev": true
+    },
+    "chalk": {
+      "version": "2.4.2",
+      "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
+      "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
+      "dev": true,
+      "requires": {
+        "ansi-styles": "^3.2.1",
+        "escape-string-regexp": "^1.0.5",
+        "supports-color": "^5.3.0"
+      }
+    },
+    "chokidar": {
+      "version": "3.5.3",
+      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.5.3.tgz",
+      "integrity": "sha512-Dr3sfKRP6oTcjf2JmUmFJfeVMvXBdegxB0iVQ5eb2V10uFJUCAS8OByZdVAyVb8xXNz3GjjTgj9kLWsZTqE6kw==",
+      "dev": true,
+      "requires": {
+        "anymatch": "~3.1.2",
+        "braces": "~3.0.2",
+        "fsevents": "~2.3.2",
+        "glob-parent": "~5.1.2",
+        "is-binary-path": "~2.1.0",
+        "is-glob": "~4.0.1",
+        "normalize-path": "~3.0.0",
+        "readdirp": "~3.6.0"
+      }
+    },
+    "clean-stack": {
+      "version": "2.2.0",
+      "resolved": "https://registry.npmjs.org/clean-stack/-/clean-stack-2.2.0.tgz",
+      "integrity": "sha512-4diC9HaTE+KRAMWhDhrGOECgWZxoevMc5TlkObMqNSsVU62PYzXZ/SMTjzyGAFF1YusgxGcSWTEXBhp0CPwQ1A==",
+      "dev": true
+    },
+    "cli-cursor": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-3.1.0.tgz",
+      "integrity": "sha512-I/zHAwsKf9FqGoXM4WWRACob9+SNukZTd94DWF57E4toouRulbCxcUh6RKUEOQlYTHJnzkPMySvPNaaSLNfLZw==",
+      "dev": true,
+      "requires": {
+        "restore-cursor": "^3.1.0"
+      }
+    },
+    "cli-truncate": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/cli-truncate/-/cli-truncate-3.1.0.tgz",
+      "integrity": "sha512-wfOBkjXteqSnI59oPcJkcPl/ZmwvMMOj340qUIY1SKZCv0B9Cf4D4fAucRkIKQmsIuYK3x1rrgU7MeGRruiuiA==",
+      "dev": true,
+      "requires": {
+        "slice-ansi": "^5.0.0",
+        "string-width": "^5.0.0"
+      },
+      "dependencies": {
+        "ansi-regex": {
+          "version": "6.0.1",
+          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.0.1.tgz",
+          "integrity": "sha512-n5M855fKb2SsfMIiFFoVrABHJC8QtHwVx+mHWP3QcEqBHYienj5dHSgjbxtC0WEZXYt4wcD6zrQElDPhFuZgfA==",
+          "dev": true
+        },
+        "ansi-styles": {
+          "version": "6.1.0",
+          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.1.0.tgz",
+          "integrity": "sha512-VbqNsoz55SYGczauuup0MFUyXNQviSpFTj1RQtFzmQLk18qbVSpTFFGMT293rmDaQuKCT6InmbuEyUne4mTuxQ==",
+          "dev": true
+        },
+        "emoji-regex": {
+          "version": "9.2.2",
+          "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
+          "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
+          "dev": true
+        },
+        "is-fullwidth-code-point": {
+          "version": "4.0.0",
+          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-4.0.0.tgz",
+          "integrity": "sha512-O4L094N2/dZ7xqVdrXhh9r1KODPJpFms8B5sGdJLPy664AgvXsreZUyCQQNItZRDlYug4xStLjNp/sz3HvBowQ==",
+          "dev": true
+        },
+        "slice-ansi": {
+          "version": "5.0.0",
+          "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-5.0.0.tgz",
+          "integrity": "sha512-FC+lgizVPfie0kkhqUScwRu1O/lF6NOgJmlCgK+/LYxDCTk8sGelYaHDhFcDN+Sn3Cv+3VSa4Byeo+IMCzpMgQ==",
+          "dev": true,
+          "requires": {
+            "ansi-styles": "^6.0.0",
+            "is-fullwidth-code-point": "^4.0.0"
+          }
+        },
+        "string-width": {
+          "version": "5.1.2",
+          "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
+          "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
+          "dev": true,
+          "requires": {
+            "eastasianwidth": "^0.2.0",
+            "emoji-regex": "^9.2.2",
+            "strip-ansi": "^7.0.1"
+          }
+        },
+        "strip-ansi": {
+          "version": "7.0.1",
+          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.0.1.tgz",
+          "integrity": "sha512-cXNxvT8dFNRVfhVME3JAe98mkXDYN2O1l7jmcwMnOslDeESg1rF/OZMtK0nRAhiari1unG5cD4jG3rapUAkLbw==",
+          "dev": true,
+          "requires": {
+            "ansi-regex": "^6.0.1"
+          }
+        }
+      }
+    },
+    "cliui": {
+      "version": "7.0.4",
+      "resolved": "https://registry.npmjs.org/cliui/-/cliui-7.0.4.tgz",
+      "integrity": "sha512-OcRE68cOsVMXp1Yvonl/fzkQOyjLSu/8bhPDfQt0e0/Eb283TKP20Fs2MqoPsr9SwA595rRCA+QMzYc9nBP+JQ==",
+      "dev": true,
+      "requires": {
+        "string-width": "^4.2.0",
+        "strip-ansi": "^6.0.0",
+        "wrap-ansi": "^7.0.0"
+      }
+    },
+    "color-convert": {
+      "version": "1.9.3",
+      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
+      "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
+      "dev": true,
+      "requires": {
+        "color-name": "1.1.3"
+      }
+    },
+    "color-name": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
+      "integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
+      "dev": true
+    },
+    "colorette": {
+      "version": "2.0.20",
+      "resolved": "https://registry.npmjs.org/colorette/-/colorette-2.0.20.tgz",
+      "integrity": "sha512-IfEDxwoWIjkeXL1eXcDiow4UbKjhLdq6/EuSVR9GMN7KVH3r9gQ83e73hsz1Nd1T3ijd5xv1wcWRYO+D6kCI2w==",
+      "dev": true
+    },
+    "commander": {
+      "version": "10.0.1",
+      "resolved": "https://registry.npmjs.org/commander/-/commander-10.0.1.tgz",
+      "integrity": "sha512-y4Mg2tXshplEbSGzx7amzPwKKOCGuoSRP/CjEdwwk0FOGlUbq6lKuoyDZTNZkmxHdJtp54hdfY/JUrdL7Xfdug==",
+      "dev": true
+    },
+    "concat-map": {
+      "version": "0.0.1",
+      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
+      "integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=",
+      "dev": true
+    },
+    "convert-source-map": {
+      "version": "1.8.0",
+      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-1.8.0.tgz",
+      "integrity": "sha512-+OQdjP49zViI/6i7nIJpA8rAl4sV/JdPfU9nZs3VqOwGIgizICvuN2ru6fMd+4llL0tar18UYJXfZ/TWtmhUjA==",
+      "dev": true,
+      "requires": {
+        "safe-buffer": "~5.1.1"
+      }
+    },
+    "core-js-compat": {
+      "version": "3.26.1",
+      "resolved": "https://registry.npmjs.org/core-js-compat/-/core-js-compat-3.26.1.tgz",
+      "integrity": "sha512-622/KzTudvXCDLRw70iHW4KKs1aGpcRcowGWyYJr2DEBfRrd6hNJybxSWJFuZYD4ma86xhrwDDHxmDaIq4EA8A==",
+      "dev": true,
+      "requires": {
+        "browserslist": "^4.21.4"
+      }
+    },
+    "cross-spawn": {
+      "version": "7.0.3",
+      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
+      "integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
+      "dev": true,
+      "requires": {
+        "path-key": "^3.1.0",
+        "shebang-command": "^2.0.0",
+        "which": "^2.0.1"
+      }
+    },
+    "debug": {
+      "version": "4.3.4",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.4.tgz",
+      "integrity": "sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==",
+      "dev": true,
+      "requires": {
+        "ms": "2.1.2"
+      }
+    },
+    "decamelize": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/decamelize/-/decamelize-4.0.0.tgz",
+      "integrity": "sha512-9iE1PgSik9HeIIw2JO94IidnE3eBoQrFJ3w7sFuzSX4DpmZ3v5sZpUiV5Swcf6mQEF+Y0ru8Neo+p+nyh2J+hQ==",
+      "dev": true
+    },
+    "deep-is": {
+      "version": "0.1.3",
+      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.3.tgz",
+      "integrity": "sha1-s2nW+128E+7PUk+RsHD+7cNXzzQ=",
+      "dev": true
+    },
+    "define-properties": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/define-properties/-/define-properties-1.1.3.tgz",
+      "integrity": "sha512-3MqfYKj2lLzdMSf8ZIZE/V+Zuy+BgD6f164e8K2w7dgnpKArBDerGYpM46IYYcjnkdPNMjPk9A6VFB8+3SKlXQ==",
+      "requires": {
+        "object-keys": "^1.0.12"
+      }
+    },
+    "diff": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/diff/-/diff-5.0.0.tgz",
+      "integrity": "sha512-/VTCrvm5Z0JGty/BWHljh+BAiw3IK+2j87NGMu8Nwc/f48WoDAC395uomO9ZD117ZOBaHmkX1oyLvkVM/aIT3w==",
+      "dev": true
+    },
+    "dir-glob": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz",
+      "integrity": "sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==",
+      "dev": true,
+      "requires": {
+        "path-type": "^4.0.0"
+      }
+    },
+    "doctrine": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
+      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
+      "dev": true,
+      "requires": {
+        "esutils": "^2.0.2"
+      }
+    },
+    "eastasianwidth": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
+      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
+      "dev": true
+    },
+    "electron-to-chromium": {
+      "version": "1.4.284",
+      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.4.284.tgz",
+      "integrity": "sha512-M8WEXFuKXMYMVr45fo8mq0wUrrJHheiKZf6BArTKk9ZBYCKJEOU5H8cdWgDT+qCVZf7Na4lVUaZsA+h6uA9+PA==",
+      "dev": true
+    },
+    "emoji-regex": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
+      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
+      "dev": true
+    },
+    "es6-object-assign": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/es6-object-assign/-/es6-object-assign-1.1.0.tgz",
+      "integrity": "sha512-MEl9uirslVwqQU369iHNWZXsI8yaZYGg/D65aOgZkeyFJwHYSxilf7rQzXKI7DdDuBPrBXbfk3sl9hJhmd5AUw=="
+    },
+    "escalade": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.1.1.tgz",
+      "integrity": "sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==",
+      "dev": true
+    },
+    "escape-string-regexp": {
+      "version": "1.0.5",
+      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
+      "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
+      "dev": true
+    },
+    "eslint": {
+      "version": "8.40.0",
+      "resolved": "https://registry.npmjs.org/eslint/-/eslint-8.40.0.tgz",
+      "integrity": "sha512-bvR+TsP9EHL3TqNtj9sCNJVAFK3fBN8Q7g5waghxyRsPLIMwL73XSKnZFK0hk/O2ANC+iAoq6PWMQ+IfBAJIiQ==",
+      "dev": true,
+      "requires": {
+        "@eslint-community/eslint-utils": "^4.2.0",
+        "@eslint-community/regexpp": "^4.4.0",
+        "@eslint/eslintrc": "^2.0.3",
+        "@eslint/js": "8.40.0",
+        "@humanwhocodes/config-array": "^0.11.8",
+        "@humanwhocodes/module-importer": "^1.0.1",
+        "@nodelib/fs.walk": "^1.2.8",
+        "ajv": "^6.10.0",
+        "chalk": "^4.0.0",
+        "cross-spawn": "^7.0.2",
+        "debug": "^4.3.2",
+        "doctrine": "^3.0.0",
+        "escape-string-regexp": "^4.0.0",
+        "eslint-scope": "^7.2.0",
+        "eslint-visitor-keys": "^3.4.1",
+        "espree": "^9.5.2",
+        "esquery": "^1.4.2",
+        "esutils": "^2.0.2",
+        "fast-deep-equal": "^3.1.3",
+        "file-entry-cache": "^6.0.1",
+        "find-up": "^5.0.0",
+        "glob-parent": "^6.0.2",
+        "globals": "^13.19.0",
+        "grapheme-splitter": "^1.0.4",
+        "ignore": "^5.2.0",
+        "import-fresh": "^3.0.0",
+        "imurmurhash": "^0.1.4",
+        "is-glob": "^4.0.0",
+        "is-path-inside": "^3.0.3",
+        "js-sdsl": "^4.1.4",
+        "js-yaml": "^4.1.0",
+        "json-stable-stringify-without-jsonify": "^1.0.1",
+        "levn": "^0.4.1",
+        "lodash.merge": "^4.6.2",
+        "minimatch": "^3.1.2",
+        "natural-compare": "^1.4.0",
+        "optionator": "^0.9.1",
+        "strip-ansi": "^6.0.1",
+        "strip-json-comments": "^3.1.0",
+        "text-table": "^0.2.0"
+      },
+      "dependencies": {
+        "ansi-styles": {
+          "version": "4.3.0",
+          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+          "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+          "dev": true,
+          "requires": {
+            "color-convert": "^2.0.1"
+          }
+        },
+        "chalk": {
+          "version": "4.1.1",
+          "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.1.tgz",
+          "integrity": "sha512-diHzdDKxcU+bAsUboHLPEDQiw0qEe0qd7SYUn3HgcFlWgbDcfLGswOHYeGrHKzG9z6UYf01d9VFMfZxPM1xZSg==",
+          "dev": true,
+          "requires": {
+            "ansi-styles": "^4.1.0",
+            "supports-color": "^7.1.0"
+          }
+        },
+        "color-convert": {
+          "version": "2.0.1",
+          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+          "dev": true,
+          "requires": {
+            "color-name": "~1.1.4"
+          }
+        },
+        "color-name": {
+          "version": "1.1.4",
+          "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+          "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+          "dev": true
+        },
+        "escape-string-regexp": {
+          "version": "4.0.0",
+          "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
+          "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
+          "dev": true
+        },
+        "glob-parent": {
+          "version": "6.0.2",
+          "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
+          "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
+          "dev": true,
+          "requires": {
+            "is-glob": "^4.0.3"
+          }
+        },
+        "globals": {
+          "version": "13.20.0",
+          "resolved": "https://registry.npmjs.org/globals/-/globals-13.20.0.tgz",
+          "integrity": "sha512-Qg5QtVkCy/kv3FUSlu4ukeZDVf9ee0iXLAUYX13gbR17bnejFTzr4iS9bY7kwCf1NztRNm1t91fjOiyx4CSwPQ==",
+          "dev": true,
+          "requires": {
+            "type-fest": "^0.20.2"
+          }
+        },
+        "has-flag": {
+          "version": "4.0.0",
+          "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
+          "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
+          "dev": true
+        },
+        "supports-color": {
+          "version": "7.2.0",
+          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
+          "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
+          "dev": true,
+          "requires": {
+            "has-flag": "^4.0.0"
+          }
+        }
+      }
+    },
+    "eslint-scope": {
+      "version": "7.2.0",
+      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-7.2.0.tgz",
+      "integrity": "sha512-DYj5deGlHBfMt15J7rdtyKNq/Nqlv5KfU4iodrQ019XESsRnwXH9KAE0y3cwtUHDo2ob7CypAnCqefh6vioWRw==",
+      "dev": true,
+      "requires": {
+        "esrecurse": "^4.3.0",
+        "estraverse": "^5.2.0"
+      }
+    },
+    "eslint-visitor-keys": {
+      "version": "3.4.1",
+      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.1.tgz",
+      "integrity": "sha512-pZnmmLwYzf+kWaM/Qgrvpen51upAktaaiI01nsJD/Yr3lMOdNtq0cxkrrg16w64VtisN6okbs7Q8AfGqj4c9fA==",
+      "dev": true
+    },
+    "espree": {
+      "version": "9.5.2",
+      "resolved": "https://registry.npmjs.org/espree/-/espree-9.5.2.tgz",
+      "integrity": "sha512-7OASN1Wma5fum5SrNhFMAMJxOUAbhyfQ8dQ//PJaJbNw0URTPWqIghHWt1MmAANKhHZIYOHruW4Kw4ruUWOdGw==",
+      "dev": true,
+      "requires": {
+        "acorn": "^8.8.0",
+        "acorn-jsx": "^5.3.2",
+        "eslint-visitor-keys": "^3.4.1"
+      },
+      "dependencies": {
+        "acorn": {
+          "version": "8.8.2",
+          "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.8.2.tgz",
+          "integrity": "sha512-xjIYgE8HBrkpd/sJqOGNspf8uHG+NOHGOw6a/Urj8taM2EXfdNAH2oFcPeIFfsv3+kz/mJrS5VuMqbNLjCa2vw==",
+          "dev": true
+        }
+      }
+    },
+    "esprima": {
+      "version": "4.0.1",
+      "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
+      "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A=="
+    },
+    "esprima-fb": {
+      "version": "15001.1001.0-dev-harmony-fb",
+      "resolved": "https://registry.npmjs.org/esprima-fb/-/esprima-fb-15001.1001.0-dev-harmony-fb.tgz",
+      "integrity": "sha1-Q761fsJujPI3092LM+QlM1d/Jlk=",
+      "dev": true
+    },
+    "esquery": {
+      "version": "1.5.0",
+      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.5.0.tgz",
+      "integrity": "sha512-YQLXUplAwJgCydQ78IMJywZCceoqk1oH01OERdSAJc/7U2AylwjhSCLDEtqwg811idIS/9fIU5GjG73IgjKMVg==",
+      "dev": true,
+      "requires": {
+        "estraverse": "^5.1.0"
+      }
+    },
+    "esrecurse": {
+      "version": "4.3.0",
+      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
+      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
+      "dev": true,
+      "requires": {
+        "estraverse": "^5.2.0"
+      }
+    },
+    "estraverse": {
+      "version": "5.3.0",
+      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
+      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
+      "dev": true
+    },
+    "esutils": {
+      "version": "2.0.3",
+      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
+      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
+      "dev": true
+    },
+    "execa": {
+      "version": "7.1.1",
+      "resolved": "https://registry.npmjs.org/execa/-/execa-7.1.1.tgz",
+      "integrity": "sha512-wH0eMf/UXckdUYnO21+HDztteVv05rq2GXksxT4fCGeHkBhw1DROXh40wcjMcRqDOWE7iPJ4n3M7e2+YFP+76Q==",
+      "dev": true,
+      "requires": {
+        "cross-spawn": "^7.0.3",
+        "get-stream": "^6.0.1",
+        "human-signals": "^4.3.0",
+        "is-stream": "^3.0.0",
+        "merge-stream": "^2.0.0",
+        "npm-run-path": "^5.1.0",
+        "onetime": "^6.0.0",
+        "signal-exit": "^3.0.7",
+        "strip-final-newline": "^3.0.0"
+      }
+    },
+    "fast-deep-equal": {
+      "version": "3.1.3",
+      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
+      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
+      "dev": true
+    },
+    "fast-glob": {
+      "version": "3.2.12",
+      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.2.12.tgz",
+      "integrity": "sha512-DVj4CQIYYow0BlaelwK1pHl5n5cRSJfM60UA0zK891sVInoPri2Ekj7+e1CT3/3qxXenpI+nBBmQAcJPJgaj4w==",
+      "dev": true,
+      "requires": {
+        "@nodelib/fs.stat": "^2.0.2",
+        "@nodelib/fs.walk": "^1.2.3",
+        "glob-parent": "^5.1.2",
+        "merge2": "^1.3.0",
+        "micromatch": "^4.0.4"
+      }
+    },
+    "fast-json-stable-stringify": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
+      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
+      "dev": true
+    },
+    "fast-levenshtein": {
+      "version": "2.0.6",
+      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
+      "integrity": "sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=",
+      "dev": true
+    },
+    "fastq": {
+      "version": "1.14.0",
+      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.14.0.tgz",
+      "integrity": "sha512-eR2D+V9/ExcbF9ls441yIuN6TI2ED1Y2ZcA5BmMtJsOkWOFRJQ0Jt0g1UwqXJJVAb+V+umH5Dfr8oh4EVP7VVg==",
+      "dev": true,
+      "requires": {
+        "reusify": "^1.0.4"
+      }
+    },
+    "file-entry-cache": {
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz",
+      "integrity": "sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==",
+      "dev": true,
+      "requires": {
+        "flat-cache": "^3.0.4"
+      }
+    },
+    "fill-range": {
+      "version": "7.0.1",
+      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
+      "integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
+      "dev": true,
+      "requires": {
+        "to-regex-range": "^5.0.1"
+      }
+    },
+    "find-up": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
+      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
+      "dev": true,
+      "requires": {
+        "locate-path": "^6.0.0",
+        "path-exists": "^4.0.0"
+      }
+    },
+    "flat": {
+      "version": "5.0.2",
+      "resolved": "https://registry.npmjs.org/flat/-/flat-5.0.2.tgz",
+      "integrity": "sha512-b6suED+5/3rTpUBdG1gupIl8MPFCAMA0QXwmljLhvCUKcUvdE4gWky9zpuGCcXHOsz4J9wPGNWq6OKpmIzz3hQ==",
+      "dev": true
+    },
+    "flat-cache": {
+      "version": "3.0.4",
+      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-3.0.4.tgz",
+      "integrity": "sha512-dm9s5Pw7Jc0GvMYbshN6zchCA9RgQlzzEZX3vylR9IqFfS8XciblUXOKfW6SiuJ0e13eDYZoZV5wdrev7P3Nwg==",
+      "dev": true,
+      "requires": {
+        "flatted": "^3.1.0",
+        "rimraf": "^3.0.2"
+      }
+    },
+    "flatted": {
+      "version": "3.2.1",
+      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.2.1.tgz",
+      "integrity": "sha512-OMQjaErSFHmHqZe+PSidH5n8j3O0F2DdnVh8JB4j4eUQ2k6KvB0qGfrKIhapvez5JerBbmWkaLYUYWISaESoXg==",
+      "dev": true
+    },
+    "flow-parser": {
+      "version": "0.195.0",
+      "resolved": "https://registry.npmjs.org/flow-parser/-/flow-parser-0.195.0.tgz",
+      "integrity": "sha512-vO9b3GJQHHsRgwe2wB7lkKLhB+2Nw3QcpVKt/yYpoGVTJo51HS7GAvLE47XJ1u/5ILNQ41A+q+SZdyq+uRvkKQ==",
+      "dev": true
+    },
+    "for-each": {
+      "version": "0.3.3",
+      "resolved": "https://registry.npmjs.org/for-each/-/for-each-0.3.3.tgz",
+      "integrity": "sha512-jqYfLp7mo9vIyQf8ykW2v7A+2N4QjeCeI5+Dz9XraiO1ign81wjiH7Fb9vSOWvQfNtmSa4H2RoQTrrXivdUZmw==",
+      "requires": {
+        "is-callable": "^1.1.3"
+      }
+    },
+    "fs.realpath": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
+      "integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8=",
+      "dev": true
+    },
+    "fsevents": {
+      "version": "2.3.2",
+      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
+      "integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
+      "dev": true,
+      "optional": true
+    },
+    "function-bind": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
+      "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A=="
+    },
+    "gensync": {
+      "version": "1.0.0-beta.2",
+      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
+      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
+      "dev": true
+    },
+    "get-caller-file": {
+      "version": "2.0.5",
+      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
+      "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
+      "dev": true
+    },
+    "get-intrinsic": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.1.3.tgz",
+      "integrity": "sha512-QJVz1Tj7MS099PevUG5jvnt9tSkXN8K14dxQlikJuPt4uD9hHAHjLyLBiLR5zELelBdD9QNRAXZzsJx0WaDL9A==",
+      "requires": {
+        "function-bind": "^1.1.1",
+        "has": "^1.0.3",
+        "has-symbols": "^1.0.3"
+      }
+    },
+    "get-stream": {
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-6.0.1.tgz",
+      "integrity": "sha512-ts6Wi+2j3jQjqi70w5AlN8DFnkSwC+MqmxEzdEALB2qXZYV3X/b1CTfgPLGJNMeAWxdPfU8FO1ms3NUfaHCPYg==",
+      "dev": true
+    },
+    "glob": {
+      "version": "8.0.3",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-8.0.3.tgz",
+      "integrity": "sha512-ull455NHSHI/Y1FqGaaYFaLGkNMMJbavMrEGFXG/PGrg6y7sutWHUHrz6gy6WEBH6akM1M414dWKCNs+IhKdiQ==",
+      "dev": true,
+      "requires": {
+        "fs.realpath": "^1.0.0",
+        "inflight": "^1.0.4",
+        "inherits": "2",
+        "minimatch": "^5.0.1",
+        "once": "^1.3.0"
+      },
+      "dependencies": {
+        "brace-expansion": {
+          "version": "2.0.1",
+          "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz",
+          "integrity": "sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==",
+          "dev": true,
+          "requires": {
+            "balanced-match": "^1.0.0"
+          }
+        },
+        "minimatch": {
+          "version": "5.1.2",
+          "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-5.1.2.tgz",
+          "integrity": "sha512-bNH9mmM9qsJ2X4r2Nat1B//1dJVcn3+iBLa3IgqJ7EbGaDNepL9QSHOxN4ng33s52VMMhhIfgCYDk3C4ZmlDAg==",
+          "dev": true,
+          "requires": {
+            "brace-expansion": "^2.0.1"
+          }
+        }
+      }
+    },
+    "glob-parent": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
+      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
+      "dev": true,
+      "requires": {
+        "is-glob": "^4.0.1"
+      }
+    },
+    "globals": {
+      "version": "11.12.0",
+      "resolved": "https://registry.npmjs.org/globals/-/globals-11.12.0.tgz",
+      "integrity": "sha512-WOBp/EEGUiIsJSp7wcv/y6MO+lV9UoncWqxuFfm8eBwzWNgyfBd6Gz+IeKQ9jCmyhoH99g15M3T+QaVHFjizVA==",
+      "dev": true
+    },
+    "globby": {
+      "version": "11.1.0",
+      "resolved": "https://registry.npmjs.org/globby/-/globby-11.1.0.tgz",
+      "integrity": "sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==",
+      "dev": true,
+      "requires": {
+        "array-union": "^2.1.0",
+        "dir-glob": "^3.0.1",
+        "fast-glob": "^3.2.9",
+        "ignore": "^5.2.0",
+        "merge2": "^1.4.1",
+        "slash": "^3.0.0"
+      }
+    },
+    "gopd": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.0.1.tgz",
+      "integrity": "sha512-d65bNlIadxvpb/A2abVdlqKqV563juRnZ1Wtk6s1sIR8uNsXR70xqIzVqxVf1eTqDunwT2MkczEeaezCKTZhwA==",
+      "requires": {
+        "get-intrinsic": "^1.1.3"
+      }
+    },
+    "grapheme-splitter": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/grapheme-splitter/-/grapheme-splitter-1.0.4.tgz",
+      "integrity": "sha512-bzh50DW9kTPM00T8y4o8vQg89Di9oLJVLW/KaOGIXJWP/iqCN6WKYkbNOF04vFLJhwcpYUh9ydh/+5vpOqV4YQ==",
+      "dev": true
+    },
+    "has": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/has/-/has-1.0.3.tgz",
+      "integrity": "sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==",
+      "requires": {
+        "function-bind": "^1.1.1"
+      }
+    },
+    "has-flag": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
+      "integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
+      "dev": true
+    },
+    "has-symbols": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz",
+      "integrity": "sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A=="
+    },
+    "has-tostringtag": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.0.tgz",
+      "integrity": "sha512-kFjcSNhnlGV1kyoGk7OXKSawH5JOb/LzUc5w9B02hOTO0dfFRjbHQKvg1d6cf3HbeUmtU9VbbV3qzZ2Teh97WQ==",
+      "requires": {
+        "has-symbols": "^1.0.2"
+      }
+    },
+    "he": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/he/-/he-1.2.0.tgz",
+      "integrity": "sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw==",
+      "dev": true
+    },
+    "human-signals": {
+      "version": "4.3.1",
+      "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-4.3.1.tgz",
+      "integrity": "sha512-nZXjEF2nbo7lIw3mgYjItAfgQXog3OjJogSbKa2CQIIvSGWcKgeJnQlNXip6NglNzYH45nSRiEVimMvYL8DDqQ==",
+      "dev": true
+    },
+    "ignore": {
+      "version": "5.2.4",
+      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.2.4.tgz",
+      "integrity": "sha512-MAb38BcSbH0eHNBxn7ql2NH/kX33OkB3lZ1BNdh7ENeRChHTYsTvWrMubiIAMNS2llXEEgZ1MUOBtXChP3kaFQ==",
+      "dev": true
+    },
+    "import-fresh": {
+      "version": "3.3.0",
+      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz",
+      "integrity": "sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==",
+      "dev": true,
+      "requires": {
+        "parent-module": "^1.0.0",
+        "resolve-from": "^4.0.0"
+      }
+    },
+    "imurmurhash": {
+      "version": "0.1.4",
+      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
+      "integrity": "sha1-khi5srkoojixPcT7a21XbyMUU+o=",
+      "dev": true
+    },
+    "indent-string": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/indent-string/-/indent-string-4.0.0.tgz",
+      "integrity": "sha512-EdDDZu4A2OyIK7Lr/2zG+w5jmbuk1DVBnEwREQvBzspBJkCEbRa8GxU1lghYcaGJCnRWibjDXlq779X1/y5xwg==",
+      "dev": true
+    },
+    "inflight": {
+      "version": "1.0.6",
+      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
+      "integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
+      "dev": true,
+      "requires": {
+        "once": "^1.3.0",
+        "wrappy": "1"
+      }
+    },
+    "inherits": {
+      "version": "2.0.4",
+      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
+      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
+    },
+    "is-arguments": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/is-arguments/-/is-arguments-1.1.1.tgz",
+      "integrity": "sha512-8Q7EARjzEnKpt/PCD7e1cgUS0a6X8u5tdSiMqXhojOdoV9TsMsiO+9VLC5vAmO8N7/GmXn7yjR8qnA6bVAEzfA==",
+      "requires": {
+        "call-bind": "^1.0.2",
+        "has-tostringtag": "^1.0.0"
+      }
+    },
+    "is-binary-path": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
+      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
+      "dev": true,
+      "requires": {
+        "binary-extensions": "^2.0.0"
+      }
+    },
+    "is-callable": {
+      "version": "1.2.7",
+      "resolved": "https://registry.npmjs.org/is-callable/-/is-callable-1.2.7.tgz",
+      "integrity": "sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA=="
+    },
+    "is-core-module": {
+      "version": "2.11.0",
+      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.11.0.tgz",
+      "integrity": "sha512-RRjxlvLDkD1YJwDbroBHMb+cukurkDWNyHx7D3oNB5x9rb5ogcksMC5wHCadcXoo67gVr/+3GFySh3134zi6rw==",
+      "dev": true,
+      "requires": {
+        "has": "^1.0.3"
+      }
+    },
+    "is-extglob": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
+      "integrity": "sha1-qIwCU1eR8C7TfHahueqXc8gz+MI=",
+      "dev": true
+    },
+    "is-fullwidth-code-point": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
+      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
+      "dev": true
+    },
+    "is-generator-function": {
+      "version": "1.0.10",
+      "resolved": "https://registry.npmjs.org/is-generator-function/-/is-generator-function-1.0.10.tgz",
+      "integrity": "sha512-jsEjy9l3yiXEQ+PsXdmBwEPcOxaXWLspKdplFUVI9vq1iZgIekeC0L167qeu86czQaxed3q/Uzuw0swL0irL8A==",
+      "requires": {
+        "has-tostringtag": "^1.0.0"
+      }
+    },
+    "is-glob": {
+      "version": "4.0.3",
+      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
+      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
+      "dev": true,
+      "requires": {
+        "is-extglob": "^2.1.1"
+      }
+    },
+    "is-nan": {
+      "version": "1.3.2",
+      "resolved": "https://registry.npmjs.org/is-nan/-/is-nan-1.3.2.tgz",
+      "integrity": "sha512-E+zBKpQ2t6MEo1VsonYmluk9NxGrbzpeeLC2xIViuO2EjU2xsXsBPwTr3Ykv9l08UYEVEdWeRZNouaZqF6RN0w==",
+      "requires": {
+        "call-bind": "^1.0.0",
+        "define-properties": "^1.1.3"
+      }
+    },
+    "is-number": {
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
+      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
+      "dev": true
+    },
+    "is-path-inside": {
+      "version": "3.0.3",
+      "resolved": "https://registry.npmjs.org/is-path-inside/-/is-path-inside-3.0.3.tgz",
+      "integrity": "sha512-Fd4gABb+ycGAmKou8eMftCupSir5lRxqf4aD/vd0cD2qc4HL07OjCeuHMr8Ro4CoMaeCKDB0/ECBOVWjTwUvPQ==",
+      "dev": true
+    },
+    "is-plain-obj": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/is-plain-obj/-/is-plain-obj-2.1.0.tgz",
+      "integrity": "sha512-YWnfyRwxL/+SsrWYfOpUtz5b3YD+nyfkHvjbcanzk8zgyO4ASD67uVMRt8k5bM4lLMDnXfriRhOpemw+NfT1eA==",
+      "dev": true
+    },
+    "is-stream": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-3.0.0.tgz",
+      "integrity": "sha512-LnQR4bZ9IADDRSkvpqMGvt/tEJWclzklNgSw48V5EAaAeDd6qGvN8ei6k5p0tvxSR171VmGyHuTiAOfxAbr8kA==",
+      "dev": true
+    },
+    "is-typed-array": {
+      "version": "1.1.10",
+      "resolved": "https://registry.npmjs.org/is-typed-array/-/is-typed-array-1.1.10.tgz",
+      "integrity": "sha512-PJqgEHiWZvMpaFZ3uTc8kHPM4+4ADTlDniuQL7cU/UDA0Ql7F70yGfHph3cLNe+c9toaigv+DFzTJKhc2CtO6A==",
+      "requires": {
+        "available-typed-arrays": "^1.0.5",
+        "call-bind": "^1.0.2",
+        "for-each": "^0.3.3",
+        "gopd": "^1.0.1",
+        "has-tostringtag": "^1.0.0"
+      }
+    },
+    "is-unicode-supported": {
+      "version": "0.1.0",
+      "resolved": "https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz",
+      "integrity": "sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==",
+      "dev": true
+    },
+    "isexe": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
+      "integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=",
+      "dev": true
+    },
+    "js-sdsl": {
+      "version": "4.4.0",
+      "resolved": "https://registry.npmjs.org/js-sdsl/-/js-sdsl-4.4.0.tgz",
+      "integrity": "sha512-FfVSdx6pJ41Oa+CF7RDaFmTnCaFhua+SNYQX74riGOpl96x+2jQCqEfQ2bnXu/5DPCqlRuiqyvTJM0Qjz26IVg==",
+      "dev": true
+    },
+    "js-tokens": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
+      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
+      "dev": true
+    },
+    "js-yaml": {
+      "version": "4.1.0",
+      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
+      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
+      "dev": true,
+      "requires": {
+        "argparse": "^2.0.1"
+      }
+    },
+    "jsesc": {
+      "version": "2.5.2",
+      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-2.5.2.tgz",
+      "integrity": "sha512-OYu7XEzjkCQ3C5Ps3QIZsQfNpqoJyZZA99wd9aWd05NCtC5pWOkShK2mkL6HXQR6/Cy2lbNdPlZBpuQHXE63gA==",
+      "dev": true
+    },
+    "json-schema-traverse": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
+      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
+      "dev": true
+    },
+    "json-stable-stringify-without-jsonify": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
+      "integrity": "sha1-nbe1lJatPzz+8wp1FC0tkwrXJlE=",
+      "dev": true
+    },
+    "json5": {
+      "version": "2.2.3",
+      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
+      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
+      "dev": true
+    },
+    "levn": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
+      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
+      "dev": true,
+      "requires": {
+        "prelude-ls": "^1.2.1",
+        "type-check": "~0.4.0"
+      }
+    },
+    "lilconfig": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/lilconfig/-/lilconfig-2.1.0.tgz",
+      "integrity": "sha512-utWOt/GHzuUxnLKxB6dk81RoOeoNeHgbrXiuGk4yyF5qlRz+iIVWu56E2fqGHFrXz0QNUhLB/8nKqvRH66JKGQ==",
+      "dev": true
+    },
+    "lint-staged": {
+      "version": "13.2.2",
+      "resolved": "https://registry.npmjs.org/lint-staged/-/lint-staged-13.2.2.tgz",
+      "integrity": "sha512-71gSwXKy649VrSU09s10uAT0rWCcY3aewhMaHyl2N84oBk4Xs9HgxvUp3AYu+bNsK4NrOYYxvSgg7FyGJ+jGcA==",
+      "dev": true,
+      "requires": {
+        "chalk": "5.2.0",
+        "cli-truncate": "^3.1.0",
+        "commander": "^10.0.0",
+        "debug": "^4.3.4",
+        "execa": "^7.0.0",
+        "lilconfig": "2.1.0",
+        "listr2": "^5.0.7",
+        "micromatch": "^4.0.5",
+        "normalize-path": "^3.0.0",
+        "object-inspect": "^1.12.3",
+        "pidtree": "^0.6.0",
+        "string-argv": "^0.3.1",
+        "yaml": "^2.2.2"
+      },
+      "dependencies": {
+        "chalk": {
+          "version": "5.2.0",
+          "resolved": "https://registry.npmjs.org/chalk/-/chalk-5.2.0.tgz",
+          "integrity": "sha512-ree3Gqw/nazQAPuJJEy+avdl7QfZMcUvmHIKgEZkGL+xOBzRvup5Hxo6LHuMceSxOabuJLJm5Yp/92R9eMmMvA==",
+          "dev": true
+        }
+      }
+    },
+    "listr2": {
+      "version": "5.0.8",
+      "resolved": "https://registry.npmjs.org/listr2/-/listr2-5.0.8.tgz",
+      "integrity": "sha512-mC73LitKHj9w6v30nLNGPetZIlfpUniNSsxxrbaPcWOjDb92SHPzJPi/t+v1YC/lxKz/AJ9egOjww0qUuFxBpA==",
+      "dev": true,
+      "requires": {
+        "cli-truncate": "^2.1.0",
+        "colorette": "^2.0.19",
+        "log-update": "^4.0.0",
+        "p-map": "^4.0.0",
+        "rfdc": "^1.3.0",
+        "rxjs": "^7.8.0",
+        "through": "^2.3.8",
+        "wrap-ansi": "^7.0.0"
+      },
+      "dependencies": {
+        "ansi-styles": {
+          "version": "4.3.0",
+          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+          "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+          "dev": true,
+          "requires": {
+            "color-convert": "^2.0.1"
+          }
+        },
+        "cli-truncate": {
+          "version": "2.1.0",
+          "resolved": "https://registry.npmjs.org/cli-truncate/-/cli-truncate-2.1.0.tgz",
+          "integrity": "sha512-n8fOixwDD6b/ObinzTrp1ZKFzbgvKZvuz/TvejnLn1aQfC6r52XEx85FmuC+3HI+JM7coBRXUvNqEU2PHVrHpg==",
+          "dev": true,
+          "requires": {
+            "slice-ansi": "^3.0.0",
+            "string-width": "^4.2.0"
+          }
+        },
+        "color-convert": {
+          "version": "2.0.1",
+          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+          "dev": true,
+          "requires": {
+            "color-name": "~1.1.4"
+          }
+        },
+        "color-name": {
+          "version": "1.1.4",
+          "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+          "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+          "dev": true
+        },
+        "slice-ansi": {
+          "version": "3.0.0",
+          "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-3.0.0.tgz",
+          "integrity": "sha512-pSyv7bSTC7ig9Dcgbw9AuRNUb5k5V6oDudjZoMBSr13qpLBG7tB+zgCkARjq7xIUgdz5P1Qe8u+rSGdouOOIyQ==",
+          "dev": true,
+          "requires": {
+            "ansi-styles": "^4.0.0",
+            "astral-regex": "^2.0.0",
+            "is-fullwidth-code-point": "^3.0.0"
+          }
+        }
+      }
+    },
+    "locate-path": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
+      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
+      "dev": true,
+      "requires": {
+        "p-locate": "^5.0.0"
+      }
+    },
+    "lodash.debounce": {
+      "version": "4.0.8",
+      "resolved": "https://registry.npmjs.org/lodash.debounce/-/lodash.debounce-4.0.8.tgz",
+      "integrity": "sha512-FT1yDzDYEoYWhnSGnpE/4Kj1fLZkDFyqRb7fNt6FdYOSxlUWAtp42Eh6Wb0rGIv/m9Bgo7x4GhQbm5Ys4SG5ow==",
+      "dev": true
+    },
+    "lodash.merge": {
+      "version": "4.6.2",
+      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
+      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
+      "dev": true
+    },
+    "log-update": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/log-update/-/log-update-4.0.0.tgz",
+      "integrity": "sha512-9fkkDevMefjg0mmzWFBW8YkFP91OrizzkW3diF7CpG+S2EYdy4+TVfGwz1zeF8x7hCx1ovSPTOE9Ngib74qqUg==",
+      "dev": true,
+      "requires": {
+        "ansi-escapes": "^4.3.0",
+        "cli-cursor": "^3.1.0",
+        "slice-ansi": "^4.0.0",
+        "wrap-ansi": "^6.2.0"
+      },
+      "dependencies": {
+        "ansi-styles": {
+          "version": "4.3.0",
+          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+          "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+          "dev": true,
+          "requires": {
+            "color-convert": "^2.0.1"
+          }
+        },
+        "color-convert": {
+          "version": "2.0.1",
+          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+          "dev": true,
+          "requires": {
+            "color-name": "~1.1.4"
+          }
+        },
+        "color-name": {
+          "version": "1.1.4",
+          "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+          "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+          "dev": true
+        },
+        "wrap-ansi": {
+          "version": "6.2.0",
+          "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-6.2.0.tgz",
+          "integrity": "sha512-r6lPcBGxZXlIcymEu7InxDMhdW0KDxpLgoFLcguasxCaJ/SOIZwINatK9KY/tf+ZrlywOKU0UDj3ATXUBfxJXA==",
+          "dev": true,
+          "requires": {
+            "ansi-styles": "^4.0.0",
+            "string-width": "^4.1.0",
+            "strip-ansi": "^6.0.0"
+          }
+        }
+      }
+    },
+    "lru-cache": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
+      "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
+      "dev": true,
+      "requires": {
+        "yallist": "^4.0.0"
+      }
+    },
+    "magic-string": {
+      "version": "0.25.7",
+      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.25.7.tgz",
+      "integrity": "sha512-4CrMT5DOHTDk4HYDlzmwu4FVCcIYI8gauveasrdCu2IKIFOJ3f0v/8MDGJCDL9oD2ppz/Av1b0Nj345H9M+XIA==",
+      "dev": true,
+      "requires": {
+        "sourcemap-codec": "^1.4.4"
+      }
+    },
+    "merge-stream": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
+      "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==",
+      "dev": true
+    },
+    "merge2": {
+      "version": "1.4.1",
+      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
+      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
+      "dev": true
+    },
+    "micromatch": {
+      "version": "4.0.5",
+      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.5.tgz",
+      "integrity": "sha512-DMy+ERcEW2q8Z2Po+WNXuw3c5YaUSFjAO5GsJqfEl7UjvtIuFKO6ZrKvcItdy98dwFI2N1tg3zNIdKaQT+aNdA==",
+      "dev": true,
+      "requires": {
+        "braces": "^3.0.2",
+        "picomatch": "^2.3.1"
+      }
+    },
+    "mimic-fn": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-4.0.0.tgz",
+      "integrity": "sha512-vqiC06CuhBTUdZH+RYl8sFrL096vA45Ok5ISO6sE/Mr1jRbGH4Csnhi8f3wKVl7x8mO4Au7Ir9D3Oyv1VYMFJw==",
+      "dev": true
+    },
+    "minimatch": {
+      "version": "3.1.2",
+      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
+      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
+      "dev": true,
+      "requires": {
+        "brace-expansion": "^1.1.7"
+      }
+    },
+    "mocha": {
+      "version": "10.2.0",
+      "resolved": "https://registry.npmjs.org/mocha/-/mocha-10.2.0.tgz",
+      "integrity": "sha512-IDY7fl/BecMwFHzoqF2sg/SHHANeBoMMXFlS9r0OXKDssYE1M5O43wUY/9BVPeIvfH2zmEbBfseqN9gBQZzXkg==",
+      "dev": true,
+      "requires": {
+        "ansi-colors": "4.1.1",
+        "browser-stdout": "1.3.1",
+        "chokidar": "3.5.3",
+        "debug": "4.3.4",
+        "diff": "5.0.0",
+        "escape-string-regexp": "4.0.0",
+        "find-up": "5.0.0",
+        "glob": "7.2.0",
+        "he": "1.2.0",
+        "js-yaml": "4.1.0",
+        "log-symbols": "4.1.0",
+        "minimatch": "5.0.1",
+        "ms": "2.1.3",
+        "nanoid": "3.3.3",
+        "serialize-javascript": "6.0.0",
+        "strip-json-comments": "3.1.1",
+        "supports-color": "8.1.1",
+        "workerpool": "6.2.1",
+        "yargs": "16.2.0",
+        "yargs-parser": "20.2.4",
+        "yargs-unparser": "2.0.0"
+      },
+      "dependencies": {
+        "ansi-styles": {
+          "version": "4.3.0",
+          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+          "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+          "dev": true,
+          "requires": {
+            "color-convert": "^2.0.1"
+          }
+        },
+        "chalk": {
+          "version": "4.1.1",
+          "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.1.tgz",
+          "integrity": "sha512-diHzdDKxcU+bAsUboHLPEDQiw0qEe0qd7SYUn3HgcFlWgbDcfLGswOHYeGrHKzG9z6UYf01d9VFMfZxPM1xZSg==",
+          "dev": true,
+          "requires": {
+            "ansi-styles": "^4.1.0",
+            "supports-color": "^7.1.0"
+          },
+          "dependencies": {
+            "supports-color": {
+              "version": "7.2.0",
+              "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
+              "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
+              "dev": true,
+              "requires": {
+                "has-flag": "^4.0.0"
+              }
+            }
+          }
+        },
+        "color-convert": {
+          "version": "2.0.1",
+          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+          "dev": true,
+          "requires": {
+            "color-name": "~1.1.4"
+          }
+        },
+        "color-name": {
+          "version": "1.1.4",
+          "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+          "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+          "dev": true
+        },
+        "escape-string-regexp": {
+          "version": "4.0.0",
+          "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
+          "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
+          "dev": true
+        },
+        "glob": {
+          "version": "7.2.0",
+          "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.0.tgz",
+          "integrity": "sha512-lmLf6gtyrPq8tTjSmrO94wBeQbFR3HbLHbuyD69wuyQkImp2hWqMGB47OX65FBkPffO641IP9jWa1z4ivqG26Q==",
+          "dev": true,
+          "requires": {
+            "fs.realpath": "^1.0.0",
+            "inflight": "^1.0.4",
+            "inherits": "2",
+            "minimatch": "^3.0.4",
+            "once": "^1.3.0",
+            "path-is-absolute": "^1.0.0"
+          },
+          "dependencies": {
+            "minimatch": {
+              "version": "3.1.2",
+              "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
+              "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
+              "dev": true,
+              "requires": {
+                "brace-expansion": "^1.1.7"
+              }
+            }
+          }
+        },
+        "has-flag": {
+          "version": "4.0.0",
+          "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
+          "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
+          "dev": true
+        },
+        "log-symbols": {
+          "version": "4.1.0",
+          "resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-4.1.0.tgz",
+          "integrity": "sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==",
+          "dev": true,
+          "requires": {
+            "chalk": "^4.1.0",
+            "is-unicode-supported": "^0.1.0"
+          }
+        },
+        "minimatch": {
+          "version": "5.0.1",
+          "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-5.0.1.tgz",
+          "integrity": "sha512-nLDxIFRyhDblz3qMuq+SoRZED4+miJ/G+tdDrjkkkRnjAsBexeGpgjLEQ0blJy7rHhR2b93rhQY4SvyWu9v03g==",
+          "dev": true,
+          "requires": {
+            "brace-expansion": "^2.0.1"
+          },
+          "dependencies": {
+            "brace-expansion": {
+              "version": "2.0.1",
+              "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz",
+              "integrity": "sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==",
+              "dev": true,
+              "requires": {
+                "balanced-match": "^1.0.0"
+              }
+            }
+          }
+        },
+        "ms": {
+          "version": "2.1.3",
+          "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+          "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+          "dev": true
+        },
+        "supports-color": {
+          "version": "8.1.1",
+          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz",
+          "integrity": "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==",
+          "dev": true,
+          "requires": {
+            "has-flag": "^4.0.0"
+          }
+        }
+      }
+    },
+    "ms": {
+      "version": "2.1.2",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
+      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
+      "dev": true
+    },
+    "nanoid": {
+      "version": "3.3.3",
+      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.3.tgz",
+      "integrity": "sha512-p1sjXuopFs0xg+fPASzQ28agW1oHD7xDsd9Xkf3T15H3c/cifrFHVwrh74PdoklAPi+i7MdRsE47vm2r6JoB+w==",
+      "dev": true
+    },
+    "natural-compare": {
+      "version": "1.4.0",
+      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
+      "integrity": "sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=",
+      "dev": true
+    },
+    "node-releases": {
+      "version": "2.0.6",
+      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.6.tgz",
+      "integrity": "sha512-PiVXnNuFm5+iYkLBNeq5211hvO38y63T0i2KKh2KnUs3RpzJ+JtODFjkD8yjLwnDkTYF1eKXheUwdssR+NRZdg==",
+      "dev": true
+    },
+    "normalize-path": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
+      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
+      "dev": true
+    },
+    "npm-run-path": {
+      "version": "5.1.0",
+      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-5.1.0.tgz",
+      "integrity": "sha512-sJOdmRGrY2sjNTRMbSvluQqg+8X7ZK61yvzBEIDhz4f8z1TZFYABsqjjCBd/0PUNE9M6QDgHJXQkGUEm7Q+l9Q==",
+      "dev": true,
+      "requires": {
+        "path-key": "^4.0.0"
+      },
+      "dependencies": {
+        "path-key": {
+          "version": "4.0.0",
+          "resolved": "https://registry.npmjs.org/path-key/-/path-key-4.0.0.tgz",
+          "integrity": "sha512-haREypq7xkM7ErfgIyA0z+Bj4AGKlMSdlQE2jvJo6huWD1EdkKYV+G/T4nq0YEF2vgTT8kqMFKo1uHn950r4SQ==",
+          "dev": true
+        }
+      }
+    },
+    "object-inspect": {
+      "version": "1.12.3",
+      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.12.3.tgz",
+      "integrity": "sha512-geUvdk7c+eizMNUDkRpW1wJwgfOiOeHbxBR/hLXK1aT6zmVSO0jsQcs7fj6MGw89jC/cjGfLcNOrtMYtGqm81g==",
+      "dev": true
+    },
+    "object-is": {
+      "version": "1.1.5",
+      "resolved": "https://registry.npmjs.org/object-is/-/object-is-1.1.5.tgz",
+      "integrity": "sha512-3cyDsyHgtmi7I7DfSSI2LDp6SK2lwvtbg0p0R1e0RvTqF5ceGx+K2dfSjm1bKDMVCFEDAQvy+o8c6a7VujOddw==",
+      "requires": {
+        "call-bind": "^1.0.2",
+        "define-properties": "^1.1.3"
+      }
+    },
+    "object-keys": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz",
+      "integrity": "sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA=="
+    },
+    "once": {
+      "version": "1.4.0",
+      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
+      "integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
+      "dev": true,
+      "requires": {
+        "wrappy": "1"
+      }
+    },
+    "onetime": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/onetime/-/onetime-6.0.0.tgz",
+      "integrity": "sha512-1FlR+gjXK7X+AsAHso35MnyN5KqGwJRi/31ft6x0M194ht7S+rWAvd7PHss9xSKMzE0asv1pyIHaJYq+BbacAQ==",
+      "dev": true,
+      "requires": {
+        "mimic-fn": "^4.0.0"
+      }
+    },
+    "optionator": {
+      "version": "0.9.1",
+      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz",
+      "integrity": "sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==",
+      "dev": true,
+      "requires": {
+        "deep-is": "^0.1.3",
+        "fast-levenshtein": "^2.0.6",
+        "levn": "^0.4.1",
+        "prelude-ls": "^1.2.1",
+        "type-check": "^0.4.0",
+        "word-wrap": "^1.2.3"
+      }
+    },
+    "p-limit": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
+      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
+      "dev": true,
+      "requires": {
+        "yocto-queue": "^0.1.0"
+      }
+    },
+    "p-locate": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
+      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
+      "dev": true,
+      "requires": {
+        "p-limit": "^3.0.2"
+      }
+    },
+    "p-map": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/p-map/-/p-map-4.0.0.tgz",
+      "integrity": "sha512-/bjOqmgETBYB5BoEeGVea8dmvHb2m9GLy1E9W43yeyfP6QQCZGFNa+XRceJEuDB6zqr+gKpIAmlLebMpykw/MQ==",
+      "dev": true,
+      "requires": {
+        "aggregate-error": "^3.0.0"
+      }
+    },
+    "parent-module": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
+      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
+      "dev": true,
+      "requires": {
+        "callsites": "^3.0.0"
+      }
+    },
+    "path-exists": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
+      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
+      "dev": true
+    },
+    "path-is-absolute": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
+      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
+      "dev": true
+    },
+    "path-key": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
+      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
+      "dev": true
+    },
+    "path-parse": {
+      "version": "1.0.7",
+      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
+      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
+      "dev": true
+    },
+    "path-type": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
+      "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==",
+      "dev": true
+    },
+    "picocolors": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.0.0.tgz",
+      "integrity": "sha512-1fygroTLlHu66zi26VoTDv8yRgm0Fccecssto+MhsZ0D/DGW2sm8E8AjW7NU5VVTRt5GxbeZ5qBuJr+HyLYkjQ==",
+      "dev": true
+    },
+    "picomatch": {
+      "version": "2.3.1",
+      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
+      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
+      "dev": true
+    },
+    "pidtree": {
+      "version": "0.6.0",
+      "resolved": "https://registry.npmjs.org/pidtree/-/pidtree-0.6.0.tgz",
+      "integrity": "sha512-eG2dWTVw5bzqGRztnHExczNxt5VGsE6OwTeCG3fdUf9KBsZzO3R5OIIIzWR+iZA0NtZ+RDVdaoE2dK1cn6jH4g==",
+      "dev": true
+    },
+    "prelude-ls": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
+      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
+      "dev": true
+    },
+    "prettier": {
+      "version": "2.6.2",
+      "resolved": "https://registry.npmjs.org/prettier/-/prettier-2.6.2.tgz",
+      "integrity": "sha512-PkUpF+qoXTqhOeWL9fu7As8LXsIUZ1WYaJiY/a7McAQzxjk82OF0tibkFXVCDImZtWxbvojFjerkiLb0/q8mew==",
+      "dev": true
+    },
+    "punycode": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.0.tgz",
+      "integrity": "sha512-rRV+zQD8tVFys26lAGR9WUuS4iUAngJScM+ZRSKtvl5tKeZ2t5bvdNFdNHBW9FWR4guGHlgmsZ1G7BSm2wTbuA==",
+      "dev": true
+    },
+    "queue-microtask": {
+      "version": "1.2.3",
+      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
+      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
+      "dev": true
+    },
+    "randombytes": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
+      "integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
+      "dev": true,
+      "requires": {
+        "safe-buffer": "^5.1.0"
+      }
+    },
+    "readdirp": {
+      "version": "3.6.0",
+      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
+      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
+      "dev": true,
+      "requires": {
+        "picomatch": "^2.2.1"
+      }
+    },
+    "regenerate": {
+      "version": "1.4.2",
+      "resolved": "https://registry.npmjs.org/regenerate/-/regenerate-1.4.2.tgz",
+      "integrity": "sha512-zrceR/XhGYU/d/opr2EKO7aRHUeiBI8qjtfHqADTwZd6Szfy16la6kqD0MIUs5z5hx6AaKa+PixpPrR289+I0A==",
+      "dev": true
+    },
+    "regenerate-unicode-properties": {
+      "version": "10.1.0",
+      "resolved": "https://registry.npmjs.org/regenerate-unicode-properties/-/regenerate-unicode-properties-10.1.0.tgz",
+      "integrity": "sha512-d1VudCLoIGitcU/hEg2QqvyGZQmdC0Lf8BqdOMXGFSvJP4bNV1+XqbPQeHHLD51Jh4QJJ225dlIFvY4Ly6MXmQ==",
+      "dev": true,
+      "requires": {
+        "regenerate": "^1.4.2"
+      }
+    },
+    "regenerator-runtime": {
+      "version": "0.13.11",
+      "resolved": "https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.13.11.tgz",
+      "integrity": "sha512-kY1AZVr2Ra+t+piVaJ4gxaFaReZVH40AKNo7UCX6W+dEwBo/2oZJzqfuN1qLq1oL45o56cPaTXELwrTh8Fpggg==",
+      "dev": true
+    },
+    "regenerator-transform": {
+      "version": "0.15.1",
+      "resolved": "https://registry.npmjs.org/regenerator-transform/-/regenerator-transform-0.15.1.tgz",
+      "integrity": "sha512-knzmNAcuyxV+gQCufkYcvOqX/qIIfHLv0u5x79kRxuGojfYVky1f15TzZEu2Avte8QGepvUNTnLskf8E6X6Vyg==",
+      "dev": true,
+      "requires": {
+        "@babel/runtime": "^7.8.4"
+      }
+    },
+    "regexpu-core": {
+      "version": "5.2.2",
+      "resolved": "https://registry.npmjs.org/regexpu-core/-/regexpu-core-5.2.2.tgz",
+      "integrity": "sha512-T0+1Zp2wjF/juXMrMxHxidqGYn8U4R+zleSJhX9tQ1PUsS8a9UtYfbsF9LdiVgNX3kiX8RNaKM42nfSgvFJjmw==",
+      "dev": true,
+      "requires": {
+        "regenerate": "^1.4.2",
+        "regenerate-unicode-properties": "^10.1.0",
+        "regjsgen": "^0.7.1",
+        "regjsparser": "^0.9.1",
+        "unicode-match-property-ecmascript": "^2.0.0",
+        "unicode-match-property-value-ecmascript": "^2.1.0"
+      }
+    },
+    "regjsgen": {
+      "version": "0.7.1",
+      "resolved": "https://registry.npmjs.org/regjsgen/-/regjsgen-0.7.1.tgz",
+      "integrity": "sha512-RAt+8H2ZEzHeYWxZ3H2z6tF18zyyOnlcdaafLrm21Bguj7uZy6ULibiAFdXEtKQY4Sy7wDTwDiOazasMLc4KPA==",
+      "dev": true
+    },
+    "regjsparser": {
+      "version": "0.9.1",
+      "resolved": "https://registry.npmjs.org/regjsparser/-/regjsparser-0.9.1.tgz",
+      "integrity": "sha512-dQUtn90WanSNl+7mQKcXAgZxvUe7Z0SqXlgzv0za4LwiUhyzBC58yQO3liFoUgu8GiJVInAhJjkj1N0EtQ5nkQ==",
+      "dev": true,
+      "requires": {
+        "jsesc": "~0.5.0"
+      },
+      "dependencies": {
+        "jsesc": {
+          "version": "0.5.0",
+          "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-0.5.0.tgz",
+          "integrity": "sha512-uZz5UnB7u4T9LvwmFqXii7pZSouaRPorGs5who1Ip7VO0wxanFvBL7GkM6dTHlgX+jhBApRetaWpnDabOeTcnA==",
+          "dev": true
+        }
+      }
+    },
+    "reify": {
+      "version": "0.20.12",
+      "resolved": "https://registry.npmjs.org/reify/-/reify-0.20.12.tgz",
+      "integrity": "sha512-4BzKwDWyJJbukwI6xIJRh+BDTitoGzxdgYPiQQ1zbcTZW6I8xgHPw1DnVuEs/mEZQlYm1e09DcFSApb4UaR5bQ==",
+      "dev": true,
+      "requires": {
+        "acorn": "^6.1.1",
+        "acorn-dynamic-import": "^4.0.0",
+        "magic-string": "^0.25.3",
+        "semver": "^5.4.1"
+      }
+    },
+    "require-directory": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
+      "integrity": "sha1-jGStX9MNqxyXbiNE/+f3kqam30I=",
+      "dev": true
+    },
+    "resolve": {
+      "version": "1.22.1",
+      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.1.tgz",
+      "integrity": "sha512-nBpuuYuY5jFsli/JIs1oldw6fOQCBioohqWZg/2hiaOybXOft4lonv85uDOKXdf8rhyK159cxU5cDcK/NKk8zw==",
+      "dev": true,
+      "requires": {
+        "is-core-module": "^2.9.0",
+        "path-parse": "^1.0.7",
+        "supports-preserve-symlinks-flag": "^1.0.0"
+      }
+    },
+    "resolve-from": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
+      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
+      "dev": true
+    },
+    "restore-cursor": {
+      "version": "3.1.0",
+      "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-3.1.0.tgz",
+      "integrity": "sha512-l+sSefzHpj5qimhFSE5a8nufZYAM3sBSVMAPtYkmC+4EH2anSGaEMXSD0izRQbu9nfyQ9y5JrVmp7E8oZrUjvA==",
+      "dev": true,
+      "requires": {
+        "onetime": "^5.1.0",
+        "signal-exit": "^3.0.2"
+      },
+      "dependencies": {
+        "mimic-fn": {
+          "version": "2.1.0",
+          "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
+          "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==",
+          "dev": true
+        },
+        "onetime": {
+          "version": "5.1.2",
+          "resolved": "https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz",
+          "integrity": "sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==",
+          "dev": true,
+          "requires": {
+            "mimic-fn": "^2.1.0"
+          }
+        }
+      }
+    },
+    "reusify": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz",
+      "integrity": "sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==",
+      "dev": true
+    },
+    "rfdc": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/rfdc/-/rfdc-1.3.0.tgz",
+      "integrity": "sha512-V2hovdzFbOi77/WajaSMXk2OLm+xNIeQdMMuB7icj7bk6zi2F8GGAxigcnDFpJHbNyNcgyJDiP+8nOrY5cZGrA==",
+      "dev": true
+    },
+    "rimraf": {
+      "version": "3.0.2",
+      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
+      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
+      "dev": true,
+      "requires": {
+        "glob": "^7.1.3"
+      },
+      "dependencies": {
+        "glob": {
+          "version": "7.2.3",
+          "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
+          "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
+          "dev": true,
+          "requires": {
+            "fs.realpath": "^1.0.0",
+            "inflight": "^1.0.4",
+            "inherits": "2",
+            "minimatch": "^3.1.1",
+            "once": "^1.3.0",
+            "path-is-absolute": "^1.0.0"
+          }
+        }
+      }
+    },
+    "run-parallel": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
+      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
+      "dev": true,
+      "requires": {
+        "queue-microtask": "^1.2.2"
+      }
+    },
+    "rxjs": {
+      "version": "7.8.1",
+      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.8.1.tgz",
+      "integrity": "sha512-AA3TVj+0A2iuIoQkWEK/tqFjBq2j+6PO6Y0zJcvzLAFhEFIO3HL0vls9hWLncZbAAbK0mar7oZ4V079I/qPMxg==",
+      "dev": true,
+      "requires": {
+        "tslib": "^2.1.0"
+      }
+    },
+    "safe-buffer": {
+      "version": "5.1.2",
+      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
+      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
+      "dev": true
+    },
+    "semver": {
+      "version": "5.7.1",
+      "resolved": "https://registry.npmjs.org/semver/-/semver-5.7.1.tgz",
+      "integrity": "sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ==",
+      "dev": true
+    },
+    "serialize-javascript": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-6.0.0.tgz",
+      "integrity": "sha512-Qr3TosvguFt8ePWqsvRfrKyQXIiW+nGbYpy8XK24NQHE83caxWt+mIymTT19DGFbNWNLfEwsrkSmN64lVWB9ag==",
+      "dev": true,
+      "requires": {
+        "randombytes": "^2.1.0"
+      }
+    },
+    "shebang-command": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
+      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
+      "dev": true,
+      "requires": {
+        "shebang-regex": "^3.0.0"
+      }
+    },
+    "shebang-regex": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
+      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
+      "dev": true
+    },
+    "signal-exit": {
+      "version": "3.0.7",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
+      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==",
+      "dev": true
+    },
+    "slash": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
+      "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
+      "dev": true
+    },
+    "slice-ansi": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-4.0.0.tgz",
+      "integrity": "sha512-qMCMfhY040cVHT43K9BFygqYbUPFZKHOg7K73mtTWJRb8pyP3fzf4Ixd5SzdEJQ6MRUg/WBnOLxghZtKKurENQ==",
+      "dev": true,
+      "requires": {
+        "ansi-styles": "^4.0.0",
+        "astral-regex": "^2.0.0",
+        "is-fullwidth-code-point": "^3.0.0"
+      },
+      "dependencies": {
+        "ansi-styles": {
+          "version": "4.3.0",
+          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+          "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+          "dev": true,
+          "requires": {
+            "color-convert": "^2.0.1"
+          }
+        },
+        "color-convert": {
+          "version": "2.0.1",
+          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+          "dev": true,
+          "requires": {
+            "color-name": "~1.1.4"
+          }
+        },
+        "color-name": {
+          "version": "1.1.4",
+          "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+          "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+          "dev": true
+        }
+      }
+    },
+    "source-map": {
+      "version": "0.6.1",
+      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
+      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g=="
+    },
+    "sourcemap-codec": {
+      "version": "1.4.8",
+      "resolved": "https://registry.npmjs.org/sourcemap-codec/-/sourcemap-codec-1.4.8.tgz",
+      "integrity": "sha512-9NykojV5Uih4lgo5So5dtw+f0JgJX30KCNI8gwhz2J9A15wD0Ml6tjHKwf6fTSa6fAdVBdZeNOs9eJ71qCk8vA==",
+      "dev": true
+    },
+    "string-argv": {
+      "version": "0.3.1",
+      "resolved": "https://registry.npmjs.org/string-argv/-/string-argv-0.3.1.tgz",
+      "integrity": "sha512-a1uQGz7IyVy9YwhqjZIZu1c8JO8dNIe20xBmSS6qu9kv++k3JGzCVmprbNN5Kn+BgzD5E7YYwg1CcjuJMRNsvg==",
+      "dev": true
+    },
+    "string-width": {
+      "version": "4.2.3",
+      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
+      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
+      "dev": true,
+      "requires": {
+        "emoji-regex": "^8.0.0",
+        "is-fullwidth-code-point": "^3.0.0",
+        "strip-ansi": "^6.0.1"
+      }
+    },
+    "strip-ansi": {
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
+      "dev": true,
+      "requires": {
+        "ansi-regex": "^5.0.1"
+      }
+    },
+    "strip-final-newline": {
+      "version": "3.0.0",
+      "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-3.0.0.tgz",
+      "integrity": "sha512-dOESqjYr96iWYylGObzd39EuNTa5VJxyvVAEm5Jnh7KGo75V43Hk1odPQkNDyXNmUR6k+gEiDVXnjB8HJ3crXw==",
+      "dev": true
+    },
+    "strip-json-comments": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
+      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
+      "dev": true
+    },
+    "supports-color": {
+      "version": "5.5.0",
+      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
+      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
+      "dev": true,
+      "requires": {
+        "has-flag": "^3.0.0"
+      }
+    },
+    "supports-preserve-symlinks-flag": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
+      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
+      "dev": true
+    },
+    "text-table": {
+      "version": "0.2.0",
+      "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
+      "integrity": "sha1-f17oI66AUgfACvLfSoTsP8+lcLQ=",
+      "dev": true
+    },
+    "through": {
+      "version": "2.3.8",
+      "resolved": "https://registry.npmjs.org/through/-/through-2.3.8.tgz",
+      "integrity": "sha512-w89qg7PI8wAdvX60bMDP+bFoD5Dvhm9oLheFp5O4a2QF0cSBGsBX4qZmadPMvVqlLJBBci+WqGGOAPvcDeNSVg==",
+      "dev": true
+    },
+    "to-fast-properties": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/to-fast-properties/-/to-fast-properties-2.0.0.tgz",
+      "integrity": "sha1-3F5pjL0HkmW8c+A3doGk5Og/YW4=",
+      "dev": true
+    },
+    "to-regex-range": {
+      "version": "5.0.1",
+      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
+      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
+      "dev": true,
+      "requires": {
+        "is-number": "^7.0.0"
+      }
+    },
+    "tslib": {
+      "version": "2.5.0",
+      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.5.0.tgz",
+      "integrity": "sha512-336iVw3rtn2BUK7ORdIAHTyxHGRIHVReokCR3XjbckJMK7ms8FysBfhLR8IXnAgy7T0PTPNBWKiH514FOW/WSg=="
+    },
+    "tsutils": {
+      "version": "3.21.0",
+      "resolved": "https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz",
+      "integrity": "sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==",
+      "dev": true,
+      "requires": {
+        "tslib": "^1.8.1"
+      },
+      "dependencies": {
+        "tslib": {
+          "version": "1.14.1",
+          "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz",
+          "integrity": "sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==",
+          "dev": true
+        }
+      }
+    },
+    "type-check": {
+      "version": "0.4.0",
+      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
+      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
+      "dev": true,
+      "requires": {
+        "prelude-ls": "^1.2.1"
+      }
+    },
+    "type-fest": {
+      "version": "0.20.2",
+      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz",
+      "integrity": "sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==",
+      "dev": true
+    },
+    "typescript": {
+      "version": "4.9.4",
+      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.9.4.tgz",
+      "integrity": "sha512-Uz+dTXYzxXXbsFpM86Wh3dKCxrQqUcVMxwU54orwlJjOpO3ao8L7j5lH+dWfTwgCwIuM9GQ2kvVotzYJMXTBZg==",
+      "dev": true
+    },
+    "unicode-canonical-property-names-ecmascript": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/unicode-canonical-property-names-ecmascript/-/unicode-canonical-property-names-ecmascript-2.0.0.tgz",
+      "integrity": "sha512-yY5PpDlfVIU5+y/BSCxAJRBIS1Zc2dDG3Ujq+sR0U+JjUevW2JhocOF+soROYDSaAezOzOKuyyixhD6mBknSmQ==",
+      "dev": true
+    },
+    "unicode-match-property-ecmascript": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/unicode-match-property-ecmascript/-/unicode-match-property-ecmascript-2.0.0.tgz",
+      "integrity": "sha512-5kaZCrbp5mmbz5ulBkDkbY0SsPOjKqVS35VpL9ulMPfSl0J0Xsm+9Evphv9CoIZFwre7aJoa94AY6seMKGVN5Q==",
+      "dev": true,
+      "requires": {
+        "unicode-canonical-property-names-ecmascript": "^2.0.0",
+        "unicode-property-aliases-ecmascript": "^2.0.0"
+      }
+    },
+    "unicode-match-property-value-ecmascript": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/unicode-match-property-value-ecmascript/-/unicode-match-property-value-ecmascript-2.1.0.tgz",
+      "integrity": "sha512-qxkjQt6qjg/mYscYMC0XKRn3Rh0wFPlfxB0xkt9CfyTvpX1Ra0+rAmdX2QyAobptSEvuy4RtpPRui6XkV+8wjA==",
+      "dev": true
+    },
+    "unicode-property-aliases-ecmascript": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/unicode-property-aliases-ecmascript/-/unicode-property-aliases-ecmascript-2.1.0.tgz",
+      "integrity": "sha512-6t3foTQI9qne+OZoVQB/8x8rk2k1eVy1gRXhV3oFQ5T6R1dqQ1xtin3XqSlx3+ATBkliTaR/hHyJBm+LVPNM8w==",
+      "dev": true
+    },
+    "update-browserslist-db": {
+      "version": "1.0.10",
+      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.0.10.tgz",
+      "integrity": "sha512-OztqDenkfFkbSG+tRxBeAnCVPckDBcvibKd35yDONx6OU8N7sqgwc7rCbkJ/WcYtVRZ4ba68d6byhC21GFh7sQ==",
+      "dev": true,
+      "requires": {
+        "escalade": "^3.1.1",
+        "picocolors": "^1.0.0"
+      }
+    },
+    "uri-js": {
+      "version": "4.4.1",
+      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
+      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
+      "dev": true,
+      "requires": {
+        "punycode": "^2.1.0"
+      }
+    },
+    "util": {
+      "version": "0.12.5",
+      "resolved": "https://registry.npmjs.org/util/-/util-0.12.5.tgz",
+      "integrity": "sha512-kZf/K6hEIrWHI6XqOFUiiMa+79wE/D8Q+NCNAWclkyg3b4d2k7s0QGepNjiABc+aR3N1PAyHL7p6UcLY6LmrnA==",
+      "requires": {
+        "inherits": "^2.0.3",
+        "is-arguments": "^1.0.4",
+        "is-generator-function": "^1.0.7",
+        "is-typed-array": "^1.1.3",
+        "which-typed-array": "^1.1.2"
+      }
+    },
+    "which": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
+      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
+      "dev": true,
+      "requires": {
+        "isexe": "^2.0.0"
+      }
+    },
+    "which-typed-array": {
+      "version": "1.1.9",
+      "resolved": "https://registry.npmjs.org/which-typed-array/-/which-typed-array-1.1.9.tgz",
+      "integrity": "sha512-w9c4xkx6mPidwp7180ckYWfMmvxpjlZuIudNtDf4N/tTAUB8VJbX25qZoAsrtGuYNnGw3pa0AXgbGKRB8/EceA==",
+      "requires": {
+        "available-typed-arrays": "^1.0.5",
+        "call-bind": "^1.0.2",
+        "for-each": "^0.3.3",
+        "gopd": "^1.0.1",
+        "has-tostringtag": "^1.0.0",
+        "is-typed-array": "^1.1.10"
+      }
+    },
+    "word-wrap": {
+      "version": "1.2.3",
+      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz",
+      "integrity": "sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==",
+      "dev": true
+    },
+    "workerpool": {
+      "version": "6.2.1",
+      "resolved": "https://registry.npmjs.org/workerpool/-/workerpool-6.2.1.tgz",
+      "integrity": "sha512-ILEIE97kDZvF9Wb9f6h5aXK4swSlKGUcOEGiIYb2OOu/IrDU9iwj0fD//SsA6E5ibwJxpEvhullJY4Sl4GcpAw==",
+      "dev": true
+    },
+    "wrap-ansi": {
+      "version": "7.0.0",
+      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
+      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
+      "dev": true,
+      "requires": {
+        "ansi-styles": "^4.0.0",
+        "string-width": "^4.1.0",
+        "strip-ansi": "^6.0.0"
+      },
+      "dependencies": {
+        "ansi-styles": {
+          "version": "4.3.0",
+          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+          "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+          "dev": true,
+          "requires": {
+            "color-convert": "^2.0.1"
+          }
+        },
+        "color-convert": {
+          "version": "2.0.1",
+          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
+          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
+          "dev": true,
+          "requires": {
+            "color-name": "~1.1.4"
+          }
+        },
+        "color-name": {
+          "version": "1.1.4",
+          "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
+          "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
+          "dev": true
+        }
+      }
+    },
+    "wrappy": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
+      "integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=",
+      "dev": true
+    },
+    "y18n": {
+      "version": "5.0.8",
+      "resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
+      "integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
+      "dev": true
+    },
+    "yallist": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
+      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
+      "dev": true
+    },
+    "yaml": {
+      "version": "2.2.2",
+      "resolved": "https://registry.npmjs.org/yaml/-/yaml-2.2.2.tgz",
+      "integrity": "sha512-CBKFWExMn46Foo4cldiChEzn7S7SRV+wqiluAb6xmueD/fGyRHIhX8m14vVGgeFWjN540nKCNVj6P21eQjgTuA==",
+      "dev": true
+    },
+    "yargs": {
+      "version": "16.2.0",
+      "resolved": "https://registry.npmjs.org/yargs/-/yargs-16.2.0.tgz",
+      "integrity": "sha512-D1mvvtDG0L5ft/jGWkLpG1+m0eQxOfaBvTNELraWj22wSVUMWxZUvYgJYcKh6jGGIkJFhH4IZPQhR4TKpc8mBw==",
+      "dev": true,
+      "requires": {
+        "cliui": "^7.0.2",
+        "escalade": "^3.1.1",
+        "get-caller-file": "^2.0.5",
+        "require-directory": "^2.1.1",
+        "string-width": "^4.2.0",
+        "y18n": "^5.0.5",
+        "yargs-parser": "^20.2.2"
+      }
+    },
+    "yargs-parser": {
+      "version": "20.2.4",
+      "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-20.2.4.tgz",
+      "integrity": "sha512-WOkpgNhPTlE73h4VFAFsOnomJVaovO8VqLDzy5saChRBFQFBoMYirowyW+Q9HB4HFF4Z7VZTiG3iSzJJA29yRA==",
+      "dev": true
+    },
+    "yargs-unparser": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/yargs-unparser/-/yargs-unparser-2.0.0.tgz",
+      "integrity": "sha512-7pRTIA9Qc1caZ0bZ6RYRGbHJthJWuakf+WmHK0rVeLkNrrGhfoabBNdue6kdINI6r4if7ocq9aD/n7xwKOdzOA==",
+      "dev": true,
+      "requires": {
+        "camelcase": "^6.0.0",
+        "decamelize": "^4.0.0",
+        "flat": "^5.0.2",
+        "is-plain-obj": "^2.1.0"
+      }
+    },
+    "yocto-queue": {
+      "version": "0.1.0",
+      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
+      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
+      "dev": true
+    }
+  }
+}
diff --git a/node_modules/recast/parsers/_babel_options.js b/node_modules/recast/parsers/_babel_options.js
index d8fa77b..2e0c794 100644
--- a/node_modules/recast/parsers/_babel_options.js
+++ b/node_modules/recast/parsers/_babel_options.js
@@ -1,14 +1,14 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-var util_1 = require("../lib/util");
+var util_js_1 = require("../lib/util.js");
 function getBabelOptions(options) {
     // The goal here is to tolerate as much syntax as possible, since Recast
     // is not in the business of forbidding anything. If you want your
     // parser to be more restrictive for some reason, you can always pass
     // your own parser object to recast.parse.
     return {
-        sourceType: (0, util_1.getOption)(options, "sourceType", "module"),
-        strictMode: (0, util_1.getOption)(options, "strictMode", false),
+        sourceType: (0, util_js_1.getOption)(options, "sourceType", "module"),
+        strictMode: (0, util_js_1.getOption)(options, "strictMode", false),
         allowImportExportEverywhere: true,
         allowReturnOutsideFunction: true,
         startLine: 1,
diff --git a/node_modules/recast/parsers/_babel_options.ts b/node_modules/recast/parsers/_babel_options.ts
new file mode 100644
index 0000000..d9a5b66
--- /dev/null
+++ b/node_modules/recast/parsers/_babel_options.ts
@@ -0,0 +1,63 @@
+import { ParserOptions, ParserPlugin } from "@babel/parser";
+import { getOption } from "../lib/util.js";
+
+export type Overrides = Partial<{
+  sourceType: ParserOptions["sourceType"];
+  strictMode: ParserOptions["strictMode"];
+}>;
+
+export default function getBabelOptions(
+  options?: Overrides,
+): ParserOptions & { plugins: ParserPlugin[] } {
+  // The goal here is to tolerate as much syntax as possible, since Recast
+  // is not in the business of forbidding anything. If you want your
+  // parser to be more restrictive for some reason, you can always pass
+  // your own parser object to recast.parse.
+  return {
+    sourceType: getOption(options, "sourceType", "module"),
+    strictMode: getOption(options, "strictMode", false),
+    allowImportExportEverywhere: true,
+    allowReturnOutsideFunction: true,
+    startLine: 1,
+    tokens: true,
+    plugins: [
+      "asyncGenerators",
+      "bigInt",
+      "classPrivateMethods",
+      "classPrivateProperties",
+      "classProperties",
+      "classStaticBlock",
+      "decimal",
+      "decorators-legacy",
+      "doExpressions",
+      "dynamicImport",
+      "exportDefaultFrom",
+      "exportExtensions" as any as ParserPlugin,
+      "exportNamespaceFrom",
+      "functionBind",
+      "functionSent",
+      "importAssertions",
+      "importMeta",
+      "nullishCoalescingOperator",
+      "numericSeparator",
+      "objectRestSpread",
+      "optionalCatchBinding",
+      "optionalChaining",
+      [
+        "pipelineOperator",
+        {
+          proposal: "minimal",
+        },
+      ] as any as ParserPlugin,
+      [
+        "recordAndTuple",
+        {
+          syntaxType: "hash",
+        },
+      ],
+      "throwExpressions",
+      "topLevelAwait",
+      "v8intrinsic",
+    ],
+  };
+}
diff --git a/node_modules/recast/parsers/acorn.d.ts b/node_modules/recast/parsers/acorn.d.ts
index 4ad6653..7456674 100644
--- a/node_modules/recast/parsers/acorn.d.ts
+++ b/node_modules/recast/parsers/acorn.d.ts
@@ -1 +1,2 @@
-export declare function parse(source: string, options?: any): any;
+import * as acorn from "acorn";
+export declare function parse(source: string, options?: any): acorn.Node;
diff --git a/node_modules/recast/parsers/acorn.js b/node_modules/recast/parsers/acorn.js
index 4dfe8b6..bf5f2d5 100644
--- a/node_modules/recast/parsers/acorn.js
+++ b/node_modules/recast/parsers/acorn.js
@@ -1,6 +1,7 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.parse = void 0;
+var tslib_1 = require("tslib");
 // This module is suitable for passing as options.parser when calling
 // recast.parse to process JavaScript code with Acorn:
 //
@@ -8,24 +9,29 @@ exports.parse = void 0;
 //     parser: require("recast/parsers/acorn")
 //   });
 //
-var util_1 = require("../lib/util");
+var util_js_1 = require("../lib/util.js");
+var acorn = tslib_1.__importStar(require("acorn"));
 function parse(source, options) {
     var comments = [];
     var tokens = [];
-    var ast = require("acorn").parse(source, {
+    var ast = acorn.parse(source, {
         allowHashBang: true,
         allowImportExportEverywhere: true,
         allowReturnOutsideFunction: true,
-        ecmaVersion: (0, util_1.getOption)(options, "ecmaVersion", 8),
-        sourceType: (0, util_1.getOption)(options, "sourceType", "module"),
+        ecmaVersion: (0, util_js_1.getOption)(options, "ecmaVersion", 8),
+        sourceType: (0, util_js_1.getOption)(options, "sourceType", "module"),
         locations: true,
         onComment: comments,
         onToken: tokens,
     });
+    // @ts-expect-error
     if (!ast.comments) {
+        // @ts-expect-error
         ast.comments = comments;
     }
+    // @ts-expect-error
     if (!ast.tokens) {
+        // @ts-expect-error
         ast.tokens = tokens;
     }
     return ast;
diff --git a/node_modules/recast/parsers/acorn.ts b/node_modules/recast/parsers/acorn.ts
new file mode 100644
index 0000000..b760510
--- /dev/null
+++ b/node_modules/recast/parsers/acorn.ts
@@ -0,0 +1,38 @@
+// This module is suitable for passing as options.parser when calling
+// recast.parse to process JavaScript code with Acorn:
+//
+//   const ast = recast.parse(source, {
+//     parser: require("recast/parsers/acorn")
+//   });
+//
+import { getOption } from "../lib/util.js";
+import * as acorn from "acorn";
+
+export function parse(source: string, options?: any) {
+  const comments: any[] = [];
+  const tokens: any[] = [];
+  const ast = acorn.parse(source, {
+    allowHashBang: true,
+    allowImportExportEverywhere: true,
+    allowReturnOutsideFunction: true,
+    ecmaVersion: getOption(options, "ecmaVersion", 8),
+    sourceType: getOption(options, "sourceType", "module"),
+    locations: true,
+    onComment: comments,
+    onToken: tokens,
+  });
+
+  // @ts-expect-error
+  if (!ast.comments) {
+    // @ts-expect-error
+    ast.comments = comments;
+  }
+
+  // @ts-expect-error
+  if (!ast.tokens) {
+    // @ts-expect-error
+    ast.tokens = tokens;
+  }
+
+  return ast;
+}
diff --git a/node_modules/recast/parsers/babel-ts.d.ts b/node_modules/recast/parsers/babel-ts.d.ts
index 9da143e..3ce3fec 100644
--- a/node_modules/recast/parsers/babel-ts.d.ts
+++ b/node_modules/recast/parsers/babel-ts.d.ts
@@ -1,4 +1,4 @@
-import { parser } from "./babel";
-import { Overrides } from "./_babel_options";
+import { parser } from "./babel.js";
+import { Overrides } from "./_babel_options.js";
 export { parser };
 export declare function parse(source: string, options?: Overrides): import("@babel/parser").ParseResult<import("@babel/types").File>;
diff --git a/node_modules/recast/parsers/babel-ts.js b/node_modules/recast/parsers/babel-ts.js
index 9fdf6f3..6d9b483 100644
--- a/node_modules/recast/parsers/babel-ts.js
+++ b/node_modules/recast/parsers/babel-ts.js
@@ -2,12 +2,12 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.parse = exports.parser = void 0;
 var tslib_1 = require("tslib");
-var babel_1 = require("./babel");
-Object.defineProperty(exports, "parser", { enumerable: true, get: function () { return babel_1.parser; } });
-var _babel_options_1 = tslib_1.__importDefault(require("./_babel_options"));
+var babel_js_1 = require("./babel.js");
+Object.defineProperty(exports, "parser", { enumerable: true, get: function () { return babel_js_1.parser; } });
+var _babel_options_js_1 = tslib_1.__importDefault(require("./_babel_options.js"));
 function parse(source, options) {
-    var babelOptions = (0, _babel_options_1.default)(options);
+    var babelOptions = (0, _babel_options_js_1.default)(options);
     babelOptions.plugins.push("jsx", "typescript");
-    return babel_1.parser.parse(source, babelOptions);
+    return babel_js_1.parser.parse(source, babelOptions);
 }
 exports.parse = parse;
diff --git a/node_modules/recast/parsers/babel-ts.ts b/node_modules/recast/parsers/babel-ts.ts
new file mode 100644
index 0000000..576693c
--- /dev/null
+++ b/node_modules/recast/parsers/babel-ts.ts
@@ -0,0 +1,10 @@
+import { parser } from "./babel.js";
+import getBabelOptions, { Overrides } from "./_babel_options.js";
+
+export { parser };
+
+export function parse(source: string, options?: Overrides) {
+  const babelOptions = getBabelOptions(options);
+  babelOptions.plugins.push("jsx", "typescript");
+  return parser.parse(source, babelOptions);
+}
diff --git a/node_modules/recast/parsers/babel.d.ts b/node_modules/recast/parsers/babel.d.ts
index da9283f..de6a538 100644
--- a/node_modules/recast/parsers/babel.d.ts
+++ b/node_modules/recast/parsers/babel.d.ts
@@ -1,8 +1,9 @@
 import { parse as babelParse } from "@babel/parser";
-import { Overrides } from "./_babel_options";
+import { Overrides } from "./_babel_options.js";
+import * as babelParser from "@babel/parser";
 type BabelParser = {
     parse: typeof babelParse;
 };
 export declare const parser: BabelParser;
-export declare function parse(source: string, options?: Overrides): import("@babel/parser").ParseResult<import("@babel/types").File>;
+export declare function parse(source: string, options?: Overrides): babelParser.ParseResult<import("@babel/types").File>;
 export {};
diff --git a/node_modules/recast/parsers/babel.js b/node_modules/recast/parsers/babel.js
index 9865fc5..78ffef8 100644
--- a/node_modules/recast/parsers/babel.js
+++ b/node_modules/recast/parsers/babel.js
@@ -2,16 +2,19 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.parse = exports.parser = void 0;
 var tslib_1 = require("tslib");
-var _babel_options_1 = tslib_1.__importDefault(require("./_babel_options"));
+var _babel_options_js_1 = tslib_1.__importDefault(require("./_babel_options.js"));
+var babelParser = tslib_1.__importStar(require("@babel/parser"));
+var babylon = tslib_1.__importStar(require("babylon"));
 // Prefer the new @babel/parser package, but fall back to babylon if
-// that's what's available.
+// that's what's available.babel
 exports.parser = (function () {
     try {
-        return require("@babel/parser");
+        return babelParser;
     }
     catch (_a) {
         try {
-            return require("babylon");
+            // @ts-expect-error
+            return babylon;
         }
         catch (_b) {
             throw new Error("Install @babel/parser to use the `typescript`, `flow`, or `babel` parsers");
@@ -26,7 +29,7 @@ exports.parser = (function () {
 //   });
 //
 function parse(source, options) {
-    var babelOptions = (0, _babel_options_1.default)(options);
+    var babelOptions = (0, _babel_options_js_1.default)(options);
     babelOptions.plugins.push("jsx", "flow", "decoratorAutoAccessors");
     return exports.parser.parse(source, babelOptions);
 }
diff --git a/node_modules/recast/parsers/babel.ts b/node_modules/recast/parsers/babel.ts
new file mode 100644
index 0000000..52393c3
--- /dev/null
+++ b/node_modules/recast/parsers/babel.ts
@@ -0,0 +1,36 @@
+import { parse as babelParse } from "@babel/parser";
+import getBabelOptions, { Overrides } from "./_babel_options.js";
+import * as babelParser from "@babel/parser";
+import * as babylon from "babylon";
+
+type BabelParser = { parse: typeof babelParse };
+
+// Prefer the new @babel/parser package, but fall back to babylon if
+// that's what's available.babel
+export const parser = (function (): BabelParser {
+  try {
+    return babelParser;
+  } catch {
+    try {
+      // @ts-expect-error
+      return babylon;
+    } catch {
+      throw new Error(
+        "Install @babel/parser to use the `typescript`, `flow`, or `babel` parsers",
+      );
+    }
+  }
+})();
+
+// This module is suitable for passing as options.parser when calling
+// recast.parse to process JavaScript code with Babel:
+//
+//   const ast = recast.parse(source, {
+//     parser: require("recast/parsers/babel")
+//   });
+//
+export function parse(source: string, options?: Overrides) {
+  const babelOptions = getBabelOptions(options);
+  babelOptions.plugins.push("jsx", "flow", "decoratorAutoAccessors");
+  return parser.parse(source, babelOptions);
+}
diff --git a/node_modules/recast/parsers/babylon.d.ts b/node_modules/recast/parsers/babylon.d.ts
index 60fce87..e89d904 100644
--- a/node_modules/recast/parsers/babylon.d.ts
+++ b/node_modules/recast/parsers/babylon.d.ts
@@ -1 +1 @@
-export * from "./babel";
+export * from "./babel.js";
diff --git a/node_modules/recast/parsers/babylon.js b/node_modules/recast/parsers/babylon.js
index a3ddb86..e0d8b72 100644
--- a/node_modules/recast/parsers/babylon.js
+++ b/node_modules/recast/parsers/babylon.js
@@ -1,4 +1,4 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 var tslib_1 = require("tslib");
-tslib_1.__exportStar(require("./babel"), exports);
+tslib_1.__exportStar(require("./babel.js"), exports);
diff --git a/node_modules/recast/parsers/babylon.ts b/node_modules/recast/parsers/babylon.ts
new file mode 100644
index 0000000..e89d904
--- /dev/null
+++ b/node_modules/recast/parsers/babylon.ts
@@ -0,0 +1 @@
+export * from "./babel.js";
diff --git a/node_modules/recast/parsers/esprima.d.ts b/node_modules/recast/parsers/esprima.d.ts
index 4ad6653..6437ad3 100644
--- a/node_modules/recast/parsers/esprima.d.ts
+++ b/node_modules/recast/parsers/esprima.d.ts
@@ -1 +1,2 @@
-export declare function parse(source: string, options?: any): any;
+import * as esprima from "esprima";
+export declare function parse(source: string, options?: any): esprima.Program;
diff --git a/node_modules/recast/parsers/esprima.js b/node_modules/recast/parsers/esprima.js
index 2c81e77..26bc7ac 100644
--- a/node_modules/recast/parsers/esprima.js
+++ b/node_modules/recast/parsers/esprima.js
@@ -1,6 +1,7 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.parse = void 0;
+var tslib_1 = require("tslib");
 // This module is suitable for passing as options.parser when calling
 // recast.parse to process ECMAScript code with Esprima:
 //
@@ -8,19 +9,21 @@ exports.parse = void 0;
 //     parser: require("recast/parsers/esprima")
 //   });
 //
-var util_1 = require("../lib/util");
+var util_js_1 = require("../lib/util.js");
+var esprima = tslib_1.__importStar(require("esprima"));
 function parse(source, options) {
     var comments = [];
-    var ast = require("esprima").parse(source, {
+    var ast = esprima.parse(source, {
         loc: true,
+        // @ts-expect-error
         locations: true,
         comment: true,
         onComment: comments,
-        range: (0, util_1.getOption)(options, "range", false),
-        tolerant: (0, util_1.getOption)(options, "tolerant", true),
+        range: (0, util_js_1.getOption)(options, "range", false),
+        tolerant: (0, util_js_1.getOption)(options, "tolerant", true),
         tokens: true,
-        jsx: (0, util_1.getOption)(options, "jsx", false),
-        sourceType: (0, util_1.getOption)(options, "sourceType", "module"),
+        jsx: (0, util_js_1.getOption)(options, "jsx", false),
+        sourceType: (0, util_js_1.getOption)(options, "sourceType", "module"),
     });
     if (!Array.isArray(ast.comments)) {
         ast.comments = comments;
diff --git a/node_modules/recast/parsers/esprima.ts b/node_modules/recast/parsers/esprima.ts
new file mode 100644
index 0000000..3210870
--- /dev/null
+++ b/node_modules/recast/parsers/esprima.ts
@@ -0,0 +1,33 @@
+"use strict";
+
+// This module is suitable for passing as options.parser when calling
+// recast.parse to process ECMAScript code with Esprima:
+//
+//   const ast = recast.parse(source, {
+//     parser: require("recast/parsers/esprima")
+//   });
+//
+import { getOption } from "../lib/util.js";
+import * as esprima from "esprima";
+
+export function parse(source: string, options?: any) {
+  const comments: any[] = [];
+  const ast = esprima.parse(source, {
+    loc: true,
+    // @ts-expect-error
+    locations: true,
+    comment: true,
+    onComment: comments,
+    range: getOption(options, "range", false),
+    tolerant: getOption(options, "tolerant", true),
+    tokens: true,
+    jsx: getOption(options, "jsx", false),
+    sourceType: getOption(options, "sourceType", "module"),
+  });
+
+  if (!Array.isArray(ast.comments)) {
+    ast.comments = comments;
+  }
+
+  return ast;
+}
diff --git a/node_modules/recast/parsers/flow.d.ts b/node_modules/recast/parsers/flow.d.ts
index 65e14fe..0a65345 100644
--- a/node_modules/recast/parsers/flow.d.ts
+++ b/node_modules/recast/parsers/flow.d.ts
@@ -1,2 +1,2 @@
-import { Overrides } from "./_babel_options";
+import { Overrides } from "./_babel_options.js";
 export declare function parse(source: string, options?: Overrides): import("@babel/parser").ParseResult<import("@babel/types").File>;
diff --git a/node_modules/recast/parsers/flow.js b/node_modules/recast/parsers/flow.js
index 780fa66..502d017 100644
--- a/node_modules/recast/parsers/flow.js
+++ b/node_modules/recast/parsers/flow.js
@@ -2,8 +2,8 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.parse = void 0;
 var tslib_1 = require("tslib");
-var babel_1 = require("./babel");
-var _babel_options_1 = tslib_1.__importDefault(require("./_babel_options"));
+var babel_js_1 = require("./babel.js");
+var _babel_options_js_1 = tslib_1.__importDefault(require("./_babel_options.js"));
 // This module is suitable for passing as options.parser when calling
 // recast.parse to process Flow code:
 //
@@ -12,8 +12,8 @@ var _babel_options_1 = tslib_1.__importDefault(require("./_babel_options"));
 //   });
 //
 function parse(source, options) {
-    var babelOptions = (0, _babel_options_1.default)(options);
+    var babelOptions = (0, _babel_options_js_1.default)(options);
     babelOptions.plugins.push("jsx", "flow");
-    return babel_1.parser.parse(source, babelOptions);
+    return babel_js_1.parser.parse(source, babelOptions);
 }
 exports.parse = parse;
diff --git a/node_modules/recast/parsers/flow.ts b/node_modules/recast/parsers/flow.ts
new file mode 100644
index 0000000..750959a
--- /dev/null
+++ b/node_modules/recast/parsers/flow.ts
@@ -0,0 +1,15 @@
+import { parser } from "./babel.js";
+import getBabelOptions, { Overrides } from "./_babel_options.js";
+
+// This module is suitable for passing as options.parser when calling
+// recast.parse to process Flow code:
+//
+//   const ast = recast.parse(source, {
+//     parser: require("recast/parsers/flow")
+//   });
+//
+export function parse(source: string, options?: Overrides) {
+  const babelOptions = getBabelOptions(options);
+  babelOptions.plugins.push("jsx", "flow");
+  return parser.parse(source, babelOptions);
+}
diff --git a/node_modules/recast/parsers/typescript.d.ts b/node_modules/recast/parsers/typescript.d.ts
index 65e14fe..0a65345 100644
--- a/node_modules/recast/parsers/typescript.d.ts
+++ b/node_modules/recast/parsers/typescript.d.ts
@@ -1,2 +1,2 @@
-import { Overrides } from "./_babel_options";
+import { Overrides } from "./_babel_options.js";
 export declare function parse(source: string, options?: Overrides): import("@babel/parser").ParseResult<import("@babel/types").File>;
diff --git a/node_modules/recast/parsers/typescript.js b/node_modules/recast/parsers/typescript.js
index ad9e2a2..61c502d 100644
--- a/node_modules/recast/parsers/typescript.js
+++ b/node_modules/recast/parsers/typescript.js
@@ -2,8 +2,8 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.parse = void 0;
 var tslib_1 = require("tslib");
-var babel_1 = require("./babel");
-var _babel_options_1 = tslib_1.__importDefault(require("./_babel_options"));
+var babel_js_1 = require("./babel.js");
+var _babel_options_js_1 = tslib_1.__importDefault(require("./_babel_options.js"));
 // This module is suitable for passing as options.parser when calling
 // recast.parse to process TypeScript code:
 //
@@ -12,8 +12,8 @@ var _babel_options_1 = tslib_1.__importDefault(require("./_babel_options"));
 //   });
 //
 function parse(source, options) {
-    var babelOptions = (0, _babel_options_1.default)(options);
+    var babelOptions = (0, _babel_options_js_1.default)(options);
     babelOptions.plugins.push("typescript");
-    return babel_1.parser.parse(source, babelOptions);
+    return babel_js_1.parser.parse(source, babelOptions);
 }
 exports.parse = parse;
diff --git a/node_modules/recast/parsers/typescript.ts b/node_modules/recast/parsers/typescript.ts
new file mode 100644
index 0000000..6325488
--- /dev/null
+++ b/node_modules/recast/parsers/typescript.ts
@@ -0,0 +1,15 @@
+import { parser } from "./babel.js";
+import getBabelOptions, { Overrides } from "./_babel_options.js";
+
+// This module is suitable for passing as options.parser when calling
+// recast.parse to process TypeScript code:
+//
+//   const ast = recast.parse(source, {
+//     parser: require("recast/parsers/typescript")
+//   });
+//
+export function parse(source: string, options?: Overrides) {
+  const babelOptions = getBabelOptions(options);
+  babelOptions.plugins.push("typescript");
+  return parser.parse(source, babelOptions);
+}
diff --git a/node_modules/recast/rename-mjs-output.mjs b/node_modules/recast/rename-mjs-output.mjs
new file mode 100644
index 0000000..c3ad722
--- /dev/null
+++ b/node_modules/recast/rename-mjs-output.mjs
@@ -0,0 +1,15 @@
+import { renameSync } from 'fs'
+import { resolve } from 'path'
+import * as glob from 'glob'
+import { fileURLToPath } from 'url'
+
+const __dirname = fileURLToPath(new URL('.', import.meta.url));
+
+// @ts-expect-error
+const files = glob.default.sync(`esm/**/*.js`)
+
+files.forEach((file) => {
+	const fullFilePath = resolve(__dirname, file)
+	renameSync(fullFilePath, fullFilePath.replace(/\.js$/, '.mjs'))
+})
+console.log('done');
diff --git a/node_modules/recast/tsconfig.cjs.json b/node_modules/recast/tsconfig.cjs.json
new file mode 100644
index 0000000..2c7b284
--- /dev/null
+++ b/node_modules/recast/tsconfig.cjs.json
@@ -0,0 +1,6 @@
+{
+  "extends": "./tsconfig.json",
+  "compilerOptions": {
+    "module": "commonjs"
+  }
+}
diff --git a/node_modules/recast/tsconfig.esm.json b/node_modules/recast/tsconfig.esm.json
new file mode 100644
index 0000000..fa7fbb7
--- /dev/null
+++ b/node_modules/recast/tsconfig.esm.json
@@ -0,0 +1,8 @@
+{
+  "extends": "./tsconfig.json",
+  "compilerOptions": {
+    "module": "ES2022",
+    "target": "ES2020",
+    "outDir": "esm"
+  }
+}
diff --git a/node_modules/recast/tsconfig.json b/node_modules/recast/tsconfig.json
index b11175e..9bf657b 100644
--- a/node_modules/recast/tsconfig.json
+++ b/node_modules/recast/tsconfig.json
@@ -2,20 +2,16 @@
   "compilerOptions": {
     "target": "es5",
     "lib": ["es2015"],
-    "module": "commonjs",
     "declaration": true,
     "rootDir": ".",
     "strict": true,
     "noUnusedLocals": true,
     "noUnusedParameters": true,
     "noImplicitReturns": true,
-    "moduleResolution": "node",
+    "moduleResolution": "node16",
     "esModuleInterop": true,
     "importHelpers": true,
     "stripInternal": true
   },
-  "exclude": [
-    "node_modules",
-    "test/data"
-  ]
+  "exclude": ["node_modules", "esm", "test/data"]
 }
